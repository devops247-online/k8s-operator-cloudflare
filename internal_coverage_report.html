
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/devops247-online/k8s-operator-cloudflare/internal/config/feature_flags.go (98.6%)</option>

				<option value="file1">github.com/devops247-online/k8s-operator-cloudflare/internal/config/loader.go (92.1%)</option>

				<option value="file2">github.com/devops247-online/k8s-operator-cloudflare/internal/config/manager.go (95.4%)</option>

				<option value="file3">github.com/devops247-online/k8s-operator-cloudflare/internal/config/types.go (90.1%)</option>

				<option value="file4">github.com/devops247-online/k8s-operator-cloudflare/internal/config/validation.go (96.0%)</option>

				<option value="file5">github.com/devops247-online/k8s-operator-cloudflare/internal/controller/cloudflarerecord_controller.go (97.4%)</option>

				<option value="file6">github.com/devops247-online/k8s-operator-cloudflare/internal/health/checker.go (92.6%)</option>

				<option value="file7">github.com/devops247-online/k8s-operator-cloudflare/internal/health/profiling.go (100.0%)</option>

				<option value="file8">github.com/devops247-online/k8s-operator-cloudflare/internal/health/shutdown.go (82.8%)</option>

				<option value="file9">github.com/devops247-online/k8s-operator-cloudflare/internal/logging/config.go (100.0%)</option>

				<option value="file10">github.com/devops247-online/k8s-operator-cloudflare/internal/logging/logger.go (89.7%)</option>

				<option value="file11">github.com/devops247-online/k8s-operator-cloudflare/internal/logging/middleware.go (95.5%)</option>

				<option value="file12">github.com/devops247-online/k8s-operator-cloudflare/internal/metrics/business.go (89.4%)</option>

				<option value="file13">github.com/devops247-online/k8s-operator-cloudflare/internal/metrics/cloudflare.go (93.5%)</option>

				<option value="file14">github.com/devops247-online/k8s-operator-cloudflare/internal/metrics/performance.go (92.9%)</option>

				<option value="file15">github.com/devops247-online/k8s-operator-cloudflare/internal/reliability/circuit_breaker.go (94.3%)</option>

				<option value="file16">github.com/devops247-online/k8s-operator-cloudflare/internal/reliability/rate_limiter.go (96.4%)</option>

				<option value="file17">github.com/devops247-online/k8s-operator-cloudflare/internal/reliability/reliability_integration_example.go (0.0%)</option>

				<option value="file18">github.com/devops247-online/k8s-operator-cloudflare/internal/reliability/retry.go (98.0%)</option>

				<option value="file19">github.com/devops247-online/k8s-operator-cloudflare/internal/slo/calculator.go (82.4%)</option>

				<option value="file20">github.com/devops247-online/k8s-operator-cloudflare/internal/slo/config.go (100.0%)</option>

				<option value="file21">github.com/devops247-online/k8s-operator-cloudflare/internal/slo/error_budget.go (95.2%)</option>

				<option value="file22">github.com/devops247-online/k8s-operator-cloudflare/internal/slo/recording_rules.go (88.2%)</option>

				<option value="file23">github.com/devops247-online/k8s-operator-cloudflare/internal/slo/slo.go (89.0%)</option>

				<option value="file24">github.com/devops247-online/k8s-operator-cloudflare/internal/tracing/config.go (100.0%)</option>

				<option value="file25">github.com/devops247-online/k8s-operator-cloudflare/internal/tracing/tracer.go (91.6%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "reflect"
        "sort"
        "strings"
        "sync"
)

// FeatureFlagManager provides thread-safe access to feature flags
type FeatureFlagManager struct {
        flags *FeatureFlags
        mutex sync.RWMutex
}

// NewFeatureFlagManager creates a new feature flag manager
func NewFeatureFlagManager(flags *FeatureFlags) *FeatureFlagManager <span class="cov9" title="74">{
        return &amp;FeatureFlagManager{
                flags: flags,
        }
}</span>

// IsEnabled checks if a specific feature flag is enabled
func (m *FeatureFlagManager) IsEnabled(flagName string) bool <span class="cov10" title="85">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.flags == nil </span><span class="cov3" title="3">{
                return false
        }</span>

        // Check standard flags first
        <span class="cov9" title="82">switch flagName </span>{
        case "EnableWebhooks":<span class="cov7" title="25">
                return m.flags.EnableWebhooks</span>
        case "EnableMetrics":<span class="cov6" title="15">
                return m.flags.EnableMetrics</span>
        case "EnableTracing":<span class="cov5" title="11">
                return m.flags.EnableTracing</span>
        case "ExperimentalFeatures":<span class="cov5" title="11">
                return m.flags.ExperimentalFeatures</span>
        }

        // Check custom flags
        <span class="cov7" title="20">if m.flags.CustomFlags != nil </span><span class="cov6" title="18">{
                if value, exists := m.flags.CustomFlags[flagName]; exists </span><span class="cov6" title="16">{
                        return value
                }</span>
        }

        <span class="cov3" title="4">return false</span>
}

// SetFlag sets a custom feature flag
func (m *FeatureFlagManager) SetFlag(flagName string, enabled bool) <span class="cov5" title="8">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.flags == nil </span><span class="cov1" title="1">{
                return // Cannot set flags on nil FeatureFlags
        }</span>

        // Initialize custom flags if nil
        <span class="cov4" title="7">if m.flags.CustomFlags == nil </span><span class="cov1" title="1">{
                m.flags.CustomFlags = make(map[string]bool)
        }</span>

        <span class="cov4" title="7">m.flags.CustomFlags[flagName] = enabled</span>
}

// GetAllFlags returns a map of all flags (standard and custom) with their values
func (m *FeatureFlagManager) GetAllFlags() map[string]bool <span class="cov5" title="8">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[string]bool)

        // Add standard flags
        if m.flags != nil </span><span class="cov4" title="6">{
                result["EnableWebhooks"] = m.flags.EnableWebhooks
                result["EnableMetrics"] = m.flags.EnableMetrics
                result["EnableTracing"] = m.flags.EnableTracing
                result["ExperimentalFeatures"] = m.flags.ExperimentalFeatures

                // Add custom flags
                if m.flags.CustomFlags != nil </span><span class="cov4" title="5">{
                        for k, v := range m.flags.CustomFlags </span><span class="cov5" title="9">{
                                result[k] = v
                        }</span>
                }
        } else<span class="cov2" title="2"> {
                // Default values when flags is nil
                result["EnableWebhooks"] = false
                result["EnableMetrics"] = false
                result["EnableTracing"] = false
                result["ExperimentalFeatures"] = false
        }</span>

        <span class="cov5" title="8">return result</span>
}

// GetEnabledFlags returns a slice of flag names that are currently enabled
func (m *FeatureFlagManager) GetEnabledFlags() []string <span class="cov3" title="3">{
        allFlags := m.GetAllFlags()
        var enabled []string

        for flagName, isEnabled := range allFlags </span><span class="cov6" title="18">{
                if isEnabled </span><span class="cov4" title="5">{
                        enabled = append(enabled, flagName)
                }</span>
        }

        // Sort for consistent ordering
        <span class="cov3" title="3">sort.Strings(enabled)
        return enabled</span>
}

// IsAnyEnabled checks if any of the specified flags are enabled
func (m *FeatureFlagManager) IsAnyEnabled(flagNames ...string) bool <span class="cov3" title="4">{
        for _, flagName := range flagNames </span><span class="cov4" title="5">{
                if m.IsEnabled(flagName) </span><span class="cov2" title="2">{
                        return true
                }</span>
        }
        <span class="cov2" title="2">return false</span>
}

// IsAllEnabled checks if all of the specified flags are enabled
func (m *FeatureFlagManager) IsAllEnabled(flagNames ...string) bool <span class="cov3" title="4">{
        if len(flagNames) == 0 </span><span class="cov1" title="1">{
                return true // vacuously true
        }</span>

        <span class="cov3" title="3">for _, flagName := range flagNames </span><span class="cov4" title="6">{
                if !m.IsEnabled(flagName) </span><span class="cov1" title="1">{
                        return false
                }</span>
        }
        <span class="cov2" title="2">return true</span>
}

// WithEnvironmentOverrides returns a new FeatureFlagManager with environment-specific overrides applied
func (m *FeatureFlagManager) WithEnvironmentOverrides(environment string) *FeatureFlagManager <span class="cov5" title="9">{
        m.mutex.RLock()
        clonedFlags := m.cloneFlags()
        m.mutex.RUnlock()

        // Apply environment-specific overrides
        switch environment </span>{
        case ProductionEnv:<span class="cov2" title="2">
                // Production should be conservative
                clonedFlags.EnableTracing = false        // Disable tracing in production for performance
                clonedFlags.ExperimentalFeatures = false</span> // Never allow experimental features in production

        case StagingEnv:<span class="cov2" title="2">
                // Staging allows more features for testing
                clonedFlags.EnableTracing = true         // Enable tracing in staging for debugging
                clonedFlags.ExperimentalFeatures = false</span> // Still disable experimental features for safety

        case DevelopmentEnv:<span class="cov2" title="2">
                // Development environment allows all features
                clonedFlags.EnableMetrics = true        // Always enable metrics in development
                clonedFlags.EnableTracing = true        // Enable tracing for debugging
                clonedFlags.ExperimentalFeatures = true</span> // Allow experimental features in development

        case TestEnv:<span class="cov1" title="1">
                // Test environment typically mirrors production but may need specific flags
                clonedFlags.EnableTracing = false
                clonedFlags.ExperimentalFeatures = false</span>
        }

        <span class="cov5" title="9">return NewFeatureFlagManager(clonedFlags)</span>
}

// Clone creates a deep copy of the FeatureFlagManager
func (m *FeatureFlagManager) Clone() *FeatureFlagManager <span class="cov3" title="3">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        clonedFlags := m.cloneFlags()
        return NewFeatureFlagManager(clonedFlags)
}</span>

// cloneFlags creates a deep copy of FeatureFlags (internal method, caller must hold lock)
func (m *FeatureFlagManager) cloneFlags() *FeatureFlags <span class="cov6" title="12">{
        if m.flags == nil </span><span class="cov1" title="1">{
                return &amp;FeatureFlags{
                        CustomFlags: make(map[string]bool),
                }
        }</span>

        <span class="cov5" title="11">cloned := &amp;FeatureFlags{
                EnableWebhooks:       m.flags.EnableWebhooks,
                EnableMetrics:        m.flags.EnableMetrics,
                EnableTracing:        m.flags.EnableTracing,
                ExperimentalFeatures: m.flags.ExperimentalFeatures,
                CustomFlags:          make(map[string]bool),
        }

        // Deep copy custom flags
        if m.flags.CustomFlags != nil </span><span class="cov4" title="7">{
                for k, v := range m.flags.CustomFlags </span><span class="cov4" title="6">{
                        cloned.CustomFlags[k] = v
                }</span>
        }

        <span class="cov5" title="11">return cloned</span>
}

// String returns a string representation of all feature flags
func (m *FeatureFlagManager) String() string <span class="cov2" title="2">{
        allFlags := m.GetAllFlags()

        var parts []string

        // Add standard flags in consistent order
        standardFlags := []string{"EnableWebhooks", "EnableMetrics", "EnableTracing", "ExperimentalFeatures"}
        for _, flag := range standardFlags </span><span class="cov5" title="8">{
                if value, exists := allFlags[flag]; exists </span><span class="cov5" title="8">{
                        parts = append(parts, fmt.Sprintf("%s=%t", flag, value))
                        delete(allFlags, flag) // Remove from map so we don't include it again
                }</span>
        }

        // Add custom flags in sorted order
        <span class="cov2" title="2">var customFlags []string
        for flag := range allFlags </span><span class="cov1" title="1">{
                customFlags = append(customFlags, flag)
        }</span>
        <span class="cov2" title="2">sort.Strings(customFlags)

        for _, flag := range customFlags </span><span class="cov1" title="1">{
                parts = append(parts, fmt.Sprintf("%s=%t", flag, allFlags[flag]))
        }</span>

        <span class="cov2" title="2">return "FeatureFlags{" + strings.Join(parts, ", ") + "}"</span>
}

// GetStandardFlags returns the values of all standard (non-custom) feature flags
func (m *FeatureFlagManager) GetStandardFlags() map[string]bool <span class="cov2" title="2">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[string]bool)

        if m.flags != nil </span><span class="cov1" title="1">{
                result["EnableWebhooks"] = m.flags.EnableWebhooks
                result["EnableMetrics"] = m.flags.EnableMetrics
                result["EnableTracing"] = m.flags.EnableTracing
                result["ExperimentalFeatures"] = m.flags.ExperimentalFeatures
        }</span> else<span class="cov1" title="1"> {
                result["EnableWebhooks"] = false
                result["EnableMetrics"] = false
                result["EnableTracing"] = false
                result["ExperimentalFeatures"] = false
        }</span>

        <span class="cov2" title="2">return result</span>
}

// GetCustomFlags returns a copy of all custom feature flags
func (m *FeatureFlagManager) GetCustomFlags() map[string]bool <span class="cov3" title="4">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        result := make(map[string]bool)

        if m.flags != nil &amp;&amp; m.flags.CustomFlags != nil </span><span class="cov2" title="2">{
                for k, v := range m.flags.CustomFlags </span><span class="cov2" title="2">{
                        result[k] = v
                }</span>
        }

        <span class="cov3" title="4">return result</span>
}

// HasFlag checks if a flag exists (regardless of its value)
func (m *FeatureFlagManager) HasFlag(flagName string) bool <span class="cov6" title="16">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.flags == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Check if it's a standard flag
        <span class="cov6" title="15">standardFlags := []string{"EnableWebhooks", "EnableMetrics", "EnableTracing", "ExperimentalFeatures"}
        for _, flag := range standardFlags </span><span class="cov8" title="46">{
                if flag == flagName </span><span class="cov4" title="7">{
                        return true
                }</span>
        }

        // Check if it's a custom flag
        <span class="cov5" title="8">if m.flags.CustomFlags != nil </span><span class="cov4" title="7">{
                _, exists := m.flags.CustomFlags[flagName]
                return exists
        }</span>

        <span class="cov1" title="1">return false</span>
}

// SetStandardFlag sets a standard feature flag using reflection
func (m *FeatureFlagManager) SetStandardFlag(flagName string, enabled bool) error <span class="cov6" title="13">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.flags == nil </span><span class="cov2" title="2">{
                m.flags = &amp;FeatureFlags{
                        CustomFlags: make(map[string]bool),
                }
        }</span>

        // Use reflection to set the standard flag
        <span class="cov6" title="13">flagsValue := reflect.ValueOf(m.flags).Elem()
        fieldValue := flagsValue.FieldByName(flagName)

        if !fieldValue.IsValid() </span><span class="cov3" title="3">{
                return fmt.Errorf("standard flag %s does not exist", flagName)
        }</span>

        <span class="cov5" title="10">if !fieldValue.CanSet() </span><span class="cov0" title="0">{
                return fmt.Errorf("cannot set standard flag %s", flagName)
        }</span>

        <span class="cov5" title="10">if fieldValue.Kind() != reflect.Bool </span><span class="cov0" title="0">{
                return fmt.Errorf("standard flag %s is not a boolean", flagName)
        }</span>

        <span class="cov5" title="10">fieldValue.SetBool(enabled)
        return nil</span>
}

// RemoveCustomFlag removes a custom feature flag
func (m *FeatureFlagManager) RemoveCustomFlag(flagName string) <span class="cov3" title="4">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.flags != nil &amp;&amp; m.flags.CustomFlags != nil </span><span class="cov2" title="2">{
                delete(m.flags.CustomFlags, flagName)
        }</span>
}

// ClearCustomFlags removes all custom feature flags
func (m *FeatureFlagManager) ClearCustomFlags() <span class="cov3" title="3">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.flags != nil </span><span class="cov2" title="2">{
                m.flags.CustomFlags = make(map[string]bool)
        }</span>
}
</pre>

		<pre class="file" id="file1" style="display: none">package config

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "strconv"
        "strings"
        "time"

        corev1 "k8s.io/api/core/v1"
        "k8s.io/apimachinery/pkg/api/errors"
        "k8s.io/apimachinery/pkg/types"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/yaml"
)

// ConfigLoader handles loading configuration from various sources
type ConfigLoader struct {
        client    client.Client
        namespace string
}

// LoadOptions specifies options for loading configuration
type LoadOptions struct {
        // FilePath specifies the path to a configuration file
        FilePath string

        // ConfigMapName specifies the name of a ConfigMap to load from
        ConfigMapName string

        // SecretName specifies the name of a Secret to load from
        SecretName string

        // LoadFromEnv indicates whether to load from environment variables
        LoadFromEnv bool

        // ValidateConfig indicates whether to validate the final configuration
        ValidateConfig bool
}

// WatchOptions specifies options for watching configuration changes
type WatchOptions struct {
        // ConfigMapName specifies the ConfigMap to watch
        ConfigMapName string

        // SecretName specifies the Secret to watch
        SecretName string

        // Interval specifies how often to check for changes
        Interval time.Duration
}

// NewConfigLoader creates a new configuration loader
func NewConfigLoader(kubeClient client.Client, namespace string) *ConfigLoader <span class="cov8" title="74">{
        return &amp;ConfigLoader{
                client:    kubeClient,
                namespace: namespace,
        }
}</span>

// LoadFromFile loads configuration from a file (JSON or YAML)
func (cl *ConfigLoader) LoadFromFile(filePath string) (*Config, error) <span class="cov5" title="14">{
        if filePath == "" </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("file path cannot be empty")
        }</span>

        // Validate file path to prevent path traversal
        <span class="cov5" title="13">cleanPath := filepath.Clean(filePath)
        if cleanPath != filePath </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid file path: path traversal detected")
        }</span>

        // #nosec G304 - file path is validated above
        <span class="cov5" title="13">data, err := os.ReadFile(cleanPath)
        if err != nil </span><span class="cov2" title="3">{
                return nil, fmt.Errorf("failed to read config file %s: %w", filePath, err)
        }</span>

        <span class="cov5" title="10">if len(data) == 0 </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config file %s is empty", filePath)
        }</span>

        <span class="cov4" title="9">config := &amp;Config{}

        // Determine file type by extension
        ext := strings.ToLower(filepath.Ext(filePath))
        switch ext </span>{
        case ".json":<span class="cov3" title="5">
                if err := json.Unmarshal(data, config); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse JSON config file %s: %w", filePath, err)
                }</span>
        case ".yaml", ".yml":<span class="cov2" title="2">
                if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov1" title="1">{
                        return nil, fmt.Errorf("failed to parse YAML config file %s: %w", filePath, err)
                }</span>
        default:<span class="cov2" title="2">
                // Try JSON first, then YAML
                if err := json.Unmarshal(data, config); err != nil </span><span class="cov2" title="2">{
                        if yamlErr := yaml.Unmarshal(data, config); yamlErr != nil </span><span class="cov1" title="1">{
                                return nil, fmt.Errorf("failed to parse config file %s as JSON or YAML: JSON error: %v, YAML error: %v", filePath, err, yamlErr)
                        }</span>
                }
        }

        <span class="cov4" title="6">return config, nil</span>
}

// LoadFromEnv loads configuration from environment variables
func (cl *ConfigLoader) LoadFromEnv() (*Config, error) <span class="cov5" title="14">{
        config := &amp;Config{
                ConfigSources: make(map[string]ConfigSource),
        }

        // Load basic fields
        if env := os.Getenv("CONFIG_ENVIRONMENT"); env != "" </span><span class="cov3" title="5">{
                config.Environment = env
                config.ConfigSources["environment"] = ConfigSourceEnv
        }</span>

        // Load operator configuration
        <span class="cov5" title="14">if logLevel := os.Getenv("CONFIG_OPERATOR_LOG_LEVEL"); logLevel != "" </span><span class="cov3" title="4">{
                config.Operator.LogLevel = logLevel
                config.ConfigSources["operator.logLevel"] = ConfigSourceEnv
        }</span>

        <span class="cov5" title="14">if reconcileInterval := os.Getenv("CONFIG_OPERATOR_RECONCILE_INTERVAL"); reconcileInterval != "" </span><span class="cov2" title="3">{
                if duration, err := time.ParseDuration(reconcileInterval); err == nil </span><span class="cov2" title="2">{
                        config.Operator.ReconcileInterval = duration
                        config.ConfigSources["operator.reconcileInterval"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if metricsAddr := os.Getenv("CONFIG_OPERATOR_METRICS_BIND_ADDRESS"); metricsAddr != "" </span><span class="cov1" title="1">{
                config.Operator.MetricsBindAddress = metricsAddr
                config.ConfigSources["operator.metricsBindAddress"] = ConfigSourceEnv
        }</span>

        <span class="cov5" title="14">if healthAddr := os.Getenv("CONFIG_OPERATOR_HEALTH_PROBE_BIND_ADDRESS"); healthAddr != "" </span><span class="cov1" title="1">{
                config.Operator.HealthProbeBindAddress = healthAddr
                config.ConfigSources["operator.healthProbeBindAddress"] = ConfigSourceEnv
        }</span>

        <span class="cov5" title="14">if leaderElection := os.Getenv("CONFIG_OPERATOR_LEADER_ELECTION"); leaderElection != "" </span><span class="cov1" title="1">{
                if enabled, err := strconv.ParseBool(leaderElection); err == nil </span><span class="cov1" title="1">{
                        config.Operator.LeaderElection = enabled
                        config.ConfigSources["operator.leaderElection"] = ConfigSourceEnv
                }</span>
        }

        // Load Cloudflare configuration
        <span class="cov5" title="14">if apiTimeout := os.Getenv("CONFIG_CLOUDFLARE_API_TIMEOUT"); apiTimeout != "" </span><span class="cov2" title="2">{
                if duration, err := time.ParseDuration(apiTimeout); err == nil </span><span class="cov2" title="2">{
                        config.Cloudflare.APITimeout = duration
                        config.ConfigSources["cloudflare.apiTimeout"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if rateLimitRPS := os.Getenv("CONFIG_CLOUDFLARE_RATE_LIMIT_RPS"); rateLimitRPS != "" </span><span class="cov4" title="6">{
                if rps, err := strconv.Atoi(rateLimitRPS); err == nil </span><span class="cov3" title="5">{
                        config.Cloudflare.RateLimitRPS = rps
                        config.ConfigSources["cloudflare.rateLimitRPS"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if retryAttempts := os.Getenv("CONFIG_CLOUDFLARE_RETRY_ATTEMPTS"); retryAttempts != "" </span><span class="cov1" title="1">{
                if attempts, err := strconv.Atoi(retryAttempts); err == nil </span><span class="cov1" title="1">{
                        config.Cloudflare.RetryAttempts = attempts
                        config.ConfigSources["cloudflare.retryAttempts"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if retryDelay := os.Getenv("CONFIG_CLOUDFLARE_RETRY_DELAY"); retryDelay != "" </span><span class="cov1" title="1">{
                if duration, err := time.ParseDuration(retryDelay); err == nil </span><span class="cov1" title="1">{
                        config.Cloudflare.RetryDelay = duration
                        config.ConfigSources["cloudflare.retryDelay"] = ConfigSourceEnv
                }</span>
        }

        // Load feature flags
        <span class="cov5" title="14">config.Features = &amp;FeatureFlags{
                CustomFlags: make(map[string]bool),
        }

        if enableWebhooks := os.Getenv("CONFIG_FEATURES_ENABLE_WEBHOOKS"); enableWebhooks != "" </span><span class="cov2" title="2">{
                if enabled, err := strconv.ParseBool(enableWebhooks); err == nil </span><span class="cov2" title="2">{
                        config.Features.EnableWebhooks = enabled
                        config.ConfigSources["features.enableWebhooks"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if enableMetrics := os.Getenv("CONFIG_FEATURES_ENABLE_METRICS"); enableMetrics != "" </span><span class="cov2" title="2">{
                if enabled, err := strconv.ParseBool(enableMetrics); err == nil </span><span class="cov2" title="2">{
                        config.Features.EnableMetrics = enabled
                        config.ConfigSources["features.enableMetrics"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if enableTracing := os.Getenv("CONFIG_FEATURES_ENABLE_TRACING"); enableTracing != "" </span><span class="cov2" title="2">{
                if enabled, err := strconv.ParseBool(enableTracing); err == nil </span><span class="cov2" title="2">{
                        config.Features.EnableTracing = enabled
                        config.ConfigSources["features.enableTracing"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if experimentalFeatures := os.Getenv("CONFIG_FEATURES_EXPERIMENTAL_FEATURES"); experimentalFeatures != "" </span><span class="cov2" title="2">{
                if enabled, err := strconv.ParseBool(experimentalFeatures); err == nil </span><span class="cov2" title="2">{
                        config.Features.ExperimentalFeatures = enabled
                        config.ConfigSources["features.experimentalFeatures"] = ConfigSourceEnv
                }</span>
        }

        // Load performance configuration
        <span class="cov5" title="14">if maxConcurrent := os.Getenv("CONFIG_PERFORMANCE_MAX_CONCURRENT_RECONCILES"); maxConcurrent != "" </span><span class="cov2" title="2">{
                if max, err := strconv.Atoi(maxConcurrent); err == nil </span><span class="cov2" title="2">{
                        config.Performance.MaxConcurrentReconciles = max
                        config.ConfigSources["performance.maxConcurrentReconciles"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if resyncPeriod := os.Getenv("CONFIG_PERFORMANCE_RESYNC_PERIOD"); resyncPeriod != "" </span><span class="cov2" title="2">{
                if duration, err := time.ParseDuration(resyncPeriod); err == nil </span><span class="cov2" title="2">{
                        config.Performance.ResyncPeriod = duration
                        config.ConfigSources["performance.resyncPeriod"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if leaseDuration := os.Getenv("CONFIG_PERFORMANCE_LEADER_ELECTION_LEASE_DURATION"); leaseDuration != "" </span><span class="cov2" title="2">{
                if duration, err := time.ParseDuration(leaseDuration); err == nil </span><span class="cov2" title="2">{
                        config.Performance.LeaderElectionLeaseDuration = duration
                        config.ConfigSources["performance.leaderElectionLeaseDuration"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if renewDeadline := os.Getenv("CONFIG_PERFORMANCE_LEADER_ELECTION_RENEW_DEADLINE"); renewDeadline != "" </span><span class="cov1" title="1">{
                if duration, err := time.ParseDuration(renewDeadline); err == nil </span><span class="cov1" title="1">{
                        config.Performance.LeaderElectionRenewDeadline = duration
                        config.ConfigSources["performance.leaderElectionRenewDeadline"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">if retryPeriod := os.Getenv("CONFIG_PERFORMANCE_LEADER_ELECTION_RETRY_PERIOD"); retryPeriod != "" </span><span class="cov1" title="1">{
                if duration, err := time.ParseDuration(retryPeriod); err == nil </span><span class="cov1" title="1">{
                        config.Performance.LeaderElectionRetryPeriod = duration
                        config.ConfigSources["performance.leaderElectionRetryPeriod"] = ConfigSourceEnv
                }</span>
        }

        <span class="cov5" title="14">return config, nil</span>
}

// LoadFromConfigMap loads configuration from a Kubernetes ConfigMap
func (cl *ConfigLoader) LoadFromConfigMap(ctx context.Context, name string) (*Config, error) <span class="cov6" title="19">{
        if cl.client == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("kubernetes client is required for loading from ConfigMap")
        }</span>

        <span class="cov6" title="18">configMap := &amp;corev1.ConfigMap{}
        err := cl.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: cl.namespace,
        }, configMap)
        if err != nil </span><span class="cov2" title="3">{
                if errors.IsNotFound(err) </span><span class="cov2" title="3">{
                        return nil, fmt.Errorf("ConfigMap %s/%s not found", cl.namespace, name)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get ConfigMap %s/%s: %w", cl.namespace, name, err)</span>
        }

        <span class="cov5" title="15">config := &amp;Config{
                ConfigSources: make(map[string]ConfigSource),
        }

        // Try to load from structured config files first
        for key, value := range configMap.Data </span><span class="cov6" title="29">{
                switch key </span>{
                case "config.json":<span class="cov2" title="2">
                        tempConfig := &amp;Config{}
                        if err := json.Unmarshal([]byte(value), tempConfig); err == nil </span><span class="cov1" title="1">{
                                config = config.Merge(tempConfig)
                                // Mark all fields as coming from ConfigMap
                                cl.markFieldsFromSource(config, ConfigSourceConfigMap)
                                return config, nil
                        }</span>
                case "config.yaml", "config.yml":<span class="cov2" title="2">
                        tempConfig := &amp;Config{}
                        if err := yaml.Unmarshal([]byte(value), tempConfig); err == nil </span><span class="cov1" title="1">{
                                config = config.Merge(tempConfig)
                                // Mark all fields as coming from ConfigMap
                                cl.markFieldsFromSource(config, ConfigSourceConfigMap)
                                return config, nil
                        }</span>
                }
        }

        // Load from individual keys
        <span class="cov5" title="13">if env, exists := configMap.Data["environment"]; exists </span><span class="cov5" title="13">{
                config.Environment = env
                config.ConfigSources["environment"] = ConfigSourceConfigMap
        }</span>

        <span class="cov5" title="13">if logLevel, exists := configMap.Data["log-level"]; exists </span><span class="cov4" title="7">{
                config.Operator.LogLevel = logLevel
                config.ConfigSources["operator.logLevel"] = ConfigSourceConfigMap
        }</span>

        <span class="cov5" title="13">if reconcileInterval, exists := configMap.Data["reconcile-interval"]; exists </span><span class="cov0" title="0">{
                if duration, err := time.ParseDuration(reconcileInterval); err == nil </span><span class="cov0" title="0">{
                        config.Operator.ReconcileInterval = duration
                        config.ConfigSources["operator.reconcileInterval"] = ConfigSourceConfigMap
                }</span>
        }

        <span class="cov5" title="13">if apiTimeout, exists := configMap.Data["api-timeout"]; exists </span><span class="cov3" title="4">{
                if duration, err := time.ParseDuration(apiTimeout); err == nil </span><span class="cov3" title="4">{
                        config.Cloudflare.APITimeout = duration
                        config.ConfigSources["cloudflare.apiTimeout"] = ConfigSourceConfigMap
                }</span>
        }

        <span class="cov5" title="13">if rateLimitRPS, exists := configMap.Data["rate-limit-rps"]; exists </span><span class="cov1" title="1">{
                if rps, err := strconv.Atoi(rateLimitRPS); err == nil </span><span class="cov1" title="1">{
                        config.Cloudflare.RateLimitRPS = rps
                        config.ConfigSources["cloudflare.rateLimitRPS"] = ConfigSourceConfigMap
                }</span>
        }

        <span class="cov5" title="13">return config, nil</span>
}

// LoadFromSecret loads configuration from a Kubernetes Secret
func (cl *ConfigLoader) LoadFromSecret(ctx context.Context, name string) (*Config, error) <span class="cov4" title="8">{
        if cl.client == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("kubernetes client is required for loading from Secret")
        }</span>

        <span class="cov4" title="7">secret := &amp;corev1.Secret{}
        err := cl.client.Get(ctx, types.NamespacedName{
                Name:      name,
                Namespace: cl.namespace,
        }, secret)
        if err != nil </span><span class="cov2" title="2">{
                if errors.IsNotFound(err) </span><span class="cov2" title="2">{
                        return nil, fmt.Errorf("secret %s/%s not found", cl.namespace, name)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get Secret %s/%s: %w", cl.namespace, name, err)</span>
        }

        <span class="cov3" title="5">config := &amp;Config{
                ConfigSources: make(map[string]ConfigSource),
        }

        // Try to load from structured config files first
        for key, value := range secret.Data </span><span class="cov4" title="6">{
                switch key </span>{
                case "config.json":<span class="cov2" title="2">
                        tempConfig := &amp;Config{}
                        if err := json.Unmarshal(value, tempConfig); err == nil </span><span class="cov2" title="2">{
                                config = config.Merge(tempConfig)
                                // Mark all fields as coming from Secret
                                cl.markFieldsFromSource(config, ConfigSourceSecret)
                                return config, nil
                        }</span>
                case "config.yaml", "config.yml":<span class="cov1" title="1">
                        tempConfig := &amp;Config{}
                        if err := yaml.Unmarshal(value, tempConfig); err == nil </span><span class="cov1" title="1">{
                                config = config.Merge(tempConfig)
                                // Mark all fields as coming from Secret
                                cl.markFieldsFromSource(config, ConfigSourceSecret)
                                return config, nil
                        }</span>
                }
        }

        // Load from individual keys
        <span class="cov2" title="2">if env, exists := secret.Data["environment"]; exists </span><span class="cov1" title="1">{
                config.Environment = string(env)
                config.ConfigSources["environment"] = ConfigSourceSecret
        }</span>

        <span class="cov2" title="2">if apiTimeout, exists := secret.Data["api-timeout"]; exists </span><span class="cov1" title="1">{
                if duration, err := time.ParseDuration(string(apiTimeout)); err == nil </span><span class="cov1" title="1">{
                        config.Cloudflare.APITimeout = duration
                        config.ConfigSources["cloudflare.apiTimeout"] = ConfigSourceSecret
                }</span>
        }

        <span class="cov2" title="2">if rateLimitRPS, exists := secret.Data["rate-limit-rps"]; exists </span><span class="cov1" title="1">{
                if rps, err := strconv.Atoi(string(rateLimitRPS)); err == nil </span><span class="cov1" title="1">{
                        config.Cloudflare.RateLimitRPS = rps
                        config.ConfigSources["cloudflare.rateLimitRPS"] = ConfigSourceSecret
                }</span>
        }

        <span class="cov2" title="2">return config, nil</span>
}

// LoadWithPriority loads configuration from multiple sources with priority:
// Environment variables &gt; ConfigMap &gt; Secret &gt; File &gt; Defaults
func (cl *ConfigLoader) LoadWithPriority(ctx context.Context, options LoadOptions) (*Config, map[string]ConfigSource, error) <span class="cov6" title="18">{
        if err := options.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, nil, fmt.Errorf("invalid load options: %w", err)
        }</span>

        // Start with defaults
        <span class="cov5" title="17">config := NewConfig()
        sources := make(map[string]ConfigSource)

        // Mark all default values
        cl.markFieldsFromSource(config, ConfigSourceDefault)
        for key := range config.ConfigSources </span><span class="cov10" title="170">{
                sources[key] = ConfigSourceDefault
        }</span>

        // Load from file (lowest priority after defaults)
        <span class="cov5" title="17">if options.FilePath != "" </span><span class="cov2" title="3">{
                fileConfig, err := cl.LoadFromFile(options.FilePath)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to load from file: %w", err)
                }</span>
                <span class="cov2" title="3">config = config.Merge(fileConfig)
                cl.markFieldsFromSource(fileConfig, ConfigSourceFile)
                for key := range fileConfig.ConfigSources </span><span class="cov4" title="8">{
                        sources[key] = ConfigSourceFile
                }</span>
        }

        // Load from Secret
        <span class="cov5" title="17">if options.SecretName != "" </span><span class="cov1" title="1">{
                secretConfig, err := cl.LoadFromSecret(ctx, options.SecretName)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to load from Secret: %w", err)
                }</span>
                <span class="cov1" title="1">config = config.Merge(secretConfig)
                for key, source := range secretConfig.ConfigSources </span><span class="cov1" title="1">{
                        sources[key] = source
                }</span>
        }

        // Load from ConfigMap
        <span class="cov5" title="17">if options.ConfigMapName != "" </span><span class="cov5" title="11">{
                configMapConfig, err := cl.LoadFromConfigMap(ctx, options.ConfigMapName)
                if err != nil </span><span class="cov1" title="1">{
                        return nil, nil, fmt.Errorf("failed to load from ConfigMap: %w", err)
                }</span>
                <span class="cov5" title="10">config = config.Merge(configMapConfig)
                for key, source := range configMapConfig.ConfigSources </span><span class="cov5" title="17">{
                        sources[key] = source
                }</span>
        }

        // Load from environment variables (highest priority)
        <span class="cov5" title="16">if options.LoadFromEnv </span><span class="cov4" title="9">{
                envConfig, err := cl.LoadFromEnv()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, fmt.Errorf("failed to load from environment: %w", err)
                }</span>
                <span class="cov4" title="9">config = config.Merge(envConfig)
                for key, source := range envConfig.ConfigSources </span><span class="cov4" title="8">{
                        sources[key] = source
                }</span>
        }

        // Validate if requested
        <span class="cov5" title="16">if options.ValidateConfig </span><span class="cov5" title="11">{
                if err := config.Validate(); err != nil </span><span class="cov2" title="2">{
                        return nil, nil, fmt.Errorf("configuration validation failed: %w", err)
                }</span>
        }

        <span class="cov5" title="14">return config, sources, nil</span>
}

// WatchConfig watches for configuration changes and returns channels for updates
func (cl *ConfigLoader) WatchConfig(ctx context.Context, options WatchOptions) (&lt;-chan *Config, &lt;-chan error) <span class="cov2" title="3">{
        if err := options.Validate(); err != nil </span><span class="cov1" title="1">{
                errorChan := make(chan error, 1)
                errorChan &lt;- fmt.Errorf("invalid watch options: %w", err)
                close(errorChan)
                return nil, errorChan
        }</span>

        <span class="cov2" title="2">configChan := make(chan *Config, 1)
        errorChan := make(chan error, 1)

        go func() </span><span class="cov2" title="2">{
                defer close(configChan)
                defer close(errorChan)

                ticker := time.NewTicker(options.Interval)
                defer ticker.Stop()

                var lastConfig *Config

                // Load initial configuration
                loadOptions := LoadOptions{
                        ConfigMapName:  options.ConfigMapName,
                        SecretName:     options.SecretName,
                        LoadFromEnv:    true,
                        ValidateConfig: true,
                }

                config, _, err := cl.LoadWithPriority(ctx, loadOptions)
                if err != nil </span><span class="cov1" title="1">{
                        select </span>{
                        case errorChan &lt;- err:<span class="cov1" title="1"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                        <span class="cov1" title="1">return</span>
                }

                <span class="cov1" title="1">lastConfig = config
                select </span>{
                case configChan &lt;- config:<span class="cov1" title="1"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                }

                // Watch for changes
                <span class="cov1" title="1">for </span><span class="cov1" title="1">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                newConfig, _, err := cl.LoadWithPriority(ctx, loadOptions)
                                if err != nil </span><span class="cov0" title="0">{
                                        select </span>{
                                        case errorChan &lt;- err:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                        <span class="cov0" title="0">continue</span>
                                }

                                // Check if configuration changed (simple string comparison)
                                <span class="cov0" title="0">lastJSON, _ := lastConfig.ToJSON()
                                newJSON, _ := newConfig.ToJSON()
                                if string(lastJSON) != string(newJSON) </span><span class="cov0" title="0">{
                                        lastConfig = newConfig
                                        select </span>{
                                        case configChan &lt;- newConfig:<span class="cov0" title="0"></span>
                                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                                return</span>
                                        }
                                }

                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                return</span>
                        }
                }
        }()

        <span class="cov2" title="2">return configChan, errorChan</span>
}

// markFieldsFromSource marks all non-zero fields in config as coming from the specified source
func (cl *ConfigLoader) markFieldsFromSource(config *Config, source ConfigSource) <span class="cov6" title="25">{
        if config.ConfigSources == nil </span><span class="cov2" title="3">{
                config.ConfigSources = make(map[string]ConfigSource)
        }</span>

        <span class="cov6" title="25">if config.Environment != "" </span><span class="cov6" title="25">{
                config.ConfigSources["environment"] = source
        }</span>
        <span class="cov6" title="25">if config.Operator.LogLevel != "" </span><span class="cov6" title="23">{
                config.ConfigSources["operator.logLevel"] = source
        }</span>
        <span class="cov6" title="25">if config.Operator.ReconcileInterval != 0 </span><span class="cov6" title="22">{
                config.ConfigSources["operator.reconcileInterval"] = source
        }</span>
        <span class="cov6" title="25">if config.Operator.MetricsBindAddress != "" </span><span class="cov5" title="17">{
                config.ConfigSources["operator.metricsBindAddress"] = source
        }</span>
        <span class="cov6" title="25">if config.Operator.HealthProbeBindAddress != "" </span><span class="cov5" title="17">{
                config.ConfigSources["operator.healthProbeBindAddress"] = source
        }</span>
        <span class="cov6" title="25">if config.Cloudflare.APITimeout != 0 </span><span class="cov6" title="19">{
                config.ConfigSources["cloudflare.apiTimeout"] = source
        }</span>
        <span class="cov6" title="25">if config.Cloudflare.RateLimitRPS != 0 </span><span class="cov6" title="19">{
                config.ConfigSources["cloudflare.rateLimitRPS"] = source
        }</span>
        <span class="cov6" title="25">if config.Performance.MaxConcurrentReconciles != 0 </span><span class="cov5" title="17">{
                config.ConfigSources["performance.maxConcurrentReconciles"] = source
        }</span>
        <span class="cov6" title="25">if config.Performance.ResyncPeriod != 0 </span><span class="cov5" title="17">{
                config.ConfigSources["performance.resyncPeriod"] = source
        }</span>
        <span class="cov6" title="25">if config.Performance.LeaderElectionLeaseDuration != 0 </span><span class="cov5" title="17">{
                config.ConfigSources["performance.leaderElectionLeaseDuration"] = source
        }</span>
}

// Validate validates the load options
func (opts *LoadOptions) Validate() error <span class="cov6" title="21">{
        if opts.FilePath == "" &amp;&amp; opts.ConfigMapName == "" &amp;&amp; opts.SecretName == "" &amp;&amp; !opts.LoadFromEnv </span><span class="cov2" title="2">{
                return fmt.Errorf("at least one configuration source must be specified")
        }</span>
        <span class="cov6" title="19">return nil</span>
}

// Validate validates the watch options
func (opts *WatchOptions) Validate() error <span class="cov4" title="6">{
        if opts.ConfigMapName == "" &amp;&amp; opts.SecretName == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("at least one resource to watch must be specified")
        }</span>

        <span class="cov3" title="4">if opts.Interval &lt; 1*time.Second </span><span class="cov1" title="1">{
                return fmt.Errorf("watch interval must be at least 1 second, got: %v", opts.Interval)
        }</span>

        <span class="cov2" title="3">return nil</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">package config

import (
        "context"
        "fmt"
        "sync"
        "time"

        "sigs.k8s.io/controller-runtime/pkg/client"
)

// ConfigChangeCallback is called when configuration changes
type ConfigChangeCallback func(oldConfig, newConfig *Config)

// ManagerOptions contains options for the configuration manager
type ManagerOptions struct {
        // Environment specifies the default environment if not loaded from config
        Environment string

        // AutoReload enables automatic configuration reloading
        AutoReload bool

        // ReloadInterval specifies how often to check for configuration changes
        ReloadInterval time.Duration

        // ValidateOnLoad validates configuration after loading
        ValidateOnLoad bool
}

// ConfigManager manages configuration loading, reloading, and change notifications
type ConfigManager struct {
        client    client.Client
        namespace string
        options   *ManagerOptions

        // Current state
        currentConfig  *Config
        currentSources map[string]ConfigSource
        loadedAt       time.Time
        loadOptions    *LoadOptions

        // Thread safety
        mutex sync.RWMutex

        // Change notifications
        callbacks []ConfigChangeCallback

        // Auto-reload control
        reloadCancel context.CancelFunc

        // Internal components
        loader             *ConfigLoader
        featureFlagManager *FeatureFlagManager
}

// NewConfigManager creates a new configuration manager with default options
func NewConfigManager(kubeClient client.Client, namespace string) *ConfigManager <span class="cov9" title="26">{
        return NewConfigManagerWithOptions(kubeClient, namespace, &amp;ManagerOptions{
                Environment:    ProductionEnv,
                AutoReload:     false,
                ReloadInterval: 5 * time.Minute,
                ValidateOnLoad: true,
        })
}</span>

// NewConfigManagerWithOptions creates a new configuration manager with custom options
func NewConfigManagerWithOptions(kubeClient client.Client, namespace string, options *ManagerOptions) *ConfigManager <span class="cov10" title="35">{
        if options == nil </span><span class="cov1" title="1">{
                options = &amp;ManagerOptions{
                        Environment:    ProductionEnv,
                        AutoReload:     false,
                        ReloadInterval: 5 * time.Minute,
                        ValidateOnLoad: true,
                }
        }</span>

        // Set defaults for missing values
        <span class="cov10" title="35">if options.ReloadInterval == 0 </span><span class="cov2" title="2">{
                options.ReloadInterval = 5 * time.Minute
        }</span>

        <span class="cov10" title="35">return &amp;ConfigManager{
                client:    kubeClient,
                namespace: namespace,
                options:   options,
                loader:    NewConfigLoader(kubeClient, namespace),
                callbacks: make([]ConfigChangeCallback, 0),
        }</span>
}

// LoadConfig loads configuration from the specified sources
func (m *ConfigManager) LoadConfig(ctx context.Context, options LoadOptions) (*Config, error) <span class="cov6" title="10">{
        // Set default validation if not specified
        if !options.ValidateConfig </span><span class="cov6" title="8">{
                options.ValidateConfig = m.options.ValidateOnLoad
        }</span>

        // Load configuration using the loader
        <span class="cov6" title="10">config, sources, err := m.loader.LoadWithPriority(ctx, options)
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to load configuration: %w", err)
        }</span>

        // Apply environment-specific overrides if manager has a default environment
        <span class="cov6" title="9">if config.Environment == "" &amp;&amp; m.options.Environment != "" </span><span class="cov0" title="0">{
                config.Environment = m.options.Environment
        }</span>

        // Store the load options for future reloads
        <span class="cov6" title="9">m.mutex.Lock()
        oldConfig := m.currentConfig
        m.currentConfig = config
        m.currentSources = sources
        m.loadedAt = time.Now()
        m.loadOptions = &amp;options
        m.featureFlagManager = NewFeatureFlagManager(config.Features)
        m.mutex.Unlock()

        // Notify callbacks of config change
        if oldConfig != nil </span><span class="cov1" title="1">{
                m.notifyCallbacks(oldConfig, config)
        }</span>

        <span class="cov6" title="9">return config, nil</span>
}

// ReloadConfig reloads the configuration using the same options as the last load
func (m *ConfigManager) ReloadConfig(ctx context.Context) (*Config, error) <span class="cov3" title="3">{
        m.mutex.RLock()
        loadOptions := m.loadOptions
        m.mutex.RUnlock()

        if loadOptions == nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("no load options available for reload - LoadConfig must be called first")
        }</span>

        <span class="cov1" title="1">return m.LoadConfig(ctx, *loadOptions)</span>
}

// GetConfig returns the current configuration (thread-safe)
func (m *ConfigManager) GetConfig() *Config <span class="cov7" title="13">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.currentConfig == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="12">return m.currentConfig.Copy()</span>
}

// GetFeatureFlagManager returns the feature flag manager for the current configuration
func (m *ConfigManager) GetFeatureFlagManager() *FeatureFlagManager <span class="cov3" title="3">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.featureFlagManager == nil </span><span class="cov2" title="2">{
                return nil
        }</span>

        <span class="cov1" title="1">return m.featureFlagManager.Clone()</span>
}

// RegisterConfigChangeCallback registers a callback to be called when configuration changes
func (m *ConfigManager) RegisterConfigChangeCallback(callback ConfigChangeCallback) <span class="cov3" title="3">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        m.callbacks = append(m.callbacks, callback)
}</span>

// StartAutoReload starts automatic configuration reloading (if enabled)
func (m *ConfigManager) StartAutoReload(ctx context.Context) error <span class="cov4" title="4">{
        if !m.options.AutoReload </span><span class="cov2" title="2">{
                return fmt.Errorf("auto-reload is not enabled")
        }</span>

        <span class="cov2" title="2">m.mutex.Lock()
        if m.reloadCancel != nil </span><span class="cov0" title="0">{
                m.reloadCancel() // Cancel any existing reload
        }</span>

        <span class="cov2" title="2">reloadCtx, cancel := context.WithCancel(ctx)
        m.reloadCancel = cancel
        m.mutex.Unlock()

        go m.autoReloadLoop(reloadCtx)

        return nil</span>
}

// StopAutoReload stops automatic configuration reloading
func (m *ConfigManager) StopAutoReload() <span class="cov5" title="5">{
        m.mutex.Lock()
        defer m.mutex.Unlock()

        if m.reloadCancel != nil </span><span class="cov1" title="1">{
                m.reloadCancel()
                m.reloadCancel = nil
        }</span>
}

// IsConfigured returns true if configuration has been loaded
func (m *ConfigManager) IsConfigured() bool <span class="cov7" title="12">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.currentConfig != nil
}</span>

// GetConfigSources returns a copy of the configuration sources map
func (m *ConfigManager) GetConfigSources() map[string]ConfigSource <span class="cov7" title="12">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        if m.currentSources == nil </span><span class="cov7" title="11">{
                return make(map[string]ConfigSource)
        }</span>

        <span class="cov1" title="1">result := make(map[string]ConfigSource)
        for k, v := range m.currentSources </span><span class="cov2" title="2">{
                result[k] = v
        }</span>

        <span class="cov1" title="1">return result</span>
}

// GetLoadedAt returns the time when the configuration was last loaded
func (m *ConfigManager) GetLoadedAt() time.Time <span class="cov2" title="2">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        return m.loadedAt
}</span>

// ValidateConfiguration validates the current configuration
func (m *ConfigManager) ValidateConfiguration() error <span class="cov4" title="4">{
        m.mutex.RLock()
        config := m.currentConfig
        m.mutex.RUnlock()

        if config == nil </span><span class="cov2" title="2">{
                return fmt.Errorf("no configuration loaded")
        }</span>

        <span class="cov2" title="2">return config.Validate()</span>
}

// GetNamespace returns the namespace used by this manager
func (m *ConfigManager) GetNamespace() string <span class="cov1" title="1">{
        return m.namespace
}</span>

// GetOptions returns a copy of the manager options
func (m *ConfigManager) GetOptions() ManagerOptions <span class="cov3" title="3">{
        return *m.options
}</span>

// autoReloadLoop runs the automatic reload loop
func (m *ConfigManager) autoReloadLoop(ctx context.Context) <span class="cov2" title="2">{
        ticker := time.NewTicker(m.options.ReloadInterval)
        defer ticker.Stop()

        for </span><span class="cov2" title="2">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        // Attempt to reload configuration
                        _, err := m.ReloadConfig(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                // In a real implementation, we might want to log this error
                                // For now, we'll continue trying
                                continue</span>
                        }

                case &lt;-ctx.Done():<span class="cov2" title="2">
                        return</span>
                }
        }
}

// notifyCallbacks notifies all registered callbacks of a configuration change
func (m *ConfigManager) notifyCallbacks(oldConfig, newConfig *Config) <span class="cov3" title="3">{
        // Make copies to avoid race conditions
        oldCopy := oldConfig.Copy()
        newCopy := newConfig.Copy()

        // Call callbacks in separate goroutines to avoid blocking
        for _, callback := range m.callbacks </span><span class="cov4" title="4">{
                go func(cb ConfigChangeCallback) </span><span class="cov4" title="4">{
                        defer func() </span><span class="cov4" title="4">{
                                if r := recover(); r != nil </span><span class="cov0" title="0">{
                                        // Handle panics in callbacks gracefully
                                        // Log the panic and continue with other callbacks
                                        _ = r // Acknowledge recovery value
                                }</span>
                        }()
                        <span class="cov4" title="4">cb(oldCopy, newCopy)</span>
                }(callback)
        }
}

// updateConfig updates the current configuration (internal method)
func (m *ConfigManager) updateConfig(newConfig *Config) <span class="cov2" title="2">{
        m.mutex.Lock()
        oldConfig := m.currentConfig
        m.currentConfig = newConfig
        m.loadedAt = time.Now()
        if newConfig != nil &amp;&amp; newConfig.Features != nil </span><span class="cov2" title="2">{
                m.featureFlagManager = NewFeatureFlagManager(newConfig.Features)
        }</span>
        <span class="cov2" title="2">m.mutex.Unlock()

        if oldConfig != nil </span><span class="cov2" title="2">{
                m.notifyCallbacks(oldConfig, newConfig)
        }</span>
}

// Validate validates the manager options
func (opts *ManagerOptions) Validate() error <span class="cov5" title="6">{
        if opts.Environment != "" </span><span class="cov3" title="3">{
                if err := ValidateEnvironment(opts.Environment); err != nil </span><span class="cov2" title="2">{
                        return fmt.Errorf("invalid environment in options: %w", err)
                }</span>
        }

        <span class="cov4" title="4">if opts.AutoReload &amp;&amp; opts.ReloadInterval &lt; 1*time.Second </span><span class="cov3" title="3">{
                return fmt.Errorf("reload interval must be at least 1 second when auto-reload is enabled, got: %v", opts.ReloadInterval)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// String returns a string representation of the manager options
func (opts *ManagerOptions) String() string <span class="cov2" title="2">{
        return fmt.Sprintf("ManagerOptions{Environment: %s, AutoReload: %v, ReloadInterval: %v, ValidateOnLoad: %v}",
                opts.Environment, opts.AutoReload, opts.ReloadInterval, opts.ValidateOnLoad)
}</span>

// String returns a string representation of the configuration manager
func (m *ConfigManager) String() string <span class="cov2" title="2">{
        m.mutex.RLock()
        defer m.mutex.RUnlock()

        status := "not configured"
        if m.currentConfig != nil </span><span class="cov1" title="1">{
                status = fmt.Sprintf("configured (loaded at %s)", m.loadedAt.Format(time.RFC3339))
        }</span>

        <span class="cov2" title="2">autoReload := "disabled"
        if m.options.AutoReload </span><span class="cov1" title="1">{
                autoReload = fmt.Sprintf("enabled (interval: %v)", m.options.ReloadInterval)
        }</span>

        <span class="cov2" title="2">return fmt.Sprintf("ConfigManager{namespace: %s, status: %s, auto-reload: %s, callbacks: %d}",
                m.namespace, status, autoReload, len(m.callbacks))</span>
}

// Close gracefully shuts down the configuration manager
func (m *ConfigManager) Close() error <span class="cov2" title="2">{
        m.StopAutoReload()

        m.mutex.Lock()
        defer m.mutex.Unlock()

        // Clear callbacks
        m.callbacks = nil

        // Clear current state
        m.currentConfig = nil
        m.currentSources = nil
        m.featureFlagManager = nil
        m.loadOptions = nil

        return nil
}</span>
</pre>

		<pre class="file" id="file3" style="display: none">package config

import (
        "encoding/json"
        "fmt"
        "time"
)

// ConfigSource represents the source of configuration
//
//nolint:revive // ConfigSource name is intentional for this package
type ConfigSource int

const (
        // ConfigSourceDefault indicates default configuration
        ConfigSourceDefault ConfigSource = iota
        // ConfigSourceEnv indicates configuration from environment variables
        ConfigSourceEnv
        // ConfigSourceFile indicates configuration from file
        ConfigSourceFile
        // ConfigSourceConfigMap indicates configuration from ConfigMap
        ConfigSourceConfigMap
        // ConfigSourceSecret indicates configuration from Secret
        ConfigSourceSecret
)

// String returns the string representation of ConfigSource
func (cs ConfigSource) String() string <span class="cov5" title="12">{
        switch cs </span>{
        case ConfigSourceDefault:<span class="cov2" title="2">
                return "default"</span>
        case ConfigSourceEnv:<span class="cov2" title="2">
                return "env"</span>
        case ConfigSourceFile:<span class="cov2" title="2">
                return "file"</span>
        case ConfigSourceConfigMap:<span class="cov2" title="2">
                return "configmap"</span>
        case ConfigSourceSecret:<span class="cov2" title="2">
                return "secret"</span>
        default:<span class="cov2" title="2">
                return "unknown"</span>
        }
}

// Config represents the complete operator configuration
type Config struct {
        // Environment specifies the deployment environment (production, staging, development)
        Environment string `json:"environment" yaml:"environment"`

        // Operator contains operator-specific configuration
        Operator OperatorConfig `json:"operator" yaml:"operator"`

        // Cloudflare contains Cloudflare API configuration
        Cloudflare CloudflareConfig `json:"cloudflare" yaml:"cloudflare"`

        // Features contains feature flags
        Features *FeatureFlags `json:"features,omitempty" yaml:"features,omitempty"`

        // Performance contains performance tuning configuration
        Performance PerformanceConfig `json:"performance" yaml:"performance"`

        // ConfigSources tracks where each configuration value came from
        ConfigSources map[string]ConfigSource `json:"-" yaml:"-"`
}

// OperatorConfig contains operator-specific settings
type OperatorConfig struct {
        // LogLevel specifies the logging level (debug, info, warn, error)
        LogLevel string `json:"logLevel" yaml:"logLevel"`

        // ReconcileInterval specifies how often to reconcile resources
        ReconcileInterval time.Duration `json:"reconcileInterval" yaml:"reconcileInterval"`

        // MetricsBindAddress is the address the metric endpoint binds to
        MetricsBindAddress string `json:"metricsBindAddress,omitempty" yaml:"metricsBindAddress,omitempty"`

        // HealthProbeBindAddress is the address the health probe endpoint binds to
        HealthProbeBindAddress string `json:"healthProbeBindAddress,omitempty" yaml:"healthProbeBindAddress,omitempty"`

        // LeaderElection enables leader election for controller manager
        LeaderElection bool `json:"leaderElection" yaml:"leaderElection"`
}

// CloudflareConfig contains Cloudflare API settings
type CloudflareConfig struct {
        // APITimeout specifies the timeout for Cloudflare API calls
        APITimeout time.Duration `json:"apiTimeout" yaml:"apiTimeout"`

        // RateLimitRPS specifies the rate limit in requests per second
        RateLimitRPS int `json:"rateLimitRPS" yaml:"rateLimitRPS"`

        // RetryAttempts specifies the number of retry attempts for failed API calls
        RetryAttempts int `json:"retryAttempts,omitempty" yaml:"retryAttempts,omitempty"`

        // RetryDelay specifies the delay between retry attempts
        RetryDelay time.Duration `json:"retryDelay,omitempty" yaml:"retryDelay,omitempty"`
}

// FeatureFlags contains feature toggle configuration
type FeatureFlags struct {
        // EnableWebhooks enables admission webhooks
        EnableWebhooks bool `json:"enableWebhooks" yaml:"enableWebhooks"`

        // EnableMetrics enables Prometheus metrics
        EnableMetrics bool `json:"enableMetrics" yaml:"enableMetrics"`

        // EnableTracing enables distributed tracing
        EnableTracing bool `json:"enableTracing" yaml:"enableTracing"`

        // ExperimentalFeatures enables experimental features
        ExperimentalFeatures bool `json:"experimentalFeatures" yaml:"experimentalFeatures"`

        // CustomFlags allows for additional feature flags
        CustomFlags map[string]bool `json:"customFlags,omitempty" yaml:"customFlags,omitempty"`
}

// PerformanceConfig contains performance tuning settings
type PerformanceConfig struct {
        // MaxConcurrentReconciles is the maximum number of concurrent reconciles
        MaxConcurrentReconciles int `json:"maxConcurrentReconciles" yaml:"maxConcurrentReconciles"`

        // ReconcileTimeout is the timeout for individual reconcile operations
        ReconcileTimeout time.Duration `json:"reconcileTimeout" yaml:"reconcileTimeout"`

        // RequeueInterval is the interval for requeueing successful reconciles
        RequeueInterval time.Duration `json:"requeueInterval" yaml:"requeueInterval"`

        // RequeueIntervalOnError is the interval for requeueing failed reconciles
        RequeueIntervalOnError time.Duration `json:"requeueIntervalOnError" yaml:"requeueIntervalOnError"`

        // ResyncPeriod is the resync period for informers
        ResyncPeriod time.Duration `json:"resyncPeriod" yaml:"resyncPeriod"`

        // LeaderElectionLeaseDuration is the duration that non-leader candidates will wait to force acquire leadership
        LeaderElectionLeaseDuration time.Duration `json:"leaderElectionLeaseDuration" yaml:"leaderElectionLeaseDuration"`

        // LeaderElectionRenewDeadline is the duration that the acting leader will retry refreshing leadership
        LeaderElectionRenewDeadline time.Duration `json:"leaderElectionRenewDeadline,omitempty" yaml:"leaderElectionRenewDeadline,omitempty"`

        // LeaderElectionRetryPeriod is the duration the LeaderElector clients should wait between tries
        LeaderElectionRetryPeriod time.Duration `json:"leaderElectionRetryPeriod,omitempty" yaml:"leaderElectionRetryPeriod,omitempty"`
}

// NewConfig creates a new configuration with default values
func NewConfig() *Config <span class="cov7" title="61">{
        return &amp;Config{
                Environment: ProductionEnv,
                Operator: OperatorConfig{
                        LogLevel:               "info",
                        ReconcileInterval:      5 * time.Minute,
                        MetricsBindAddress:     ":8080",
                        HealthProbeBindAddress: ":8081",
                        LeaderElection:         true,
                },
                Cloudflare: CloudflareConfig{
                        APITimeout:    30 * time.Second,
                        RateLimitRPS:  10,
                        RetryAttempts: 3,
                        RetryDelay:    1 * time.Second,
                },
                Features: &amp;FeatureFlags{
                        EnableWebhooks:       true,
                        EnableMetrics:        true,
                        EnableTracing:        false,
                        ExperimentalFeatures: false,
                        CustomFlags:          make(map[string]bool),
                },
                Performance: PerformanceConfig{
                        MaxConcurrentReconciles:     5,
                        ReconcileTimeout:            5 * time.Minute,
                        RequeueInterval:             5 * time.Minute,
                        RequeueIntervalOnError:      1 * time.Minute,
                        ResyncPeriod:                10 * time.Minute,
                        LeaderElectionLeaseDuration: 15 * time.Second,
                        LeaderElectionRenewDeadline: 10 * time.Second,
                        LeaderElectionRetryPeriod:   2 * time.Second,
                },
                ConfigSources: make(map[string]ConfigSource),
        }
}</span>

// GetEnvironmentDefaults returns default configuration for a specific environment
func GetEnvironmentDefaults(env string) *Config <span class="cov5" title="16">{
        base := NewConfig()
        base.Environment = env

        switch env </span>{
        case ProductionEnv:<span class="cov3" title="4">
                // Production defaults are already set in NewConfig()
                return base</span>

        case StagingEnv:<span class="cov3" title="4">
                base.Operator.LogLevel = DebugLevel
                base.Operator.ReconcileInterval = 1 * time.Minute
                base.Cloudflare.APITimeout = 15 * time.Second
                base.Cloudflare.RateLimitRPS = 5
                return base</span>

        case DevelopmentEnv:<span class="cov3" title="6">
                base.Operator.LogLevel = DebugLevel
                base.Operator.ReconcileInterval = 30 * time.Second
                base.Cloudflare.APITimeout = 10 * time.Second
                base.Cloudflare.RateLimitRPS = 2
                base.Features.ExperimentalFeatures = true
                return base</span>

        default:<span class="cov2" title="2">
                return base</span>
        }
}

// Merge merges another config into this one, with the other config taking precedence
func (c *Config) Merge(other *Config) *Config <span class="cov7" title="41">{
        if other == nil </span><span class="cov2" title="2">{
                return c.Copy()
        }</span>

        <span class="cov6" title="39">result := c.Copy()

        // Merge basic fields
        if other.Environment != "" </span><span class="cov6" title="23">{
                result.Environment = other.Environment
        }</span>

        // Merge operator config
        <span class="cov6" title="39">if other.Operator.LogLevel != "" </span><span class="cov5" title="14">{
                result.Operator.LogLevel = other.Operator.LogLevel
        }</span>
        <span class="cov6" title="39">if other.Operator.ReconcileInterval != 0 </span><span class="cov3" title="5">{
                result.Operator.ReconcileInterval = other.Operator.ReconcileInterval
        }</span>
        <span class="cov6" title="39">if other.Operator.MetricsBindAddress != "" </span><span class="cov0" title="0">{
                result.Operator.MetricsBindAddress = other.Operator.MetricsBindAddress
        }</span>
        <span class="cov6" title="39">if other.Operator.HealthProbeBindAddress != "" </span><span class="cov0" title="0">{
                result.Operator.HealthProbeBindAddress = other.Operator.HealthProbeBindAddress
        }</span>

        // Merge cloudflare config
        <span class="cov6" title="39">if other.Cloudflare.APITimeout != 0 </span><span class="cov3" title="4">{
                result.Cloudflare.APITimeout = other.Cloudflare.APITimeout
        }</span>
        <span class="cov6" title="39">if other.Cloudflare.RateLimitRPS != 0 </span><span class="cov3" title="6">{
                result.Cloudflare.RateLimitRPS = other.Cloudflare.RateLimitRPS
        }</span>
        <span class="cov6" title="39">if other.Cloudflare.RetryAttempts != 0 </span><span class="cov0" title="0">{
                result.Cloudflare.RetryAttempts = other.Cloudflare.RetryAttempts
        }</span>
        <span class="cov6" title="39">if other.Cloudflare.RetryDelay != 0 </span><span class="cov0" title="0">{
                result.Cloudflare.RetryDelay = other.Cloudflare.RetryDelay
        }</span>

        // Merge feature flags
        <span class="cov6" title="39">if other.Features != nil </span><span class="cov5" title="14">{
                if result.Features == nil </span><span class="cov2" title="2">{
                        result.Features = &amp;FeatureFlags{
                                CustomFlags: make(map[string]bool),
                        }
                }</span>
                <span class="cov5" title="14">if other.Features.EnableWebhooks </span><span class="cov2" title="2">{
                        result.Features.EnableWebhooks = true
                }</span>
                <span class="cov5" title="14">if other.Features.EnableMetrics </span><span class="cov1" title="1">{
                        result.Features.EnableMetrics = true
                }</span>
                <span class="cov5" title="14">if other.Features.EnableTracing </span><span class="cov1" title="1">{
                        result.Features.EnableTracing = true
                }</span>
                <span class="cov5" title="14">if other.Features.ExperimentalFeatures </span><span class="cov1" title="1">{
                        result.Features.ExperimentalFeatures = true
                }</span>
                // Merge custom flags
                <span class="cov5" title="14">for k, v := range other.Features.CustomFlags </span><span class="cov2" title="2">{
                        result.Features.CustomFlags[k] = v
                }</span>
        }

        // Merge performance config
        <span class="cov6" title="39">if other.Performance.MaxConcurrentReconciles != 0 </span><span class="cov0" title="0">{
                result.Performance.MaxConcurrentReconciles = other.Performance.MaxConcurrentReconciles
        }</span>
        <span class="cov6" title="39">if other.Performance.ReconcileTimeout != 0 </span><span class="cov2" title="2">{
                result.Performance.ReconcileTimeout = other.Performance.ReconcileTimeout
        }</span>
        <span class="cov6" title="39">if other.Performance.RequeueInterval != 0 </span><span class="cov1" title="1">{
                result.Performance.RequeueInterval = other.Performance.RequeueInterval
        }</span>
        <span class="cov6" title="39">if other.Performance.RequeueIntervalOnError != 0 </span><span class="cov1" title="1">{
                result.Performance.RequeueIntervalOnError = other.Performance.RequeueIntervalOnError
        }</span>
        <span class="cov6" title="39">if other.Performance.ResyncPeriod != 0 </span><span class="cov0" title="0">{
                result.Performance.ResyncPeriod = other.Performance.ResyncPeriod
        }</span>
        <span class="cov6" title="39">if other.Performance.LeaderElectionLeaseDuration != 0 </span><span class="cov0" title="0">{
                result.Performance.LeaderElectionLeaseDuration = other.Performance.LeaderElectionLeaseDuration
        }</span>
        <span class="cov6" title="39">if other.Performance.LeaderElectionRenewDeadline != 0 </span><span class="cov1" title="1">{
                result.Performance.LeaderElectionRenewDeadline = other.Performance.LeaderElectionRenewDeadline
        }</span>
        <span class="cov6" title="39">if other.Performance.LeaderElectionRetryPeriod != 0 </span><span class="cov1" title="1">{
                result.Performance.LeaderElectionRetryPeriod = other.Performance.LeaderElectionRetryPeriod
        }</span>

        <span class="cov6" title="39">return result</span>
}

// Copy creates a deep copy of the configuration
func (c *Config) Copy() *Config <span class="cov7" title="63">{
        if c == nil </span><span class="cov1" title="1">{
                return nil
        }</span>

        <span class="cov7" title="62">result := &amp;Config{
                Environment:   c.Environment,
                Operator:      c.Operator,
                Cloudflare:    c.Cloudflare,
                Performance:   c.Performance,
                ConfigSources: make(map[string]ConfigSource),
        }

        // Deep copy feature flags
        if c.Features != nil </span><span class="cov7" title="51">{
                result.Features = &amp;FeatureFlags{
                        EnableWebhooks:       c.Features.EnableWebhooks,
                        EnableMetrics:        c.Features.EnableMetrics,
                        EnableTracing:        c.Features.EnableTracing,
                        ExperimentalFeatures: c.Features.ExperimentalFeatures,
                        CustomFlags:          make(map[string]bool),
                }
                for k, v := range c.Features.CustomFlags </span><span class="cov2" title="2">{
                        result.Features.CustomFlags[k] = v
                }</span>
        }

        // Copy config sources
        <span class="cov7" title="62">for k, v := range c.ConfigSources </span><span class="cov10" title="261">{
                result.ConfigSources[k] = v
        }</span>

        <span class="cov7" title="62">return result</span>
}

// ToJSON converts the configuration to JSON
func (c *Config) ToJSON() ([]byte, error) <span class="cov1" title="1">{
        return json.MarshalIndent(c, "", "  ")
}</span>

// FromJSON loads configuration from JSON
func (c *Config) FromJSON(data []byte) error <span class="cov2" title="2">{
        return json.Unmarshal(data, c)
}</span>

// IsValid validates the operator configuration
func (oc *OperatorConfig) IsValid() error <span class="cov6" title="34">{
        if err := ValidateLogLevel(oc.LogLevel); err != nil </span><span class="cov2" title="3">{
                return err
        }</span>

        <span class="cov6" title="31">if err := ValidateDuration(oc.ReconcileInterval, 1*time.Second, 1*time.Hour, "reconcile interval"); err != nil </span><span class="cov3" title="4">{
                return err
        }</span>

        <span class="cov6" title="27">return nil</span>
}

// IsValid validates the cloudflare configuration
func (cc *CloudflareConfig) IsValid() error <span class="cov6" title="34">{
        if err := ValidateDuration(cc.APITimeout, 1*time.Second, 5*time.Minute, "API timeout"); err != nil </span><span class="cov3" title="4">{
                return err
        }</span>

        <span class="cov6" title="30">if err := ValidatePositiveInt(cc.RateLimitRPS, "rate limit RPS"); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov6" title="28">if cc.RetryAttempts &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("retry attempts cannot be negative, got: %d", cc.RetryAttempts)
        }</span>

        <span class="cov6" title="28">if cc.RetryDelay &gt; 0 </span><span class="cov6" title="25">{
                if err := ValidateDuration(cc.RetryDelay, 100*time.Millisecond, 30*time.Second, "retry delay"); err != nil </span><span class="cov2" title="2">{
                        return err
                }</span>
        }

        <span class="cov6" title="26">return nil</span>
}

// IsValid validates the performance configuration
func (pc *PerformanceConfig) IsValid() error <span class="cov6" title="31">{
        if err := ValidatePositiveInt(pc.MaxConcurrentReconciles, "max concurrent reconciles"); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov6" title="29">if err := ValidateDuration(pc.ReconcileTimeout, 1*time.Second, 30*time.Minute, "reconcile timeout"); err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov6" title="27">if err := ValidateDuration(pc.RequeueInterval, 1*time.Second, 24*time.Hour, "requeue interval"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="27">if err := ValidateDuration(pc.RequeueIntervalOnError, 1*time.Second, 1*time.Hour, "requeue interval on error"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="27">if err := ValidateDuration(pc.ResyncPeriod, 1*time.Minute, 24*time.Hour, "resync period"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="27">if err := ValidateDuration(pc.LeaderElectionLeaseDuration, 1*time.Second, 5*time.Minute, "leader election lease duration"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov6" title="27">if pc.LeaderElectionRenewDeadline &gt; 0 </span><span class="cov6" title="23">{
                if err := ValidateDuration(pc.LeaderElectionRenewDeadline, 1*time.Second, 1*time.Minute, "leader election renew deadline"); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov6" title="26">if pc.LeaderElectionRetryPeriod &gt; 0 </span><span class="cov6" title="24">{
                if err := ValidateDuration(pc.LeaderElectionRetryPeriod, 100*time.Millisecond, 30*time.Second, "leader election retry period"); err != nil </span><span class="cov1" title="1">{
                        return err
                }</span>
        }

        <span class="cov6" title="25">return nil</span>
}
</pre>

		<pre class="file" id="file4" style="display: none">package config

import (
        "fmt"
        "net"
        "strings"
        "time"
)

// Validate validates the entire configuration
func (c *Config) Validate() error <span class="cov6" title="30">{
        if c == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("config cannot be nil")
        }</span>

        // Validate environment
        <span class="cov6" title="30">if err := ValidateEnvironment(c.Environment); err != nil </span><span class="cov3" title="4">{
                return fmt.Errorf("environment validation failed: %w", err)
        }</span>

        // Validate operator configuration
        <span class="cov6" title="26">if err := c.Operator.IsValid(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("operator configuration validation failed: %w", err)
        }</span>

        // Validate bind addresses
        <span class="cov6" title="25">if c.Operator.MetricsBindAddress != "" </span><span class="cov6" title="23">{
                if err := ValidateBindAddress(c.Operator.MetricsBindAddress); err != nil </span><span class="cov1" title="1">{
                        return fmt.Errorf("invalid metrics bind address: %w", err)
                }</span>
        }

        <span class="cov6" title="24">if c.Operator.HealthProbeBindAddress != "" </span><span class="cov5" title="22">{
                if err := ValidateBindAddress(c.Operator.HealthProbeBindAddress); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid health probe bind address: %w", err)
                }</span>
        }

        // Validate cloudflare configuration
        <span class="cov6" title="24">if err := c.Cloudflare.IsValid(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cloudflare configuration validation failed: %w", err)
        }</span>

        // Validate performance configuration
        <span class="cov6" title="23">if err := c.Performance.IsValid(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("performance configuration validation failed: %w", err)
        }</span>

        // Validate feature flags
        <span class="cov5" title="22">if err := c.Features.Validate(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("feature flags validation failed: %w", err)
        }</span>

        // Environment-specific validation
        <span class="cov5" title="22">if err := c.validateEnvironmentSpecific(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("environment-specific validation failed: %w", err)
        }</span>

        // Cross-field validation
        <span class="cov5" title="21">if err := c.validateCrossFields(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("cross-field validation failed: %w", err)
        }</span>

        <span class="cov5" title="20">return nil</span>
}

// ValidateEnvironment validates the environment string
func ValidateEnvironment(env string) error <span class="cov6" title="39">{
        if env == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("environment cannot be empty")
        }</span>

        <span class="cov6" title="38">validEnvironments := map[string]bool{
                ProductionEnv: true,
                "staging":     true,
                "development": true,
                TestEnv:       true,
        }

        if !validEnvironments[env] </span><span class="cov4" title="7">{
                return fmt.Errorf("invalid environment: %s, must be one of: production, staging, development, test", env)
        }</span>

        <span class="cov6" title="31">return nil</span>
}

// ValidateLogLevel validates the log level string
func ValidateLogLevel(level string) error <span class="cov7" title="44">{
        if level == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("log level cannot be empty")
        }</span>

        <span class="cov6" title="42">validLevels := map[string]bool{
                "trace": true,
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
                "fatal": true,
                "panic": true,
        }

        if !validLevels[level] </span><span class="cov3" title="4">{
                return fmt.Errorf("invalid log level: %s, must be one of: trace, debug, info, warn, error, fatal, panic", level)
        }</span>

        <span class="cov6" title="38">return nil</span>
}

// ValidateDuration validates a duration against min/max bounds
func ValidateDuration(duration, minDur, maxDur time.Duration, fieldName string) error <span class="cov10" title="279">{
        if duration &lt;= 0 </span><span class="cov4" title="8">{
                return fmt.Errorf("%s must be positive, got: %v", fieldName, duration)
        }</span>

        <span class="cov9" title="271">if duration &lt; minDur </span><span class="cov3" title="4">{
                return fmt.Errorf("%s must be at least %v, got: %v", fieldName, minDur, duration)
        }</span>

        <span class="cov9" title="267">if maxDur &gt; 0 &amp;&amp; duration &gt; maxDur </span><span class="cov3" title="6">{
                return fmt.Errorf("%s must be at most %v, got: %v", fieldName, maxDur, duration)
        }</span>

        <span class="cov9" title="261">return nil</span>
}

// ValidatePositiveInt validates that an integer is positive
func ValidatePositiveInt(value int, fieldName string) error <span class="cov7" title="64">{
        if value &lt;= 0 </span><span class="cov3" title="6">{
                return fmt.Errorf("%s must be positive, got: %d", fieldName, value)
        }</span>
        <span class="cov7" title="58">return nil</span>
}

// ValidatePortRange validates that a port is in valid range (1-65535)
func ValidatePortRange(port int) error <span class="cov4" title="7">{
        if port &lt; 1 || port &gt; 65535 </span><span class="cov3" title="4">{
                return fmt.Errorf("port must be between 1 and 65535, got: %d", port)
        }</span>
        <span class="cov2" title="3">return nil</span>
}

// ValidateBindAddress validates bind address format
func ValidateBindAddress(address string) error <span class="cov7" title="61">{
        if address == "" </span><span class="cov1" title="1">{
                return fmt.Errorf("bind address cannot be empty")
        }</span>

        // Handle special case of just ":port"
        <span class="cov7" title="60">if strings.HasPrefix(address, ":") </span><span class="cov7" title="45">{
                portStr := address[1:]
                if portStr == "" </span><span class="cov1" title="1">{
                        return fmt.Errorf("bind address cannot be just ':'")
                }</span>
                <span class="cov7" title="44">if portStr == "0" </span><span class="cov2" title="3">{
                        // ":0" is valid (let OS choose port)
                        return nil
                }</span>
        }

        // Try to parse as host:port
        <span class="cov7" title="56">host, port, err := net.SplitHostPort(address)
        if err != nil </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid bind address format: %s", address)
        }</span>

        // Validate host (can be empty for ":port" format)
        <span class="cov7" title="54">if host != "" </span><span class="cov5" title="13">{
                // Check if it's a valid IP address
                if ip := net.ParseIP(host); ip == nil </span><span class="cov4" title="8">{
                        // If not an IP, could be hostname - basic validation
                        if strings.Contains(host, " ") || strings.Contains(host, "\t") </span><span class="cov2" title="2">{
                                return fmt.Errorf("invalid host in bind address: %s", host)
                        }</span>
                }
        }

        // Validate port
        <span class="cov7" title="52">if port != "0" </span><span class="cov7" title="51">{ // "0" means let OS choose port
                if _, err := net.LookupPort("tcp", port); err != nil </span><span class="cov2" title="3">{
                        return fmt.Errorf("invalid port in bind address: %s", port)
                }</span>
        }

        <span class="cov7" title="49">return nil</span>
}

// Validate validates feature flags
func (ff *FeatureFlags) Validate() error <span class="cov6" title="26">{
        if ff == nil </span><span class="cov1" title="1">{
                return nil // nil feature flags are allowed
        }</span>

        // Currently no complex validation needed for feature flags
        // This method is here for future extensibility
        <span class="cov6" title="25">return nil</span>
}

// validateEnvironmentSpecific performs environment-specific validation
func (c *Config) validateEnvironmentSpecific() error <span class="cov6" title="27">{
        switch c.Environment </span>{
        case ProductionEnv:<span class="cov4" title="12">
                // Production-specific validations
                if c.Operator.ReconcileInterval &lt; 30*time.Second </span><span class="cov1" title="1">{
                        return fmt.Errorf("production environment requires reconcile interval of at least 30s, got: %v", c.Operator.ReconcileInterval)
                }</span>

                <span class="cov4" title="11">if c.Cloudflare.RateLimitRPS &gt; 50 </span><span class="cov1" title="1">{
                        return fmt.Errorf("production environment should have rate limit &lt;= 50 RPS for safety, got: %d", c.Cloudflare.RateLimitRPS)
                }</span>

                // Ensure stable features are enabled in production
                <span class="cov4" title="10">if c.Features != nil &amp;&amp; c.Features.ExperimentalFeatures </span><span class="cov1" title="1">{
                        return fmt.Errorf("experimental features should not be enabled in production")
                }</span>

        case "staging":<span class="cov4" title="8">
                // Staging-specific validations
                if c.Operator.ReconcileInterval &lt; 10*time.Second </span><span class="cov1" title="1">{
                        return fmt.Errorf("staging environment requires reconcile interval of at least 10s, got: %v", c.Operator.ReconcileInterval)
                }</span>

        case "development":<span class="cov3" title="4">
                // Development-specific validations are more relaxed
                if c.Operator.ReconcileInterval &lt; 5*time.Second </span><span class="cov1" title="1">{
                        return fmt.Errorf("development environment requires reconcile interval of at least 5s, got: %v", c.Operator.ReconcileInterval)
                }</span>

        case TestEnv:<span class="cov2" title="3"></span>
                // Test environment is most permissive
                // No additional validations
        }

        <span class="cov5" title="22">return nil</span>
}

// validateCrossFields performs cross-field validation
func (c *Config) validateCrossFields() error <span class="cov6" title="25">{
        // Validate leader election timing relationships
        if c.Performance.LeaderElectionRenewDeadline &gt; 0 &amp;&amp;
                c.Performance.LeaderElectionLeaseDuration &gt; 0 &amp;&amp;
                c.Performance.LeaderElectionRenewDeadline &gt;= c.Performance.LeaderElectionLeaseDuration </span><span class="cov1" title="1">{
                return fmt.Errorf("leader election renew deadline (%v) must be less than lease duration (%v)",
                        c.Performance.LeaderElectionRenewDeadline, c.Performance.LeaderElectionLeaseDuration)
        }</span>

        <span class="cov6" title="24">if c.Performance.LeaderElectionRetryPeriod &gt; 0 &amp;&amp;
                c.Performance.LeaderElectionRenewDeadline &gt; 0 &amp;&amp;
                c.Performance.LeaderElectionRetryPeriod &gt;= c.Performance.LeaderElectionRenewDeadline </span><span class="cov1" title="1">{
                return fmt.Errorf("leader election retry period (%v) must be less than renew deadline (%v)",
                        c.Performance.LeaderElectionRetryPeriod, c.Performance.LeaderElectionRenewDeadline)
        }</span>

        // Validate bind addresses don't conflict
        <span class="cov6" title="23">if c.Operator.MetricsBindAddress != "" &amp;&amp; c.Operator.HealthProbeBindAddress != "" </span><span class="cov6" title="23">{
                if c.Operator.MetricsBindAddress == c.Operator.HealthProbeBindAddress </span><span class="cov2" title="2">{
                        // Special case: port 0 means OS chooses random port, so multiple binds to :0 are allowed
                        if c.Operator.MetricsBindAddress != ":0" </span><span class="cov1" title="1">{
                                return fmt.Errorf("metrics and health probe cannot use the same bind address: %s", c.Operator.MetricsBindAddress)
                        }</span>
                }

                // Extract ports and check for conflicts on same host
                <span class="cov5" title="22">metricsHost, metricsPort, err1 := net.SplitHostPort(c.Operator.MetricsBindAddress)
                healthHost, healthPort, err2 := net.SplitHostPort(c.Operator.HealthProbeBindAddress)

                if err1 == nil &amp;&amp; err2 == nil &amp;&amp; metricsPort == healthPort &amp;&amp; metricsPort != "0" </span><span class="cov1" title="1">{
                        // Check if they're on the same host (or one is wildcard)
                        if metricsHost == healthHost || metricsHost == "" || healthHost == "" ||
                                metricsHost == "0.0.0.0" || healthHost == "0.0.0.0" </span><span class="cov0" title="0">{
                                return fmt.Errorf("metrics and health probe cannot use the same port: %s", metricsPort)
                        }</span>
                }
        }

        // Validate retry configuration
        <span class="cov5" title="22">if c.Cloudflare.RetryDelay &gt; 0 &amp;&amp; c.Cloudflare.APITimeout &gt; 0 </span><span class="cov5" title="22">{
                maxRetryTime := time.Duration(c.Cloudflare.RetryAttempts) * c.Cloudflare.RetryDelay
                if maxRetryTime &gt;= c.Cloudflare.APITimeout </span><span class="cov1" title="1">{
                        return fmt.Errorf("total retry time (%v) should be less than API timeout (%v)",
                                maxRetryTime, c.Cloudflare.APITimeout)
                }</span>
        }

        <span class="cov5" title="21">return nil</span>
}
</pre>

		<pre class="file" id="file5" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"
        "os"
        "strconv"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        dnsv1 "github.com/devops247-online/k8s-operator-cloudflare/api/v1"
        "github.com/devops247-online/k8s-operator-cloudflare/internal/config"
        "github.com/devops247-online/k8s-operator-cloudflare/internal/logging"
        "github.com/devops247-online/k8s-operator-cloudflare/internal/metrics"
        "github.com/devops247-online/k8s-operator-cloudflare/internal/tracing"
)

const (
        // CloudflareRecordFinalizer is the finalizer added to CloudflareRecord resources
        CloudflareRecordFinalizer = "dns.cloudflare.io/finalizer"
)

// CloudflareRecordReconciler reconciles a CloudflareRecord object
type CloudflareRecordReconciler struct {
        client.Client
        Scheme *runtime.Scheme

        // Configuration manager for advanced configuration support
        configManager *config.ConfigManager

        // Performance configuration
        MaxConcurrentReconciles int
        ReconcileTimeout        time.Duration
        RequeueInterval         time.Duration
        RequeueIntervalOnError  time.Duration

        // Metrics collectors
        performanceMetrics *metrics.PerformanceMetrics
        cloudflareMetrics  *metrics.CloudflareMetrics
        businessMetrics    *metrics.BusinessMetrics
}

// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords/finalizers,verbs=update
// +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

// NewCloudflareRecordReconciler creates a new CloudflareRecordReconciler with performance configuration
func NewCloudflareRecordReconciler(kubeClient client.Client, scheme *runtime.Scheme, configManager *config.ConfigManager) *CloudflareRecordReconciler <span class="cov9" title="61">{
        reconciler := &amp;CloudflareRecordReconciler{
                Client:             kubeClient,
                Scheme:             scheme,
                configManager:      configManager,
                performanceMetrics: metrics.NewPerformanceMetrics(),
                cloudflareMetrics:  metrics.NewCloudflareMetrics(),
                businessMetrics:    metrics.NewBusinessMetrics(),
        }

        // Load performance configuration from config manager or environment variables
        reconciler.loadPerformanceConfig()

        return reconciler
}</span>

// loadPerformanceConfig loads performance tuning parameters from config manager or environment variables
func (r *CloudflareRecordReconciler) loadPerformanceConfig() <span class="cov10" title="63">{
        // Set defaults first
        r.MaxConcurrentReconciles = 5
        r.ReconcileTimeout = 5 * time.Minute
        r.RequeueInterval = 5 * time.Minute
        r.RequeueIntervalOnError = 1 * time.Minute

        // Try to get configuration from config manager first
        if r.configManager != nil &amp;&amp; r.configManager.IsConfigured() </span><span class="cov1" title="1">{
                cfg := r.configManager.GetConfig()
                if cfg != nil </span><span class="cov1" title="1">{
                        // Load from config manager - override defaults with non-zero values
                        if cfg.Performance.MaxConcurrentReconciles &gt; 0 </span><span class="cov1" title="1">{
                                r.MaxConcurrentReconciles = cfg.Performance.MaxConcurrentReconciles
                        }</span>
                        <span class="cov1" title="1">if cfg.Performance.ReconcileTimeout &gt; 0 </span><span class="cov1" title="1">{
                                r.ReconcileTimeout = cfg.Performance.ReconcileTimeout
                        }</span>
                        <span class="cov1" title="1">if cfg.Performance.RequeueInterval &gt; 0 </span><span class="cov1" title="1">{
                                r.RequeueInterval = cfg.Performance.RequeueInterval
                        }</span>
                        <span class="cov1" title="1">if cfg.Performance.RequeueIntervalOnError &gt; 0 </span><span class="cov1" title="1">{
                                r.RequeueIntervalOnError = cfg.Performance.RequeueIntervalOnError
                        }</span>
                        <span class="cov1" title="1">return</span>
                }
        }

        // Fallback to environment variables - override defaults
        <span class="cov9" title="62">if val := os.Getenv("MAX_CONCURRENT_RECONCILES"); val != "" </span><span class="cov5" title="7">{
                if parsed, err := strconv.Atoi(val); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov3" title="3">{
                        r.MaxConcurrentReconciles = parsed
                }</span>
        }

        <span class="cov9" title="62">if val := os.Getenv("RECONCILE_TIMEOUT"); val != "" </span><span class="cov4" title="6">{
                if parsed, err := time.ParseDuration(val); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov2" title="2">{
                        r.ReconcileTimeout = parsed
                }</span>
        }

        <span class="cov9" title="62">if val := os.Getenv("REQUEUE_INTERVAL"); val != "" </span><span class="cov4" title="6">{
                if parsed, err := time.ParseDuration(val); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov2" title="2">{
                        r.RequeueInterval = parsed
                }</span>
        }

        <span class="cov9" title="62">if val := os.Getenv("REQUEUE_INTERVAL_ON_ERROR"); val != "" </span><span class="cov4" title="6">{
                if parsed, err := time.ParseDuration(val); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov2" title="2">{
                        r.RequeueIntervalOnError = parsed
                }</span>
        }
}

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *CloudflareRecordReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="26">{
        startTime := time.Now()

        // Start tracing span
        ctx, span := tracing.StartSpan(ctx, "CloudflareRecordReconciler.Reconcile")
        defer span.End()

        // Add trace attributes
        span.SetAttributes(
                tracing.StringAttribute("cloudflare.record.name", req.Name),
                tracing.StringAttribute("cloudflare.record.namespace", req.Namespace),
        )

        // Create structured logging context
        reqCtx := logging.RequestContext{
                RequestID: logging.GenerateRequestID(),
                Operation: "reconcile",
                Resource:  req.Name,
                Namespace: req.Namespace,
                StartTime: startTime,
                TraceID:   tracing.GetTraceID(ctx),
                SpanID:    tracing.GetSpanID(ctx),
        }

        // Enrich context with request information and structured logger
        ctx = logging.ContextWithRequestInfo(ctx, reqCtx)

        // Get enriched logger from context or create new one
        log := logf.FromContext(ctx)
        structuredLogger := logging.EnrichLogr(ctx, log)

        // Update context with enriched logger
        ctx = logging.ContextWithLogr(ctx, structuredLogger)

        // Log reconciliation start with structured fields
        structuredLogger.Info("Starting CloudflareRecord reconciliation")

        // Create context with timeout only if parent context doesn't have deadline
        var workCtx context.Context
        if _, hasDeadline := ctx.Deadline(); hasDeadline </span><span class="cov2" title="2">{
                // Parent context already has deadline (e.g., from tests), use it
                workCtx = ctx
        }</span> else<span class="cov7" title="24"> {
                // No deadline in parent context, add our own
                var cancel context.CancelFunc
                workCtx, cancel = context.WithTimeout(ctx, r.ReconcileTimeout)
                defer cancel()
        }</span>

        // Update queue depth metric (approximate)
        <span class="cov8" title="26">r.performanceMetrics.UpdateQueueDepth("cloudflarerecord", req.Namespace, 1)
        defer r.performanceMetrics.UpdateQueueDepth("cloudflarerecord", req.Namespace, 0)

        // Fetch the CloudflareRecord instance
        var cloudflareRecord dnsv1.CloudflareRecord
        if err := r.Get(workCtx, req.NamespacedName, &amp;cloudflareRecord); err != nil </span><span class="cov4" title="6">{
                duration := time.Since(startTime)

                // Add error to span
                span.RecordError(err)

                if errors.IsNotFound(err) </span><span class="cov4" title="5">{
                        // Request object not found, could have been deleted after reconcile request.
                        structuredLogger.Info("CloudflareRecord resource not found, ignoring since object must be deleted")
                        r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "not_found", req.Namespace, duration)
                        r.performanceMetrics.IncReconcileRate("cloudflarerecord", "not_found", req.Namespace)
                        return ctrl.Result{}, nil
                }</span>

                <span class="cov1" title="1">structuredLogger.Error(err, "Failed to get CloudflareRecord")
                r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "error", req.Namespace, duration)
                r.performanceMetrics.IncReconcileRate("cloudflarerecord", "error", req.Namespace)
                r.performanceMetrics.IncErrorRate("cloudflarerecord", "get_error", req.Namespace)
                return ctrl.Result{RequeueAfter: r.RequeueIntervalOnError}, err</span>
        }

        // Check feature flags if config manager is available
        <span class="cov7" title="20">if r.configManager != nil &amp;&amp; r.configManager.IsConfigured() </span><span class="cov0" title="0">{
                ffm := r.configManager.GetFeatureFlagManager()
                if ffm != nil &amp;&amp; !ffm.IsEnabled("EnableReconciliation") </span><span class="cov0" title="0">{
                        structuredLogger.Info("Reconciliation disabled by feature flag")
                        return ctrl.Result{RequeueAfter: r.RequeueInterval}, nil
                }</span>
        }

        // Check if the CloudflareRecord instance is marked to be deleted
        <span class="cov7" title="20">if cloudflareRecord.GetDeletionTimestamp() != nil </span><span class="cov2" title="2">{
                result, err := r.reconcileDelete(workCtx, &amp;cloudflareRecord)
                duration := time.Since(startTime)

                if err != nil </span><span class="cov1" title="1">{
                        r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "delete_error", req.Namespace, duration)
                        r.performanceMetrics.IncReconcileRate("cloudflarerecord", "delete_error", req.Namespace)
                        r.performanceMetrics.IncErrorRate("cloudflarerecord", "delete_error", req.Namespace)
                }</span> else<span class="cov1" title="1"> {
                        r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "delete_success", req.Namespace, duration)
                        r.performanceMetrics.IncReconcileRate("cloudflarerecord", "delete_success", req.Namespace)
                }</span>

                <span class="cov2" title="2">return result, err</span>
        }

        // Add finalizer if not present
        <span class="cov7" title="18">if !controllerutil.ContainsFinalizer(&amp;cloudflareRecord, CloudflareRecordFinalizer) </span><span class="cov6" title="15">{
                controllerutil.AddFinalizer(&amp;cloudflareRecord, CloudflareRecordFinalizer)
                if err := r.Update(workCtx, &amp;cloudflareRecord); err != nil </span><span class="cov1" title="1">{
                        duration := time.Since(startTime)
                        span.RecordError(err)
                        structuredLogger.Error(err, "Failed to add finalizer")
                        r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "finalizer_error", req.Namespace, duration)
                        r.performanceMetrics.IncReconcileRate("cloudflarerecord", "finalizer_error", req.Namespace)
                        r.performanceMetrics.IncErrorRate("cloudflarerecord", "finalizer_error", req.Namespace)
                        return ctrl.Result{RequeueAfter: r.RequeueIntervalOnError}, err
                }</span>
        }

        // Add DNS record details to span
        <span class="cov7" title="17">span.SetAttributes(
                tracing.StringAttribute("cloudflare.zone", cloudflareRecord.Spec.Zone),
                tracing.StringAttribute("cloudflare.type", cloudflareRecord.Spec.Type),
                tracing.StringAttribute("cloudflare.name", cloudflareRecord.Spec.Name),
                tracing.StringAttribute("cloudflare.content", cloudflareRecord.Spec.Content),
        )

        // Log the DNS record details with structured logging
        structuredLogger.Info("Processing CloudflareRecord",
                "zone", cloudflareRecord.Spec.Zone,
                "type", cloudflareRecord.Spec.Type,
                "name", cloudflareRecord.Spec.Name,
                "content", cloudflareRecord.Spec.Content)

        // Update business metrics for CRD resource status
        r.businessMetrics.UpdateCRDResourceStatus(req.Namespace, "processing", cloudflareRecord.Spec.Type, 1)

        // Update DNS records by type metric
        r.businessMetrics.UpdateDNSRecordsByType(cloudflareRecord.Spec.Type, cloudflareRecord.Spec.Zone, "", 1)

        // TODO: Implement full Cloudflare API integration here
        // For now, just update status to show operator is working

        // Simulate API call time for metrics
        apiStartTime := time.Now()
        time.Sleep(10 * time.Millisecond) // Simulate API delay
        r.performanceMetrics.ObserveAPIResponseTime("record_update", "200", req.Namespace, time.Since(apiStartTime))

        // Update status to indicate processing
        r.updateStatus(&amp;cloudflareRecord, true, dnsv1.ConditionReasonRecordCreated, "DNS record processing completed (implementation ready for Cloudflare API)")

        cloudflareRecord.Status.ObservedGeneration = cloudflareRecord.Generation
        now := metav1.NewTime(time.Now())
        cloudflareRecord.Status.LastUpdated = &amp;now

        if err := r.Status().Update(workCtx, &amp;cloudflareRecord); err != nil </span><span class="cov4" title="6">{
                duration := time.Since(startTime)
                span.RecordError(err)
                structuredLogger.Error(err, "Failed to update CloudflareRecord status")
                r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "status_error", req.Namespace, duration)
                r.performanceMetrics.IncReconcileRate("cloudflarerecord", "status_error", req.Namespace)
                r.performanceMetrics.IncErrorRate("cloudflarerecord", "status_error", req.Namespace)
                return ctrl.Result{RequeueAfter: r.RequeueIntervalOnError}, err
        }</span>

        // Record successful reconciliation
        <span class="cov6" title="11">duration := time.Since(startTime)

        // Add success attributes to span
        span.SetAttributes(
                tracing.StringAttribute("reconcile.result", "success"),
                tracing.IntAttribute("reconcile.duration_ms", int(duration.Milliseconds())),
        )

        // Log successful completion
        structuredLogger.Info("CloudflareRecord reconciliation completed successfully",
                "duration", duration.String(),
                "requeue_after", r.RequeueInterval.String())

        r.performanceMetrics.ObserveReconcileDuration("cloudflarerecord", "success", req.Namespace, duration)
        r.performanceMetrics.IncReconcileRate("cloudflarerecord", "success", req.Namespace)

        // Update business metrics for successful reconciliation
        r.businessMetrics.UpdateCRDResourceStatus(req.Namespace, "ready", cloudflareRecord.Spec.Type, 1)
        r.businessMetrics.UpdateReconciliationHealth("cloudflarerecord", req.Namespace, "CloudflareRecord", true)
        r.businessMetrics.UpdateDNSRecordsByStatus("active", cloudflareRecord.Spec.Zone, "", 1)

        // Simulate API call metrics (in real implementation, this would be in API call)
        r.cloudflareMetrics.RecordAPIRequest("POST", "/zones/dns_records", "200", "", duration)
        r.cloudflareMetrics.RecordDNSOperation("create", cloudflareRecord.Spec.Type, "", "success")

        // Requeue with configured interval
        return ctrl.Result{RequeueAfter: r.RequeueInterval}, nil</span>
}

// reconcileDelete handles the deletion of CloudflareRecord
func (r *CloudflareRecordReconciler) reconcileDelete(ctx context.Context, cloudflareRecord *dnsv1.CloudflareRecord) (ctrl.Result, error) <span class="cov4" title="4">{
        startTime := time.Now()

        // Start tracing span for delete operation
        ctx, span := tracing.StartSpan(ctx, "CloudflareRecordReconciler.reconcileDelete")
        defer span.End()

        // Add trace attributes for delete operation
        span.SetAttributes(
                tracing.StringAttribute("cloudflare.record.name", cloudflareRecord.Name),
                tracing.StringAttribute("cloudflare.record.namespace", cloudflareRecord.Namespace),
                tracing.StringAttribute("cloudflare.zone", cloudflareRecord.Spec.Zone),
                tracing.StringAttribute("cloudflare.type", cloudflareRecord.Spec.Type),
                tracing.StringAttribute("operation", "delete"),
        )

        // Get structured logger from context
        structuredLogger := logging.LogrFromContext(ctx)

        structuredLogger.Info("Deleting CloudflareRecord",
                "name", cloudflareRecord.Name,
                "namespace", cloudflareRecord.Namespace,
                "zone", cloudflareRecord.Spec.Zone,
                "type", cloudflareRecord.Spec.Type)

        // TODO: In a full implementation, delete the DNS record from Cloudflare here
        // Simulate API call metrics for deletion
        duration := time.Since(startTime)
        r.cloudflareMetrics.RecordAPIRequest("DELETE", "/zones/dns_records", "200", "", duration)
        r.cloudflareMetrics.RecordDNSOperation("delete", cloudflareRecord.Spec.Type, "", "success")

        // Update business metrics for deletion
        r.businessMetrics.UpdateCRDResourceStatus(cloudflareRecord.Namespace, "deleting", cloudflareRecord.Spec.Type, 1)
        r.businessMetrics.UpdateDNSRecordsByType(cloudflareRecord.Spec.Type, cloudflareRecord.Spec.Zone, "", -1)

        // Remove finalizer
        controllerutil.RemoveFinalizer(cloudflareRecord, CloudflareRecordFinalizer)
        if err := r.Update(ctx, cloudflareRecord); err != nil </span><span class="cov1" title="1">{
                span.RecordError(err)
                structuredLogger.Error(err, "Failed to remove finalizer")
                r.cloudflareMetrics.RecordAPIError("DELETE", "/zones/dns_records", "finalizer_error", "")
                return ctrl.Result{RequeueAfter: r.RequeueIntervalOnError}, err
        }</span>

        // Add success attributes to span
        <span class="cov3" title="3">span.SetAttributes(
                tracing.StringAttribute("delete.result", "success"),
                tracing.IntAttribute("delete.duration_ms", int(duration.Milliseconds())),
        )

        // Log successful deletion
        structuredLogger.Info("CloudflareRecord deletion completed successfully",
                "duration", duration.String())

        return ctrl.Result{}, nil</span>
}

// updateStatus updates the status of the CloudflareRecord
func (r *CloudflareRecordReconciler) updateStatus(cloudflareRecord *dnsv1.CloudflareRecord, ready bool, reason, message string) <span class="cov8" title="31">{
        cloudflareRecord.Status.Ready = ready

        // Update condition
        condition := metav1.Condition{
                Type:               dnsv1.ConditionTypeReady,
                Status:             metav1.ConditionFalse,
                Reason:             reason,
                Message:            message,
                LastTransitionTime: metav1.NewTime(time.Now()),
        }

        if ready </span><span class="cov7" title="25">{
                condition.Status = metav1.ConditionTrue
        }</span>

        // Find existing condition or add new one
        <span class="cov8" title="31">found := false
        for i, existingCondition := range cloudflareRecord.Status.Conditions </span><span class="cov4" title="6">{
                if existingCondition.Type == dnsv1.ConditionTypeReady </span><span class="cov4" title="6">{
                        found = true
                        if existingCondition.Status != condition.Status || existingCondition.Reason != condition.Reason </span><span class="cov3" title="3">{
                                cloudflareRecord.Status.Conditions[i] = condition
                        }</span>
                        <span class="cov4" title="6">break</span>
                }
        }

        <span class="cov8" title="31">if !found </span><span class="cov7" title="25">{
                cloudflareRecord.Status.Conditions = append(cloudflareRecord.Status.Conditions, condition)
        }</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *CloudflareRecordReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov1" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;dnsv1.CloudflareRecord{}).
                Named("cloudflarerecord").
                WithOptions(controller.Options{
                        MaxConcurrentReconciles: r.MaxConcurrentReconciles,
                }).
                Complete(r)
}</span>
</pre>

		<pre class="file" id="file6" style="display: none">package health

import (
        "context"
        "fmt"
        "net/http"
        "time"

        "github.com/cloudflare/cloudflare-go"
        "k8s.io/client-go/discovery"
        "k8s.io/client-go/kubernetes"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/manager"
)

// CloudflareAPIInterface defines the methods we use from cloudflare.API
type CloudflareAPIInterface interface {
        VerifyAPIToken(ctx context.Context) (cloudflare.APITokenVerifyBody, error)
}

// Checker provides comprehensive health checking for the operator
type Checker struct {
        client.Client
        k8sClient       kubernetes.Interface
        discoveryClient discovery.DiscoveryInterface
        manager         manager.Manager
        cloudflareAPI   CloudflareAPIInterface
}

// NewChecker creates a new health checker instance
func NewChecker(mgr manager.Manager, cfAPI *cloudflare.API) *Checker <span class="cov1" title="1">{
        cfg := mgr.GetConfig()
        k8sClient, _ := kubernetes.NewForConfig(cfg)
        discoveryClient, _ := discovery.NewDiscoveryClientForConfig(cfg)

        return &amp;Checker{
                Client:          mgr.GetClient(),
                k8sClient:       k8sClient,
                discoveryClient: discoveryClient,
                manager:         mgr,
                cloudflareAPI:   cfAPI,
        }
}</span>

// LivenessCheck performs basic liveness check
func (c *Checker) LivenessCheck(req *http.Request) error <span class="cov5" title="3">{
        ctx, cancel := context.WithTimeout(req.Context(), 5*time.Second)
        defer cancel()

        // Check if manager is running
        if c.manager == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("manager is not initialized")
        }</span>

        // Basic connectivity check to K8s API
        <span class="cov3" title="2">if err := c.checkKubernetesAPI(ctx); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("kubernetes API check failed: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// ReadinessCheck performs comprehensive readiness check
func (c *Checker) ReadinessCheck(req *http.Request) error <span class="cov7" title="5">{
        ctx, cancel := context.WithTimeout(req.Context(), 10*time.Second)
        defer cancel()

        // Check Kubernetes API accessibility
        if err := c.checkKubernetesAPI(ctx); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("kubernetes API not ready: %w", err)
        }</span>

        // Check CRD availability
        <span class="cov6" title="4">if err := c.checkCRDAvailability(ctx); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("CRD not ready: %w", err)
        }</span>

        // Check Cloudflare API connectivity (if configured)
        <span class="cov5" title="3">if c.cloudflareAPI != nil </span><span class="cov3" title="2">{
                if err := c.checkCloudflareAPI(ctx); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cloudflare API not ready: %w", err)
                }</span>
        }

        // Check leader election status (if enabled)
        <span class="cov5" title="3">if err := c.checkLeaderElectionStatus(ctx); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("leader election not ready: %w", err)
        }</span>

        <span class="cov5" title="3">return nil</span>
}

// checkKubernetesAPI verifies connectivity to Kubernetes API
func (c *Checker) checkKubernetesAPI(_ context.Context) error <span class="cov10" title="9">{
        if c.k8sClient == nil </span><span class="cov5" title="3">{
                return fmt.Errorf("kubernetes client not initialized")
        }</span>

        // Try to get cluster version
        <span class="cov8" title="6">_, err := c.k8sClient.Discovery().ServerVersion()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get server version: %w", err)
        }</span>

        <span class="cov8" title="6">return nil</span>
}

// checkCRDAvailability verifies that CloudflareRecord CRD is available
func (c *Checker) checkCRDAvailability(_ context.Context) error <span class="cov8" title="7">{
        if c.discoveryClient == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("discovery client not initialized")
        }</span>

        // Check if CloudflareRecord CRD is available
        <span class="cov8" title="6">apiResourceList, err := c.discoveryClient.ServerResourcesForGroupVersion("dns.cloudflare.io/v1")
        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("failed to get API resources: %w", err)
        }</span>

        // Look for CloudflareRecord resource
        <span class="cov7" title="5">for _, resource := range apiResourceList.APIResources </span><span class="cov7" title="5">{
                if resource.Kind == "CloudflareRecord" </span><span class="cov6" title="4">{
                        return nil
                }</span>
        }

        <span class="cov1" title="1">return fmt.Errorf("CloudflareRecord CRD not found")</span>
}

// checkCloudflareAPI verifies connectivity to Cloudflare API
func (c *Checker) checkCloudflareAPI(ctx context.Context) error <span class="cov8" title="6">{
        if c.cloudflareAPI == nil </span><span class="cov1" title="1">{
                // For E2E tests and development, Cloudflare API may not be configured
                // This is not considered an error, just skip the check
                return nil
        }</span>

        // Add defensive check to prevent panic
        <span class="cov7" title="5">defer func() </span><span class="cov7" title="5">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        // Log panic but don't crash the health check
                        return
                }</span>
        }()

        // Try to verify API token
        <span class="cov7" title="5">result, err := c.cloudflareAPI.VerifyAPIToken(ctx)
        if err != nil </span><span class="cov3" title="2">{
                // Log error but don't fail health check in test environments
                // In production, missing API would be caught by the nil check above
                return nil
        }</span>

        <span class="cov5" title="3">if result.Status != "active" </span><span class="cov1" title="1">{
                // Log status but don't fail health check in test environments
                // In production, proper API configuration should be ensured
                return nil
        }</span>

        <span class="cov3" title="2">return nil</span>
}

// checkLeaderElectionStatus verifies leader election status
func (c *Checker) checkLeaderElectionStatus(_ context.Context) error <span class="cov7" title="5">{
        // If manager doesn't have leader election enabled, skip check
        if c.manager == nil </span><span class="cov1" title="1">{
                return fmt.Errorf("manager not initialized")
        }</span>

        // For now, just check if we can access the lease resource
        // In production, you might want to check if this instance is the leader
        // TODO: Implement actual leader election status check
        <span class="cov6" title="4">return nil</span>
}

// GetHealthzHandler returns the liveness check handler
func (c *Checker) GetHealthzHandler() healthz.Checker <span class="cov1" title="1">{
        return c.LivenessCheck
}</span>

// GetReadyzHandler returns the readiness check handler
func (c *Checker) GetReadyzHandler() healthz.Checker <span class="cov1" title="1">{
        return c.ReadinessCheck
}</span>
</pre>

		<pre class="file" id="file7" style="display: none">package health

import (
        "net/http"
        "net/http/pprof"
        "os"
        "strconv"
)

// SetupProfiling configures pprof endpoints for debugging
func SetupProfiling(mux *http.ServeMux) <span class="cov7" title="7">{
        // Only enable pprof in development or when explicitly enabled
        if !isPprofEnabled() </span><span class="cov4" title="3">{
                return
        }</span>

        // Register pprof handlers
        <span class="cov5" title="4">mux.HandleFunc("/debug/pprof/", pprof.Index)
        mux.HandleFunc("/debug/pprof/cmdline", pprof.Cmdline)
        mux.HandleFunc("/debug/pprof/profile", pprof.Profile)
        mux.HandleFunc("/debug/pprof/symbol", pprof.Symbol)
        mux.HandleFunc("/debug/pprof/trace", pprof.Trace)

        // Register additional handlers
        mux.Handle("/debug/pprof/goroutine", pprof.Handler("goroutine"))
        mux.Handle("/debug/pprof/heap", pprof.Handler("heap"))
        mux.Handle("/debug/pprof/threadcreate", pprof.Handler("threadcreate"))
        mux.Handle("/debug/pprof/block", pprof.Handler("block"))
        mux.Handle("/debug/pprof/mutex", pprof.Handler("mutex"))</span>
}

// isPprofEnabled checks if pprof profiling should be enabled
func isPprofEnabled() bool <span class="cov10" title="17">{
        // Check environment variable
        if enabled := os.Getenv("ENABLE_PPROF"); enabled != "" </span><span class="cov8" title="11">{
                if val, err := strconv.ParseBool(enabled); err == nil </span><span class="cov7" title="9">{
                        return val
                }</span>
        }

        // Check if running in development mode
        <span class="cov7" title="8">if env := os.Getenv("GO_ENV"); env == "development" </span><span class="cov4" title="3">{
                return true
        }</span>

        // Default to disabled for security
        <span class="cov6" title="5">return false</span>
}
</pre>

		<pre class="file" id="file8" style="display: none">package health

import (
        "context"
        "os"
        "os/signal"
        "sync"
        "syscall"
        "time"

        "github.com/go-logr/logr"
        "sigs.k8s.io/controller-runtime/pkg/log"
)

// GracefulShutdownManager handles graceful shutdown of the operator
type GracefulShutdownManager struct {
        shutdownCallbacks []func(context.Context) error
        shutdownTimeout   time.Duration
        mu                sync.RWMutex
        logger            logr.Logger
}

// NewGracefulShutdownManager creates a new graceful shutdown manager
func NewGracefulShutdownManager(timeout time.Duration) *GracefulShutdownManager <span class="cov6" title="15">{
        return &amp;GracefulShutdownManager{
                shutdownCallbacks: make([]func(context.Context) error, 0),
                shutdownTimeout:   timeout,
                logger:            log.Log.WithName("graceful-shutdown"),
        }
}</span>

// AddShutdownCallback adds a callback function to be called during shutdown
func (gsm *GracefulShutdownManager) AddShutdownCallback(callback func(context.Context) error) <span class="cov10" title="72">{
        gsm.mu.Lock()
        defer gsm.mu.Unlock()
        gsm.shutdownCallbacks = append(gsm.shutdownCallbacks, callback)
}</span>

// WaitForShutdownSignal waits for shutdown signals and executes graceful shutdown
func (gsm *GracefulShutdownManager) WaitForShutdownSignal() <span class="cov0" title="0">{
        // Create channel to receive OS signals
        sigChan := make(chan os.Signal, 1)

        // Register channel to receive specific signals
        signal.Notify(sigChan, syscall.SIGTERM, syscall.SIGINT)

        // Wait for signal
        sig := &lt;-sigChan
        gsm.logger.Info("Received shutdown signal", "signal", sig)

        // Execute graceful shutdown
        gsm.executeGracefulShutdown()
}</span>

// executeGracefulShutdown executes all registered shutdown callbacks
func (gsm *GracefulShutdownManager) executeGracefulShutdown() <span class="cov5" title="7">{
        ctx, cancel := context.WithTimeout(context.Background(), gsm.shutdownTimeout)
        defer cancel()

        gsm.mu.RLock()
        callbacks := make([]func(context.Context) error, len(gsm.shutdownCallbacks))
        copy(callbacks, gsm.shutdownCallbacks)
        gsm.mu.RUnlock()

        gsm.logger.Info("Starting graceful shutdown", "callbacks", len(callbacks), "timeout", gsm.shutdownTimeout)

        // Execute callbacks in reverse order (LIFO)
        for i := len(callbacks) - 1; i &gt;= 0; i-- </span><span class="cov7" title="18">{
                callback := callbacks[i]
                if err := callback(ctx); err != nil </span><span class="cov2" title="2">{
                        gsm.logger.Error(err, "Error during shutdown callback", "index", i)
                }</span>
        }

        <span class="cov5" title="7">gsm.logger.Info("Graceful shutdown completed")</span>
}

// DefaultShutdownCallbacks returns default shutdown callbacks for the operator
func DefaultShutdownCallbacks() []func(context.Context) error <span class="cov4" title="5">{
        return []func(context.Context) error{
                // Clean up in-flight reconciliations
                func(ctx context.Context) error </span><span class="cov3" title="4">{
                        log.Log.Info("Waiting for in-flight reconciliations to complete")
                        // Add logic to wait for reconciliations
                        time.Sleep(2 * time.Second) // Placeholder
                        return nil
                }</span>,

                // Clean up connections
                func(ctx context.Context) error <span class="cov3" title="4">{
                        log.Log.Info("Closing external connections")
                        // Add logic to close Cloudflare API connections
                        return nil
                }</span>,

                // Final cleanup
                func(ctx context.Context) error <span class="cov3" title="4">{
                        log.Log.Info("Performing final cleanup")
                        return nil
                }</span>,
        }
}
</pre>

		<pre class="file" id="file9" style="display: none">// Package logging provides structured logging functionality for the Cloudflare DNS Operator.
// It implements Zap-based JSON logging with configurable levels, sampling, and environment-specific overrides.
package logging

import (
        "fmt"
        "strings"

        "go.uber.org/zap/zapcore"
)

// Config represents the logging configuration
type Config struct {
        // Level sets the logging level (debug, info, warn, error)
        Level string `yaml:"level" json:"level"`

        // Format sets the log format (json, console)
        Format string `yaml:"format" json:"format"`

        // Development enables development mode (caller info, stack traces)
        Development bool `yaml:"development" json:"development"`

        // Sampling configuration for log sampling
        Sampling SamplingConfig `yaml:"sampling" json:"sampling"`

        // Outputs specifies where logs should be written
        Outputs []string `yaml:"outputs" json:"outputs"`
}

// SamplingConfig represents log sampling configuration
type SamplingConfig struct {
        // Enabled turns sampling on or off
        Enabled bool `yaml:"enabled" json:"enabled"`

        // Initial number of log entries to always log per second
        Initial int `yaml:"initial" json:"initial"`

        // Thereafter, every Mth log entry will be logged
        Thereafter int `yaml:"thereafter" json:"thereafter"`
}

// NewDefaultConfig returns a default logging configuration
func NewDefaultConfig() Config <span class="cov6" title="14">{
        return Config{
                Level:       "info",
                Format:      "json",
                Development: false,
                Sampling: SamplingConfig{
                        Enabled:    false,
                        Initial:    100,
                        Thereafter: 100,
                },
                Outputs: []string{"stdout"},
        }
}</span>

// NewEnvironmentConfig returns a logging configuration for the given environment
func NewEnvironmentConfig(environment string) Config <span class="cov6" title="13">{
        config := NewDefaultConfig()

        switch strings.ToLower(environment) </span>{
        case "development", "dev":<span class="cov4" title="5">
                config.Level = "debug"
                config.Format = "console"
                config.Development = true</span>
        case "production", "prod":<span class="cov5" title="7">
                config.Level = "info"
                config.Format = "json"
                config.Development = false
                config.Sampling.Enabled = true</span>
        default:<span class="cov1" title="1">
                // Default to production settings for unknown environments
                config.Level = "info"
                config.Format = "json"
                config.Development = false</span>
        }

        <span class="cov6" title="13">return config</span>
}

// Validate validates the logging configuration
func (c *Config) Validate() error <span class="cov8" title="42">{
        // Validate log level
        if c.GetLevel() == zapcore.InvalidLevel </span><span class="cov4" title="6">{
                return fmt.Errorf("invalid log level: %s", c.Level)
        }</span>

        // Validate format
        <span class="cov8" title="36">if c.Format != "json" &amp;&amp; c.Format != "console" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid log format: %s, must be 'json' or 'console'", c.Format)
        }</span>

        // Validate sampling config
        <span class="cov8" title="35">if err := c.Sampling.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid sampling config: %w", err)
        }</span>

        // Validate outputs
        <span class="cov8" title="34">if len(c.Outputs) == 0 </span><span class="cov7" title="24">{
                c.Outputs = []string{"stdout"}
        }</span>

        <span class="cov8" title="34">return nil</span>
}

// GetLevel returns the zapcore log level
func (c *Config) GetLevel() zapcore.Level <span class="cov10" title="74">{
        var level zapcore.Level
        if err := level.UnmarshalText([]byte(c.Level)); err != nil </span><span class="cov5" title="7">{
                return zapcore.InvalidLevel
        }</span>
        <span class="cov9" title="67">return level</span>
}

// IsJSON returns true if the format is JSON
func (c *Config) IsJSON() bool <span class="cov8" title="31">{
        return c.Format == "json"
}</span>

// String returns a string representation of the config
func (c *Config) String() string <span class="cov1" title="1">{
        return fmt.Sprintf("level=%s, format=%s, development=%t, sampling=%t",
                c.Level, c.Format, c.Development, c.Sampling.Enabled)
}</span>

// Validate validates the sampling configuration
func (s *SamplingConfig) Validate() error <span class="cov8" title="39">{
        if !s.Enabled </span><span class="cov8" title="30">{
                return nil
        }</span>

        <span class="cov5" title="9">if s.Initial &lt; 0 </span><span class="cov2" title="2">{
                return fmt.Errorf("sampling initial must be &gt;= 0, got %d", s.Initial)
        }</span>

        <span class="cov5" title="7">if s.Thereafter &lt; 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("sampling thereafter must be &gt;= 0, got %d", s.Thereafter)
        }</span>

        <span class="cov4" title="6">return nil</span>
}
</pre>

		<pre class="file" id="file10" style="display: none">package logging

import (
        "context"
        "fmt"
        "os"

        "github.com/go-logr/logr"
        "github.com/go-logr/zapr"
        "go.opentelemetry.io/otel/trace"
        "go.uber.org/zap"
        "go.uber.org/zap/zapcore"
)

// NewLogger creates a new zap logger with the given configuration
func NewLogger(config Config) (*zap.Logger, error) <span class="cov10" title="33">{
        if err := config.Validate(); err != nil </span><span class="cov5" title="5">{
                return nil, fmt.Errorf("invalid logging config: %w", err)
        }</span>

        // Create zap config based on our config
        <span class="cov9" title="28">var zapConfig zap.Config
        if config.Development </span><span class="cov6" title="7">{
                zapConfig = zap.NewDevelopmentConfig()
        }</span> else<span class="cov8" title="21"> {
                zapConfig = zap.NewProductionConfig()
        }</span>

        // Set log level
        <span class="cov9" title="28">zapConfig.Level = zap.NewAtomicLevelAt(config.GetLevel())

        // Set encoding format
        if config.IsJSON() </span><span class="cov8" title="21">{
                zapConfig.Encoding = "json"
                // Add trace context fields to JSON encoder
                zapConfig.EncoderConfig.TimeKey = "timestamp"
                zapConfig.EncoderConfig.LevelKey = "level"
                zapConfig.EncoderConfig.NameKey = "logger"
                zapConfig.EncoderConfig.CallerKey = "caller"
                zapConfig.EncoderConfig.MessageKey = "message"
                zapConfig.EncoderConfig.StacktraceKey = "stacktrace"
        }</span> else<span class="cov6" title="7"> {
                zapConfig.Encoding = "console"
                zapConfig.EncoderConfig.EncodeTime = zapcore.ISO8601TimeEncoder
                zapConfig.EncoderConfig.EncodeLevel = zapcore.CapitalColorLevelEncoder
        }</span>

        // Set output paths
        <span class="cov9" title="28">zapConfig.OutputPaths = config.Outputs
        zapConfig.ErrorOutputPaths = config.Outputs

        // Configure sampling if enabled
        if config.Sampling.Enabled </span><span class="cov4" title="4">{
                zapConfig.Sampling = &amp;zap.SamplingConfig{
                        Initial:    config.Sampling.Initial,
                        Thereafter: config.Sampling.Thereafter,
                }
        }</span>

        // Build the logger
        <span class="cov9" title="28">logger, err := zapConfig.Build()
        if err != nil </span><span class="cov2" title="2">{
                return nil, fmt.Errorf("failed to build logger: %w", err)
        }</span>

        <span class="cov9" title="26">return logger, nil</span>
}

// NewLogrLogger creates a new logr.Logger with the given configuration
func NewLogrLogger(config Config) (logr.Logger, error) <span class="cov6" title="7">{
        zapLogger, err := NewLogger(config)
        if err != nil </span><span class="cov1" title="1">{
                return logr.Logger{}, err
        }</span>

        // Convert zap logger to logr.Logger
        <span class="cov5" title="6">return zapr.NewLogger(zapLogger), nil</span>
}

// GetTraceID extracts the trace ID from the context
func GetTraceID(ctx context.Context) string <span class="cov8" title="21">{
        span := trace.SpanFromContext(ctx)
        if !span.SpanContext().IsValid() </span><span class="cov8" title="21">{
                return ""
        }</span>
        <span class="cov0" title="0">return span.SpanContext().TraceID().String()</span>
}

// GetSpanID extracts the span ID from the context
func GetSpanID(ctx context.Context) string <span class="cov8" title="21">{
        span := trace.SpanFromContext(ctx)
        if !span.SpanContext().IsValid() </span><span class="cov8" title="21">{
                return ""
        }</span>
        <span class="cov0" title="0">return span.SpanContext().SpanID().String()</span>
}

// WithTraceContext adds trace context fields to the logger
func WithTraceContext(ctx context.Context, logger *zap.Logger) *zap.Logger <span class="cov6" title="10">{
        traceID := GetTraceID(ctx)
        spanID := GetSpanID(ctx)

        fields := make([]zap.Field, 0, 2)
        if traceID != "" </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("trace.id", traceID))
        }</span>
        <span class="cov6" title="10">if spanID != "" </span><span class="cov0" title="0">{
                fields = append(fields, zap.String("span.id", spanID))
        }</span>

        <span class="cov6" title="10">if len(fields) &gt; 0 </span><span class="cov0" title="0">{
                return logger.With(fields...)
        }</span>

        <span class="cov6" title="10">return logger</span>
}

// WithTraceContextLogr adds trace context fields to the logr.Logger
func WithTraceContextLogr(ctx context.Context, logger logr.Logger) logr.Logger <span class="cov5" title="5">{
        traceID := GetTraceID(ctx)
        spanID := GetSpanID(ctx)

        values := make([]interface{}, 0, 4)
        if traceID != "" </span><span class="cov0" title="0">{
                values = append(values, "trace.id", traceID)
        }</span>
        <span class="cov5" title="5">if spanID != "" </span><span class="cov0" title="0">{
                values = append(values, "span.id", spanID)
        }</span>

        <span class="cov5" title="5">if len(values) &gt; 0 </span><span class="cov0" title="0">{
                return logger.WithValues(values...)
        }</span>

        <span class="cov5" title="5">return logger</span>
}

// SetupGlobalLogger sets up the global logger with the given configuration
func SetupGlobalLogger(config Config) error <span class="cov2" title="2">{
        logger, err := NewLogger(config)
        if err != nil </span><span class="cov1" title="1">{
                return err
        }</span>

        // Replace global logger
        <span class="cov1" title="1">zap.ReplaceGlobals(logger)
        return nil</span>
}

// SyncLogger safely syncs the logger, handling any errors
func SyncLogger(logger *zap.Logger) <span class="cov2" title="2">{
        if logger == nil </span><span class="cov1" title="1">{
                return
        }</span>

        // Sync can fail on stdout/stderr, which is expected
        <span class="cov1" title="1">_ = logger.Sync()</span>
}

// LoggerFromConfig creates a logger from environment variables and config
func LoggerFromConfig(environment string) (*zap.Logger, error) <span class="cov6" title="8">{
        config := NewEnvironmentConfig(environment)

        // Override with environment variables if present
        if level := os.Getenv("LOG_LEVEL"); level != "" </span><span class="cov4" title="4">{
                config.Level = level
        }</span>
        <span class="cov6" title="8">if format := os.Getenv("LOG_FORMAT"); format != "" </span><span class="cov2" title="2">{
                config.Format = format
        }</span>
        <span class="cov6" title="8">if os.Getenv("LOG_DEVELOPMENT") == "true" </span><span class="cov2" title="2">{
                config.Development = true
        }</span>

        <span class="cov6" title="8">return NewLogger(config)</span>
}

// LogrFromConfig creates a logr.Logger from environment variables and config
func LogrFromConfig(environment string) (logr.Logger, error) <span class="cov2" title="2">{
        zapLogger, err := LoggerFromConfig(environment)
        if err != nil </span><span class="cov1" title="1">{
                return logr.Logger{}, err
        }</span>
        <span class="cov1" title="1">return zapr.NewLogger(zapLogger), nil</span>
}
</pre>

		<pre class="file" id="file11" style="display: none">package logging

import (
        "context"
        "time"

        "github.com/go-logr/logr"
        "go.uber.org/zap"
        "sigs.k8s.io/controller-runtime/pkg/reconcile"
)

// RequestContext contains common fields for request logging
type RequestContext struct {
        RequestID string
        UserAgent string
        RemoteIP  string
        Operation string
        Resource  string
        Namespace string
        StartTime time.Time
        TraceID   string
        SpanID    string
}

// ContextKey is a type for context keys to avoid collisions
type ContextKey string

const (
        // RequestContextKey is the key for storing RequestContext in context
        RequestContextKey ContextKey = "request_context"
        // LoggerContextKey is the key for storing logger in context
        LoggerContextKey ContextKey = "logger"
)

// ContextWithRequestInfo adds request information to the context
func ContextWithRequestInfo(ctx context.Context, reqCtx RequestContext) context.Context <span class="cov8" title="8">{
        return context.WithValue(ctx, RequestContextKey, reqCtx)
}</span>

// RequestInfoFromContext extracts request information from context
func RequestInfoFromContext(ctx context.Context) (RequestContext, bool) <span class="cov10" title="12">{
        reqCtx, ok := ctx.Value(RequestContextKey).(RequestContext)
        return reqCtx, ok
}</span>

// ContextWithLogger adds a logger to the context
func ContextWithLogger(ctx context.Context, logger *zap.Logger) context.Context <span class="cov6" title="4">{
        return context.WithValue(ctx, LoggerContextKey, logger)
}</span>

// LoggerFromContext extracts logger from context
func LoggerFromContext(ctx context.Context) (*zap.Logger, bool) <span class="cov3" title="2">{
        logger, ok := ctx.Value(LoggerContextKey).(*zap.Logger)
        return logger, ok
}</span>

// ContextWithLogr adds a logr.Logger to the context
func ContextWithLogr(ctx context.Context, logger logr.Logger) context.Context <span class="cov1" title="1">{
        return context.WithValue(ctx, LoggerContextKey, logger)
}</span>

// LogrFromContext extracts logr.Logger from context, falling back to default if not found
func LogrFromContext(ctx context.Context) logr.Logger <span class="cov3" title="2">{
        if logger, ok := ctx.Value(LoggerContextKey).(logr.Logger); ok </span><span class="cov1" title="1">{
                return logger
        }</span>
        // Return a no-op logger if none found
        <span class="cov1" title="1">return logr.Discard()</span>
}

// EnrichLogger adds request context fields to the logger
func EnrichLogger(ctx context.Context, logger *zap.Logger) *zap.Logger <span class="cov7" title="6">{
        // Add trace context
        logger = WithTraceContext(ctx, logger)

        // Add request context if available
        if reqCtx, ok := RequestInfoFromContext(ctx); ok </span><span class="cov6" title="5">{
                fields := make([]zap.Field, 0, 8)

                if reqCtx.RequestID != "" </span><span class="cov6" title="4">{
                        fields = append(fields, zap.String("request.id", reqCtx.RequestID))
                }</span>
                <span class="cov6" title="5">if reqCtx.Operation != "" </span><span class="cov6" title="4">{
                        fields = append(fields, zap.String("operation", reqCtx.Operation))
                }</span>
                <span class="cov6" title="5">if reqCtx.Resource != "" </span><span class="cov6" title="4">{
                        fields = append(fields, zap.String("resource", reqCtx.Resource))
                }</span>
                <span class="cov6" title="5">if reqCtx.Namespace != "" </span><span class="cov6" title="4">{
                        fields = append(fields, zap.String("namespace", reqCtx.Namespace))
                }</span>
                <span class="cov6" title="5">if reqCtx.UserAgent != "" </span><span class="cov1" title="1">{
                        fields = append(fields, zap.String("user_agent", reqCtx.UserAgent))
                }</span>
                <span class="cov6" title="5">if reqCtx.RemoteIP != "" </span><span class="cov1" title="1">{
                        fields = append(fields, zap.String("remote_ip", reqCtx.RemoteIP))
                }</span>
                <span class="cov6" title="5">if !reqCtx.StartTime.IsZero() </span><span class="cov6" title="4">{
                        fields = append(fields, zap.Time("start_time", reqCtx.StartTime))
                }</span>

                <span class="cov6" title="5">if len(fields) &gt; 0 </span><span class="cov6" title="4">{
                        logger = logger.With(fields...)
                }</span>
        }

        <span class="cov7" title="6">return logger</span>
}

// EnrichLogr adds request context fields to the logr.Logger
func EnrichLogr(ctx context.Context, logger logr.Logger) logr.Logger <span class="cov3" title="2">{
        // Add trace context
        logger = WithTraceContextLogr(ctx, logger)

        // Add request context if available
        if reqCtx, ok := RequestInfoFromContext(ctx); ok </span><span class="cov1" title="1">{
                values := make([]interface{}, 0, 16)

                if reqCtx.RequestID != "" </span><span class="cov1" title="1">{
                        values = append(values, "request.id", reqCtx.RequestID)
                }</span>
                <span class="cov1" title="1">if reqCtx.Operation != "" </span><span class="cov1" title="1">{
                        values = append(values, "operation", reqCtx.Operation)
                }</span>
                <span class="cov1" title="1">if reqCtx.Resource != "" </span><span class="cov1" title="1">{
                        values = append(values, "resource", reqCtx.Resource)
                }</span>
                <span class="cov1" title="1">if reqCtx.Namespace != "" </span><span class="cov1" title="1">{
                        values = append(values, "namespace", reqCtx.Namespace)
                }</span>
                <span class="cov1" title="1">if reqCtx.UserAgent != "" </span><span class="cov0" title="0">{
                        values = append(values, "user_agent", reqCtx.UserAgent)
                }</span>
                <span class="cov1" title="1">if reqCtx.RemoteIP != "" </span><span class="cov0" title="0">{
                        values = append(values, "remote_ip", reqCtx.RemoteIP)
                }</span>
                <span class="cov1" title="1">if !reqCtx.StartTime.IsZero() </span><span class="cov1" title="1">{
                        values = append(values, "start_time", reqCtx.StartTime.Format(time.RFC3339))
                }</span>

                <span class="cov1" title="1">if len(values) &gt; 0 </span><span class="cov1" title="1">{
                        logger = logger.WithValues(values...)
                }</span>
        }

        <span class="cov3" title="2">return logger</span>
}

// ReconcilerMiddleware wraps a reconciler with structured logging
func ReconcilerMiddleware(logger *zap.Logger, reconciler reconcile.Reconciler) reconcile.Reconciler <span class="cov4" title="3">{
        return reconcile.Func(func(ctx context.Context, req reconcile.Request) (reconcile.Result, error) </span><span class="cov4" title="3">{
                startTime := time.Now()

                // Create request context
                reqCtx := RequestContext{
                        RequestID: generateRequestID(),
                        Operation: "reconcile",
                        Resource:  req.Name,
                        Namespace: req.Namespace,
                        StartTime: startTime,
                }

                // Add trace context if available
                reqCtx.TraceID = GetTraceID(ctx)
                reqCtx.SpanID = GetSpanID(ctx)

                // Enrich context
                ctx = ContextWithRequestInfo(ctx, reqCtx)
                enrichedLogger := EnrichLogger(ctx, logger)
                ctx = ContextWithLogger(ctx, enrichedLogger)

                // Log request start
                enrichedLogger.Info("Starting reconciliation",
                        zap.Duration("timeout", time.Duration(0)), // Will be set by controller-runtime
                )

                // Execute reconciler
                result, err := reconciler.Reconcile(ctx, req)

                // Log completion
                duration := time.Since(startTime)
                if err != nil </span><span class="cov1" title="1">{
                        enrichedLogger.Error("Reconciliation failed",
                                zap.Error(err),
                                zap.Duration("duration", duration),
                                zap.Duration("requeue_after", result.RequeueAfter),
                        )
                }</span> else<span class="cov3" title="2"> {
                        enrichedLogger.Info("Reconciliation completed",
                                zap.Duration("duration", duration),
                                zap.Duration("requeue_after", result.RequeueAfter),
                        )
                }</span>

                <span class="cov4" title="3">return result, err</span>
        })
}

// generateRequestID generates a simple request ID
// In production, you might want to use UUID or other methods
func generateRequestID() string <span class="cov6" title="5">{
        return time.Now().Format("20060102150405.000000")
}</span>

// GenerateRequestID generates a simple request ID (public function)
func GenerateRequestID() string <span class="cov0" title="0">{
        return generateRequestID()
}</span>
</pre>

		<pre class="file" id="file12" style="display: none">package metrics

import (
        "github.com/prometheus/client_golang/prometheus"
        dto "github.com/prometheus/client_model/go"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // Business metrics for DNS records by type
        dnsRecordsByType = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_dns_records_by_type_total",
                        Help: "Total number of DNS records managed by type",
                },
                []string{"record_type", "zone_name", "zone_id"},
        )

        // DNS records by status
        dnsRecordsByStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_dns_records_by_status_total",
                        Help: "Total number of DNS records by status (active, pending, error)",
                },
                []string{"status", "zone_name", "zone_id"},
        )

        // Zone health metrics
        zoneHealthStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_zone_health_status",
                        Help: "Health status of Cloudflare zones (1 = healthy, 0 = unhealthy)",
                },
                []string{"zone_id", "zone_name", "health_check"},
        )

        // Operator reconciliation health
        reconciliationHealth = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_reconciliation_health",
                        Help: "Health status of reconciliation process (1 = healthy, 0 = unhealthy)",
                },
                []string{"controller", "namespace", "resource_type"},
        )

        // DNS propagation metrics
        dnsPropagationTime = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cloudflare_dns_propagation_time_seconds",
                        Help:    "Time taken for DNS changes to propagate",
                        Buckets: []float64{1, 5, 10, 30, 60, 180, 300, 600},
                },
                []string{"record_type", "zone_id", "operation"},
        )

        // CRD resource status
        crdResourceStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_crd_resources_total",
                        Help: "Total number of CloudflareRecord CRD resources by status",
                },
                []string{"namespace", "status", "record_type"},
        )

        // Operator uptime
        operatorUptime = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_uptime_seconds",
                        Help: "Uptime of the Cloudflare operator in seconds",
                },
                []string{"version", "namespace"},
        )

        // Configuration validity
        configurationValidity = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_configuration_validity",
                        Help: "Validity of operator configuration (1 = valid, 0 = invalid)",
                },
                []string{"config_type", "namespace"},
        )

        // SLI metrics for SLO tracking
        reconcileSuccessRate = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_reconcile_success_rate",
                        Help: "Success rate of reconciliation operations (percentage)",
                },
                []string{"controller", "namespace", "time_window"},
        )

        // Average response time SLI
        averageResponseTime = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_average_response_time_seconds",
                        Help: "Average response time for operations (SLI metric)",
                },
                []string{"operation_type", "time_window"},
        )

        // Error budget remaining
        errorBudgetRemaining = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_error_budget_remaining_percent",
                        Help: "Remaining error budget percentage for SLO tracking",
                },
                []string{"slo_name", "time_window"},
        )
)

func init() <span class="cov1" title="1">{
        // Register business metrics with controller-runtime metrics registry
        metrics.Registry.MustRegister(
                dnsRecordsByType,
                dnsRecordsByStatus,
                zoneHealthStatus,
                reconciliationHealth,
                dnsPropagationTime,
                crdResourceStatus,
                operatorUptime,
                configurationValidity,
                reconcileSuccessRate,
                averageResponseTime,
                errorBudgetRemaining,
        )
}</span>

// BusinessMetrics provides methods to update business-related metrics
type BusinessMetrics struct{}

// NewBusinessMetrics creates a new BusinessMetrics instance
func NewBusinessMetrics() *BusinessMetrics <span class="cov4" title="17">{
        return &amp;BusinessMetrics{}
}</span>

// UpdateDNSRecordsByType updates the count of DNS records by type
func (bm *BusinessMetrics) UpdateDNSRecordsByType(recordType, zoneName, zoneID string, count float64) <span class="cov9" title="2524">{
        dnsRecordsByType.WithLabelValues(recordType, zoneName, zoneID).Set(count)
}</span>

// UpdateDNSRecordsByStatus updates the count of DNS records by status
func (bm *BusinessMetrics) UpdateDNSRecordsByStatus(status, zoneName, zoneID string, count float64) <span class="cov1" title="1">{
        dnsRecordsByStatus.WithLabelValues(status, zoneName, zoneID).Set(count)
}</span>

// UpdateZoneHealth updates the health status of a zone
func (bm *BusinessMetrics) UpdateZoneHealth(zoneID, zoneName, healthCheck string, healthy bool) <span class="cov8" title="510">{
        value := 0.0
        if healthy </span><span class="cov7" title="258">{
                value = 1.0
        }</span>
        <span class="cov8" title="510">zoneHealthStatus.WithLabelValues(zoneID, zoneName, healthCheck).Set(value)</span>
}

// UpdateReconciliationHealth updates the health status of reconciliation
func (bm *BusinessMetrics) UpdateReconciliationHealth(controller, namespace, resourceType string, healthy bool) <span class="cov8" title="510">{
        value := 0.0
        if healthy </span><span class="cov7" title="258">{
                value = 1.0
        }</span>
        <span class="cov8" title="510">reconciliationHealth.WithLabelValues(controller, namespace, resourceType).Set(value)</span>
}

// ObserveDNSPropagationTime records DNS propagation time
func (bm *BusinessMetrics) ObserveDNSPropagationTime(recordType, zoneID, operation string, seconds float64) <span class="cov1" title="1">{
        dnsPropagationTime.WithLabelValues(recordType, zoneID, operation).Observe(seconds)
}</span>

// UpdateCRDResourceStatus updates the count of CRD resources by status
func (bm *BusinessMetrics) UpdateCRDResourceStatus(namespace, status, recordType string, count float64) <span class="cov9" title="2524">{
        crdResourceStatus.WithLabelValues(namespace, status, recordType).Set(count)
}</span>

// UpdateOperatorUptime updates the operator uptime
func (bm *BusinessMetrics) UpdateOperatorUptime(version, namespace string, seconds float64) <span class="cov1" title="1">{
        operatorUptime.WithLabelValues(version, namespace).Set(seconds)
}</span>

// UpdateConfigurationValidity updates configuration validity status
func (bm *BusinessMetrics) UpdateConfigurationValidity(configType, namespace string, valid bool) <span class="cov1" title="1">{
        value := 0.0
        if valid </span><span class="cov1" title="1">{
                value = 1.0
        }</span>
        <span class="cov1" title="1">configurationValidity.WithLabelValues(configType, namespace).Set(value)</span>
}

// UpdateReconcileSuccessRate updates the reconciliation success rate SLI
func (bm *BusinessMetrics) UpdateReconcileSuccessRate(controller, namespace, timeWindow string, rate float64) <span class="cov9" title="2524">{
        reconcileSuccessRate.WithLabelValues(controller, namespace, timeWindow).Set(rate)
}</span>

// UpdateAverageResponseTime updates the average response time SLI
func (bm *BusinessMetrics) UpdateAverageResponseTime(operationType, timeWindow string, seconds float64) <span class="cov1" title="1">{
        averageResponseTime.WithLabelValues(operationType, timeWindow).Set(seconds)
}</span>

// UpdateErrorBudgetRemaining updates the remaining error budget percentage
func (bm *BusinessMetrics) UpdateErrorBudgetRemaining(sloName, timeWindow string, percent float64) <span class="cov1" title="1">{
        errorBudgetRemaining.WithLabelValues(sloName, timeWindow).Set(percent)
}</span>

// GetDNSRecordsByType returns the current count of DNS records by type
func (bm *BusinessMetrics) GetDNSRecordsByType(recordType, zoneName, zoneID string) float64 <span class="cov10" title="2637">{
        if metric, err := dnsRecordsByType.GetMetricWithLabelValues(recordType, zoneName, zoneID); err == nil </span><span class="cov10" title="2637">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov10" title="2637">{
                        return *pb.Gauge.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetCRDResourceStatus returns the current count of CRD resources by status
func (bm *BusinessMetrics) GetCRDResourceStatus(namespace, status, recordType string) float64 <span class="cov10" title="2637">{
        if metric, err := crdResourceStatus.GetMetricWithLabelValues(namespace, status, recordType); err == nil </span><span class="cov10" title="2637">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov10" title="2637">{
                        return *pb.Gauge.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetReconcileSuccessRate returns the current reconciliation success rate
func (bm *BusinessMetrics) GetReconcileSuccessRate(controller, namespace, timeWindow string) float64 <span class="cov10" title="2637">{
        if metric, err := reconcileSuccessRate.GetMetricWithLabelValues(controller, namespace, timeWindow); err == nil </span><span class="cov10" title="2637">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov10" title="2637">{
                        return *pb.Gauge.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// IsZoneHealthy checks if a zone is healthy based on metrics
func (bm *BusinessMetrics) IsZoneHealthy(zoneID, zoneName, healthCheck string) bool <span class="cov8" title="624">{
        if metric, err := zoneHealthStatus.GetMetricWithLabelValues(zoneID, zoneName, healthCheck); err == nil </span><span class="cov8" title="624">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov8" title="624">{
                        return *pb.Gauge.Value == 1.0
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsReconciliationHealthy checks if reconciliation is healthy
func (bm *BusinessMetrics) IsReconciliationHealthy(controller, namespace, resourceType string) bool <span class="cov8" title="624">{
        if metric, err := reconciliationHealth.GetMetricWithLabelValues(controller, namespace, resourceType); err == nil </span><span class="cov8" title="624">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov8" title="624">{
                        return *pb.Gauge.Value == 1.0
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>

		<pre class="file" id="file13" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        dto "github.com/prometheus/client_model/go"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // Cloudflare API request metrics
        cloudflareAPIRequestsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cloudflare_api_requests_total",
                        Help: "Total number of requests made to Cloudflare API",
                },
                []string{"method", "endpoint", "status", "zone_id"},
        )

        // Cloudflare API response time
        cloudflareAPIResponseTime = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cloudflare_api_response_time_seconds",
                        Help:    "Response time of Cloudflare API requests in seconds",
                        Buckets: []float64{0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0},
                },
                []string{"method", "endpoint", "status", "zone_id"},
        )

        // Cloudflare API rate limit metrics
        cloudflareAPIRateLimitRemaining = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_api_rate_limit_remaining",
                        Help: "Remaining API rate limit for Cloudflare requests",
                },
                []string{"endpoint"},
        )

        // Cloudflare API rate limit total
        cloudflareAPIRateLimitTotal = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_api_rate_limit_total",
                        Help: "Total API rate limit for Cloudflare requests",
                },
                []string{"endpoint"},
        )

        // Cloudflare API errors
        cloudflareAPIErrorsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cloudflare_api_errors_total",
                        Help: "Total number of Cloudflare API errors",
                },
                []string{"method", "endpoint", "error_type", "zone_id"},
        )

        // Cloudflare DNS records managed
        cloudflareDNSRecordsManagedTotal = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_dns_records_managed_total",
                        Help: "Total number of DNS records currently managed by the operator",
                },
                []string{"zone_id", "zone_name", "record_type"},
        )

        // Cloudflare zones managed
        cloudflareZonesManagedTotal = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_zones_managed_total",
                        Help: "Total number of Cloudflare zones managed by the operator",
                },
                []string{"zone_name", "plan_type"},
        )

        // Cloudflare DNS record operations
        cloudflareDNSRecordOperationsTotal = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cloudflare_dns_record_operations_total",
                        Help: "Total number of DNS record operations (create, update, delete)",
                },
                []string{"operation", "record_type", "zone_id", "result"},
        )

        // Cloudflare API request duration by operation
        cloudflareOperationDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cloudflare_operation_duration_seconds",
                        Help:    "Time spent on specific Cloudflare operations",
                        Buckets: []float64{0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0, 30.0},
                },
                []string{"operation", "zone_id", "result"},
        )

        // Cloudflare zone status
        cloudflareZoneStatus = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_zone_status",
                        Help: "Status of Cloudflare zones (1 = active, 0 = inactive)",
                },
                []string{"zone_id", "zone_name", "status"},
        )
)

func init() <span class="cov1" title="1">{
        // Register Cloudflare metrics with controller-runtime metrics registry
        metrics.Registry.MustRegister(
                cloudflareAPIRequestsTotal,
                cloudflareAPIResponseTime,
                cloudflareAPIRateLimitRemaining,
                cloudflareAPIRateLimitTotal,
                cloudflareAPIErrorsTotal,
                cloudflareDNSRecordsManagedTotal,
                cloudflareZonesManagedTotal,
                cloudflareDNSRecordOperationsTotal,
                cloudflareOperationDuration,
                cloudflareZoneStatus,
        )
}</span>

// CloudflareMetrics provides methods to update Cloudflare-specific metrics
type CloudflareMetrics struct{}

// NewCloudflareMetrics creates a new CloudflareMetrics instance
func NewCloudflareMetrics() *CloudflareMetrics <span class="cov4" title="16">{
        return &amp;CloudflareMetrics{}
}</span>

// RecordAPIRequest records a Cloudflare API request
func (cm *CloudflareMetrics) RecordAPIRequest(method, endpoint, status, zoneID string, duration time.Duration) <span class="cov9" title="2613">{
        cloudflareAPIRequestsTotal.WithLabelValues(method, endpoint, status, zoneID).Inc()
        cloudflareAPIResponseTime.WithLabelValues(method, endpoint, status, zoneID).Observe(duration.Seconds())
}</span>

// RecordAPIError records a Cloudflare API error
func (cm *CloudflareMetrics) RecordAPIError(method, endpoint, errorType, zoneID string) <span class="cov2" title="4">{
        cloudflareAPIErrorsTotal.WithLabelValues(method, endpoint, errorType, zoneID).Inc()
}</span>

// UpdateRateLimit updates the API rate limit metrics
func (cm *CloudflareMetrics) UpdateRateLimit(endpoint string, remaining, total float64) <span class="cov1" title="1">{
        cloudflareAPIRateLimitRemaining.WithLabelValues(endpoint).Set(remaining)
        cloudflareAPIRateLimitTotal.WithLabelValues(endpoint).Set(total)
}</span>

// UpdateManagedRecords updates the count of managed DNS records
func (cm *CloudflareMetrics) UpdateManagedRecords(zoneID, zoneName, recordType string, count float64) <span class="cov9" title="2613">{
        cloudflareDNSRecordsManagedTotal.WithLabelValues(zoneID, zoneName, recordType).Set(count)
}</span>

// UpdateManagedZones updates the count of managed zones
func (cm *CloudflareMetrics) UpdateManagedZones(zoneName, planType string, count float64) <span class="cov1" title="1">{
        cloudflareZonesManagedTotal.WithLabelValues(zoneName, planType).Set(count)
}</span>

// RecordDNSOperation records a DNS record operation (create, update, delete)
func (cm *CloudflareMetrics) RecordDNSOperation(operation, recordType, zoneID, result string) <span class="cov1" title="1">{
        cloudflareDNSRecordOperationsTotal.WithLabelValues(operation, recordType, zoneID, result).Inc()
}</span>

// ObserveOperationDuration records the duration of a Cloudflare operation
func (cm *CloudflareMetrics) ObserveOperationDuration(operation, zoneID, result string, duration time.Duration) <span class="cov1" title="1">{
        cloudflareOperationDuration.WithLabelValues(operation, zoneID, result).Observe(duration.Seconds())
}</span>

// UpdateZoneStatus updates the status of a Cloudflare zone
func (cm *CloudflareMetrics) UpdateZoneStatus(zoneID, zoneName, status string, active bool) <span class="cov1" title="1">{
        value := 0.0
        if active </span><span class="cov1" title="1">{
                value = 1.0
        }</span>
        <span class="cov1" title="1">cloudflareZoneStatus.WithLabelValues(zoneID, zoneName, status).Set(value)</span>
}

// GetAPIRequestCount returns the current API request count for a specific endpoint
func (cm *CloudflareMetrics) GetAPIRequestCount(method, endpoint, status, zoneID string) float64 <span class="cov9" title="2627">{
        if metric, err := cloudflareAPIRequestsTotal.GetMetricWithLabelValues(method, endpoint, status, zoneID); err == nil </span><span class="cov9" title="2627">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Counter != nil </span><span class="cov9" title="2627">{
                        return *pb.Counter.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetManagedRecordsCount returns the current count of managed records
func (cm *CloudflareMetrics) GetManagedRecordsCount(zoneID, zoneName, recordType string) float64 <span class="cov10" title="2630">{
        if metric, err := cloudflareDNSRecordsManagedTotal.GetMetricWithLabelValues(zoneID, zoneName, recordType); err == nil </span><span class="cov10" title="2630">{
                pb := &amp;dto.Metric{}
                if err := metric.Write(pb); err == nil &amp;&amp; pb.Gauge != nil </span><span class="cov10" title="2630">{
                        return *pb.Gauge.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// APICallTimer provides a convenient way to time API calls
type APICallTimer struct {
        cm       *CloudflareMetrics
        method   string
        endpoint string
        zoneID   string
        start    time.Time
}

// NewAPICallTimer creates a new API call timer
func (cm *CloudflareMetrics) NewAPICallTimer(method, endpoint, zoneID string) *APICallTimer <span class="cov2" title="5">{
        return &amp;APICallTimer{
                cm:       cm,
                method:   method,
                endpoint: endpoint,
                zoneID:   zoneID,
                start:    time.Now(),
        }
}</span>

// RecordSuccess records a successful API call
func (t *APICallTimer) RecordSuccess() <span class="cov2" title="4">{
        duration := time.Since(t.start)
        t.cm.RecordAPIRequest(t.method, t.endpoint, "success", t.zoneID, duration)
}</span>

// RecordError records a failed API call
func (t *APICallTimer) RecordError(errorType string) <span class="cov2" title="3">{
        duration := time.Since(t.start)
        t.cm.RecordAPIRequest(t.method, t.endpoint, "error", t.zoneID, duration)
        t.cm.RecordAPIError(t.method, t.endpoint, errorType, t.zoneID)
}</span>
</pre>

		<pre class="file" id="file14" style="display: none">package metrics

import (
        "time"

        "github.com/prometheus/client_golang/prometheus"
        dto "github.com/prometheus/client_model/go"
        "sigs.k8s.io/controller-runtime/pkg/metrics"
)

var (
        // Queue depth metric - number of pending reconcile requests
        queueDepth = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_queue_depth",
                        Help: "Number of pending reconcile requests in the controller queue",
                },
                []string{"controller", "namespace"},
        )

        // Reconcile rate metric - reconciles per second
        reconcileRate = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cloudflare_operator_reconcile_rate_total",
                        Help: "Total number of reconciles processed",
                },
                []string{"controller", "result", "namespace"}, // result: success, error, requeue
        )

        // Error rate metric - errors per minute
        errorRate = prometheus.NewCounterVec(
                prometheus.CounterOpts{
                        Name: "cloudflare_operator_error_rate_total",
                        Help: "Total number of errors encountered during reconciliation",
                },
                []string{"controller", "error_type", "namespace"},
        )

        // API response time metric
        apiResponseTime = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cloudflare_operator_api_response_time_seconds",
                        Help:    "Response time of Cloudflare API calls in seconds",
                        Buckets: prometheus.DefBuckets,
                },
                []string{"operation", "status_code", "namespace"},
        )

        // Reconcile duration metric
        reconcileDuration = prometheus.NewHistogramVec(
                prometheus.HistogramOpts{
                        Name:    "cloudflare_operator_reconcile_duration_seconds",
                        Help:    "Time taken to complete reconciliation in seconds",
                        Buckets: []float64{0.1, 0.5, 1.0, 2.5, 5.0, 10.0, 15.0, 30.0},
                },
                []string{"controller", "result", "namespace"},
        )

        // Resource processing rate
        resourceProcessingRate = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_resources_per_second",
                        Help: "Number of resources processed per second",
                },
                []string{"controller", "namespace"},
        )

        // Cache hit ratio
        cacheHitRatio = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_cache_hit_ratio",
                        Help: "Cache hit ratio for controller operations",
                },
                []string{"controller", "cache_type"},
        )

        // Memory usage tracking
        memoryUsage = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_memory_usage_bytes",
                        Help: "Memory usage of the operator in bytes",
                },
                []string{"type"}, // type: heap, stack, gc
        )

        // CPU usage tracking
        cpuUsage = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_cpu_usage_seconds_total",
                        Help: "CPU usage of the operator in seconds",
                },
                []string{"type"}, // type: user, system
        )

        // Active workers metric
        activeWorkers = prometheus.NewGaugeVec(
                prometheus.GaugeOpts{
                        Name: "cloudflare_operator_active_workers",
                        Help: "Number of active reconcile workers",
                },
                []string{"controller"},
        )
)

func init() <span class="cov1" title="1">{
        // Register metrics with controller-runtime metrics registry
        metrics.Registry.MustRegister(
                queueDepth,
                reconcileRate,
                errorRate,
                apiResponseTime,
                reconcileDuration,
                resourceProcessingRate,
                cacheHitRatio,
                memoryUsage,
                cpuUsage,
                activeWorkers,
        )
}</span>

// PerformanceMetrics provides methods to update performance metrics
type PerformanceMetrics struct{}

// NewPerformanceMetrics creates a new PerformanceMetrics instance
func NewPerformanceMetrics() *PerformanceMetrics <span class="cov4" title="34">{
        return &amp;PerformanceMetrics{}
}</span>

// UpdateQueueDepth updates the queue depth metric
func (pm *PerformanceMetrics) UpdateQueueDepth(controller, namespace string, depth float64) <span class="cov10" title="7643">{
        queueDepth.WithLabelValues(controller, namespace).Set(depth)
}</span>

// IncReconcileRate increments the reconcile rate metric
func (pm *PerformanceMetrics) IncReconcileRate(controller, result, namespace string) <span class="cov7" title="632">{
        reconcileRate.WithLabelValues(controller, result, namespace).Inc()
}</span>

// IncErrorRate increments the error rate metric
func (pm *PerformanceMetrics) IncErrorRate(controller, errorType, namespace string) <span class="cov7" title="629">{
        errorRate.WithLabelValues(controller, errorType, namespace).Inc()
}</span>

// ObserveAPIResponseTime records API response time
func (pm *PerformanceMetrics) ObserveAPIResponseTime(operation, statusCode, namespace string, duration time.Duration) <span class="cov3" title="13">{
        apiResponseTime.WithLabelValues(operation, statusCode, namespace).Observe(duration.Seconds())
}</span>

// ObserveReconcileDuration records reconcile duration
func (pm *PerformanceMetrics) ObserveReconcileDuration(controller, result, namespace string, duration time.Duration) <span class="cov3" title="13">{
        reconcileDuration.WithLabelValues(controller, result, namespace).Observe(duration.Seconds())
}</span>

// UpdateResourceProcessingRate updates the resource processing rate
func (pm *PerformanceMetrics) UpdateResourceProcessingRate(controller, namespace string, rate float64) <span class="cov3" title="13">{
        resourceProcessingRate.WithLabelValues(controller, namespace).Set(rate)
}</span>

// UpdateCacheHitRatio updates the cache hit ratio
func (pm *PerformanceMetrics) UpdateCacheHitRatio(controller, cacheType string, ratio float64) <span class="cov1" title="2">{
        cacheHitRatio.WithLabelValues(controller, cacheType).Set(ratio)
}</span>

// UpdateMemoryUsage updates memory usage metrics
func (pm *PerformanceMetrics) UpdateMemoryUsage(memType string, bytes float64) <span class="cov1" title="2">{
        memoryUsage.WithLabelValues(memType).Set(bytes)
}</span>

// UpdateCPUUsage updates CPU usage metrics
func (pm *PerformanceMetrics) UpdateCPUUsage(cpuType string, seconds float64) <span class="cov1" title="2">{
        cpuUsage.WithLabelValues(cpuType).Set(seconds)
}</span>

// UpdateActiveWorkers updates the active workers metric
func (pm *PerformanceMetrics) UpdateActiveWorkers(controller string, count float64) <span class="cov1" title="2">{
        activeWorkers.WithLabelValues(controller).Set(count)
}</span>

// GetQueueDepthMetric returns the current queue depth for HPA
func (pm *PerformanceMetrics) GetQueueDepthMetric(controller, namespace string) float64 <span class="cov9" title="6665">{
        metric := &amp;dto.Metric{}
        if m, err := queueDepth.GetMetricWithLabelValues(controller, namespace); err == nil </span><span class="cov9" title="6665">{
                if err := m.Write(metric); err == nil &amp;&amp; metric.Gauge != nil </span><span class="cov9" title="6665">{
                        return *metric.Gauge.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetReconcileRateMetric returns the current reconcile rate for HPA
func (pm *PerformanceMetrics) GetReconcileRateMetric(controller, namespace string) float64 <span class="cov7" title="638">{
        // Calculate rate based on success reconciles in the last minute
        metric := &amp;dto.Metric{}
        if m, err := reconcileRate.GetMetricWithLabelValues(controller, "success", namespace); err == nil </span><span class="cov7" title="638">{
                if err := m.Write(metric); err == nil &amp;&amp; metric.Counter != nil </span><span class="cov7" title="638">{
                        return *metric.Counter.Value
                }</span>
        }
        <span class="cov0" title="0">return 0</span>
}

// GetErrorRateMetric returns the current error rate for HPA
func (pm *PerformanceMetrics) GetErrorRateMetric(controller, namespace string) float64 <span class="cov7" title="617">{
        // Sum all error types for the controller and namespace
        totalErrors := 0.0

        // This is a simplified version - in practice, you'd iterate through all error types
        metric := &amp;dto.Metric{}
        if m, err := errorRate.GetMetricWithLabelValues(controller, "reconcile_error", namespace); err == nil </span><span class="cov7" title="617">{
                if err := m.Write(metric); err == nil &amp;&amp; metric.Counter != nil </span><span class="cov7" title="617">{
                        totalErrors += *metric.Counter.Value
                }</span>
        }

        <span class="cov7" title="617">return totalErrors</span>
}
</pre>

		<pre class="file" id="file15" style="display: none">package reliability

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// CircuitBreakerState represents the current state of the circuit breaker
type CircuitBreakerState int

const (
        // StateClosed - Circuit is closed, requests flow normally
        StateClosed CircuitBreakerState = iota
        // StateOpen - Circuit is open, requests are rejected
        StateOpen
        // StateHalfOpen - Circuit is half-open, limited requests are allowed to test recovery
        StateHalfOpen
)

func (s CircuitBreakerState) String() string <span class="cov9" title="154">{
        switch s </span>{
        case StateClosed:<span class="cov8" title="101">
                return "closed"</span>
        case StateOpen:<span class="cov6" title="28">
                return "open"</span>
        case StateHalfOpen:<span class="cov6" title="25">
                return "half-open"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// CircuitBreakerConfig holds configuration for the circuit breaker
type CircuitBreakerConfig struct {
        // Name is the circuit breaker identifier
        Name string

        // MaxRequests is the maximum number of requests allowed to pass through
        // when the circuit breaker is half-open
        MaxRequests uint32

        // Interval is the cyclic period of the closed state for the circuit breaker
        // to clear the internal counts
        Interval time.Duration

        // Timeout is the period of the open state after which the state becomes half-open
        Timeout time.Duration

        // ReadyToTrip is called with a copy of Counts whenever a request fails in the closed state.
        // If ReadyToTrip returns true, the circuit breaker will be placed into the open state.
        ReadyToTrip func(counts Counts) bool

        // OnStateChange is called whenever the state of the circuit breaker changes
        OnStateChange func(name string, from CircuitBreakerState, to CircuitBreakerState)

        // IsSuccessful determines whether a given error should be counted as a success or failure
        IsSuccessful func(err error) bool
}

// Counts holds the numbers of requests and their successes/failures
type Counts struct {
        Requests             uint32
        TotalSuccesses       uint32
        TotalFailures        uint32
        ConsecutiveSuccesses uint32
        ConsecutiveFailures  uint32
}

// Reset resets all counts to zero
func (c *Counts) Reset() <span class="cov6" title="19">{
        c.Requests = 0
        c.TotalSuccesses = 0
        c.TotalFailures = 0
        c.ConsecutiveSuccesses = 0
        c.ConsecutiveFailures = 0
}</span>

// OnRequest increments the number of requests
func (c *Counts) OnRequest() <span class="cov8" title="86">{
        c.Requests++
}</span>

// OnSuccess increments the number of successes
func (c *Counts) OnSuccess() <span class="cov8" title="65">{
        c.TotalSuccesses++
        c.ConsecutiveSuccesses++
        c.ConsecutiveFailures = 0
}</span>

// OnFailure increments the number of failures
func (c *Counts) OnFailure() <span class="cov6" title="21">{
        c.TotalFailures++
        c.ConsecutiveFailures++
        c.ConsecutiveSuccesses = 0
}</span>

// SuccessRate returns the success rate as a float between 0 and 1
func (c *Counts) SuccessRate() float64 <span class="cov2" title="3">{
        if c.Requests == 0 </span><span class="cov1" title="1">{
                return 0
        }</span>
        <span class="cov2" title="2">return float64(c.TotalSuccesses) / float64(c.Requests)</span>
}

// FailureRate returns the failure rate as a float between 0 and 1
func (c *Counts) FailureRate() float64 <span class="cov6" title="24">{
        if c.Requests == 0 </span><span class="cov5" title="17">{
                return 0
        }</span>
        <span class="cov4" title="7">return float64(c.TotalFailures) / float64(c.Requests)</span>
}

// CircuitBreaker implements the circuit breaker pattern
type CircuitBreaker struct {
        config CircuitBreakerConfig
        logger *zap.Logger

        // Synchronization
        mu sync.RWMutex

        // State management
        state       CircuitBreakerState
        generation  uint64
        counts      Counts
        expiry      time.Time

        // Metrics
        requestsTotal      *prometheus.CounterVec
        successesTotal     *prometheus.CounterVec
        failuresTotal      *prometheus.CounterVec
        stateChangesTotal  *prometheus.CounterVec
        stateDuration      *prometheus.GaugeVec
        currentStateGauge  *prometheus.GaugeVec
}

// NewCircuitBreaker creates a new circuit breaker with the given configuration
func NewCircuitBreaker(config CircuitBreakerConfig, logger *zap.Logger) *CircuitBreaker <span class="cov0" title="0">{
        return NewCircuitBreakerWithRegistry(config, logger, prometheus.DefaultRegisterer)
}</span>

// NewCircuitBreakerWithRegistry creates a new circuit breaker with a custom metrics registry
func NewCircuitBreakerWithRegistry(config CircuitBreakerConfig, logger *zap.Logger, registerer prometheus.Registerer) *CircuitBreaker <span class="cov5" title="12">{
        // Set default configuration values
        if config.MaxRequests == 0 </span><span class="cov1" title="1">{
                config.MaxRequests = 1
        }</span>
        <span class="cov5" title="12">if config.Interval == 0 </span><span class="cov3" title="5">{
                config.Interval = 60 * time.Second
        }</span>
        <span class="cov5" title="12">if config.Timeout == 0 </span><span class="cov4" title="6">{
                config.Timeout = 60 * time.Second
        }</span>
        <span class="cov5" title="12">if config.ReadyToTrip == nil </span><span class="cov2" title="3">{
                config.ReadyToTrip = defaultReadyToTrip
        }</span>
        <span class="cov5" title="12">if config.IsSuccessful == nil </span><span class="cov5" title="11">{
                config.IsSuccessful = defaultIsSuccessful
        }</span>

        <span class="cov5" title="12">cb := &amp;CircuitBreaker{
                config:     config,
                logger:     logger,
                state:      StateClosed,
                generation: 0,
                expiry:     time.Now().Add(config.Interval),

                requestsTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "circuit_breaker_requests_total",
                                Help: "Total number of requests handled by circuit breaker",
                        },
                        []string{"name", "state"},
                ),

                successesTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "circuit_breaker_successes_total",
                                Help: "Total number of successful requests",
                        },
                        []string{"name"},
                ),

                failuresTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "circuit_breaker_failures_total",
                                Help: "Total number of failed requests",
                        },
                        []string{"name"},
                ),

                stateChangesTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "circuit_breaker_state_changes_total",
                                Help: "Total number of state changes",
                        },
                        []string{"name", "from_state", "to_state"},
                ),

                stateDuration: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "circuit_breaker_state_duration_seconds",
                                Help: "Duration spent in each state",
                        },
                        []string{"name", "state"},
                ),

                currentStateGauge: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "circuit_breaker_current_state",
                                Help: "Current state of circuit breaker (0=closed, 1=open, 2=half-open)",
                        },
                        []string{"name"},
                ),
        }

        // Register metrics if registerer provided
        if registerer != nil </span><span class="cov5" title="12">{
                registerer.MustRegister(
                        cb.requestsTotal,
                        cb.successesTotal,
                        cb.failuresTotal,
                        cb.stateChangesTotal,
                        cb.stateDuration,
                        cb.currentStateGauge,
                )
        }</span>

        // Set initial state metric
        <span class="cov5" title="12">cb.currentStateGauge.WithLabelValues(config.Name).Set(float64(StateClosed))

        return cb</span>
}

// Execute runs the given function if the circuit breaker accepts the request
func (cb *CircuitBreaker) Execute(ctx context.Context, fn func(context.Context) error) error <span class="cov8" title="86">{
        generation, err := cb.beforeRequest()
        if err != nil </span><span class="cov2" title="2">{
                return err
        }</span>

        <span class="cov8" title="84">defer func() </span><span class="cov8" title="84">{
                // Recover from panics and treat them as failures
                if r := recover(); r != nil </span><span class="cov1" title="1">{
                        cb.afterRequest(generation, fmt.Errorf("panic recovered: %v", r))
                        panic(r)</span> // Re-panic after recording the failure
                }
        }()

        // Execute the function
        <span class="cov8" title="84">err = fn(ctx)
        cb.afterRequest(generation, err)

        return err</span>
}

// beforeRequest is called before a request is executed
func (cb *CircuitBreaker) beforeRequest() (uint64, error) <span class="cov8" title="86">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        now := time.Now()
        state, generation := cb.currentState(now)

        if state == StateOpen </span><span class="cov2" title="2">{
                cb.requestsTotal.WithLabelValues(cb.config.Name, "open").Inc()
                return generation, ErrCircuitBreakerOpen
        }</span> else<span class="cov8" title="84"> if state == StateHalfOpen &amp;&amp; cb.counts.Requests &gt;= cb.config.MaxRequests </span><span class="cov0" title="0">{
                cb.requestsTotal.WithLabelValues(cb.config.Name, "half-open-rejected").Inc()
                return generation, ErrCircuitBreakerOpen
        }</span>

        <span class="cov8" title="84">cb.counts.OnRequest()
        cb.requestsTotal.WithLabelValues(cb.config.Name, state.String()).Inc()

        return generation, nil</span>
}

// afterRequest is called after a request is executed
func (cb *CircuitBreaker) afterRequest(before uint64, err error) <span class="cov8" title="84">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        now := time.Now()
        state, generation := cb.currentState(now)

        // If generation has changed, ignore this result (too late)
        if generation != before </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="84">if cb.config.IsSuccessful(err) </span><span class="cov8" title="64">{
                cb.onSuccess(state, now)
        }</span> else<span class="cov6" title="20"> {
                cb.onFailure(state, now)
        }</span>
}

// onSuccess handles successful requests
func (cb *CircuitBreaker) onSuccess(state CircuitBreakerState, now time.Time) <span class="cov8" title="64">{
        cb.counts.OnSuccess()
        cb.successesTotal.WithLabelValues(cb.config.Name).Inc()

        if state == StateHalfOpen &amp;&amp; cb.counts.ConsecutiveSuccesses &gt;= cb.config.MaxRequests </span><span class="cov2" title="3">{
                cb.setState(StateClosed, now)
        }</span>
}

// onFailure handles failed requests
func (cb *CircuitBreaker) onFailure(state CircuitBreakerState, now time.Time) <span class="cov6" title="20">{
        cb.counts.OnFailure()
        cb.failuresTotal.WithLabelValues(cb.config.Name).Inc()

        if state == StateClosed </span><span class="cov6" title="19">{
                if cb.config.ReadyToTrip(cb.counts) </span><span class="cov4" title="7">{
                        cb.setState(StateOpen, now)
                }</span>
        } else<span class="cov1" title="1"> if state == StateHalfOpen </span><span class="cov1" title="1">{
                cb.setState(StateOpen, now)
        }</span>
}

// currentState returns the current state and generation
func (cb *CircuitBreaker) currentState(now time.Time) (CircuitBreakerState, uint64) <span class="cov10" title="186">{
        switch cb.state </span>{
        case StateClosed:<span class="cov9" title="161">
                if !cb.expiry.IsZero() &amp;&amp; cb.expiry.Before(now) </span><span class="cov1" title="1">{
                        cb.toNewGeneration(now)
                }</span>
        case StateOpen:<span class="cov5" title="13">
                if cb.expiry.Before(now) </span><span class="cov3" title="4">{
                        cb.setState(StateHalfOpen, now)
                }</span>
        }
        <span class="cov10" title="186">return cb.state, cb.generation</span>
}

// setState changes the state of the circuit breaker
func (cb *CircuitBreaker) setState(state CircuitBreakerState, now time.Time) <span class="cov5" title="16">{
        if cb.state == state </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov5" title="16">prev := cb.state
        cb.state = state
        cb.toNewGeneration(now)

        // Update metrics
        cb.stateChangesTotal.WithLabelValues(cb.config.Name, prev.String(), state.String()).Inc()
        cb.currentStateGauge.WithLabelValues(cb.config.Name).Set(float64(state))

        // Call state change callback
        if cb.config.OnStateChange != nil </span><span class="cov2" title="3">{
                cb.config.OnStateChange(cb.config.Name, prev, state)
        }</span>

        // Log state change
        <span class="cov5" title="16">cb.logger.Info("Circuit breaker state changed",
                zap.String("name", cb.config.Name),
                zap.String("from", prev.String()),
                zap.String("to", state.String()),
                zap.Uint32("requests", cb.counts.Requests),
                zap.Uint32("failures", cb.counts.TotalFailures),
                zap.Float64("failure_rate", cb.counts.FailureRate()),
        )</span>
}

// toNewGeneration resets counts and expiry for a new generation
func (cb *CircuitBreaker) toNewGeneration(now time.Time) <span class="cov5" title="18">{
        cb.generation++
        cb.counts.Reset()

        var expiry time.Time
        switch cb.state </span>{
        case StateClosed:<span class="cov3" title="5">
                if cb.config.Interval == 0 </span><span class="cov0" title="0">{
                        expiry = time.Time{}
                }</span> else<span class="cov3" title="5"> {
                        expiry = now.Add(cb.config.Interval)
                }</span>
        case StateOpen:<span class="cov4" title="9">
                expiry = now.Add(cb.config.Timeout)</span>
        default:<span class="cov3" title="4"> // StateHalfOpen
                expiry = time.Time{}</span>
        }
        <span class="cov5" title="18">cb.expiry = expiry</span>
}

// State returns the current state of the circuit breaker
func (cb *CircuitBreaker) State() CircuitBreakerState <span class="cov5" title="16">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        state, _ := cb.currentState(time.Now())
        return state
}</span>

// Counts returns a copy of the current counts
func (cb *CircuitBreaker) Counts() Counts <span class="cov4" title="6">{
        cb.mu.RLock()
        defer cb.mu.RUnlock()

        return cb.counts
}</span>

// Name returns the circuit breaker name
func (cb *CircuitBreaker) Name() string <span class="cov1" title="1">{
        return cb.config.Name
}</span>

// Reset resets the circuit breaker to the closed state
func (cb *CircuitBreaker) Reset() <span class="cov1" title="1">{
        cb.mu.Lock()
        defer cb.mu.Unlock()

        cb.toNewGeneration(time.Now())
        cb.setState(StateClosed, time.Now())
}</span>

// Errors
var (
        ErrCircuitBreakerOpen = fmt.Errorf("circuit breaker is open")
)

// Default functions
func defaultReadyToTrip(counts Counts) bool <span class="cov3" title="5">{
        return counts.Requests &gt;= 5 &amp;&amp; counts.FailureRate() &gt;= 0.6
}</span>

func defaultIsSuccessful(err error) bool <span class="cov8" title="81">{
        return err == nil
}</pre>

		<pre class="file" id="file16" style="display: none">package reliability

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// RateLimiterType defines the type of rate limiting algorithm
type RateLimiterType string

const (
        // TokenBucket uses token bucket algorithm
        TokenBucket RateLimiterType = "token_bucket"
        // SlidingWindow uses sliding window algorithm
        SlidingWindow RateLimiterType = "sliding_window"
        // FixedWindow uses fixed window algorithm
        FixedWindow RateLimiterType = "fixed_window"
)

// RateLimiterConfig holds configuration for the rate limiter
type RateLimiterConfig struct {
        // Name is the rate limiter identifier
        Name string

        // Type is the rate limiting algorithm type
        Type RateLimiterType

        // RequestsPerSecond is the allowed rate (requests per second)
        RequestsPerSecond float64

        // BurstSize is the maximum burst size allowed (only for token bucket)
        BurstSize int

        // WindowSize is the time window size (for windowed algorithms)
        WindowSize time.Duration

        // BackoffStrategy defines how to handle rate limit exceeded
        BackoffStrategy BackoffStrategy

        // OnRateLimited is called when rate limit is exceeded
        OnRateLimited func(limiterName string, delay time.Duration)
}

// BackoffStrategy defines how to handle rate limit exceeded
type BackoffStrategy string

const (
        // Block waits until rate limit allows the request
        Block BackoffStrategy = "block"
        // Reject immediately rejects the request
        Reject BackoffStrategy = "reject"
        // Adaptive dynamically adjusts based on current load
        Adaptive BackoffStrategy = "adaptive"
)

// RateLimiter interface defines rate limiting operations
type RateLimiter interface {
        // Allow checks if a request is allowed and returns immediately
        Allow() bool

        // Wait blocks until the request can be processed
        Wait(ctx context.Context) error

        // Reserve reserves a slot and returns the delay needed
        Reserve() time.Duration

        // SetRate updates the rate limit dynamically
        SetRate(requestsPerSecond float64, burstSize int)

        // Stats returns current rate limiter statistics
        Stats() RateLimiterStats

        // Reset resets the rate limiter state
        Reset()
}

// RateLimiterStats holds rate limiter statistics
type RateLimiterStats struct {
        RequestsAllowed   uint64
        RequestsRejected  uint64
        RequestsWaiting   uint64
        CurrentTokens     float64
        RequestsPerSecond float64
        BurstSize         int
        LastRefill        time.Time
}

// TokenBucketLimiter implements token bucket rate limiting
type TokenBucketLimiter struct {
        config RateLimiterConfig
        logger *zap.Logger

        // Token bucket state
        mu            sync.Mutex
        tokens        float64
        lastRefill    time.Time
        maxTokens     float64
        refillRate    float64

        // Statistics
        allowed   uint64
        rejected  uint64
        waiting   uint64

        // Prometheus metrics
        requestsTotal    *prometheus.CounterVec
        waitingDuration  *prometheus.HistogramVec
        tokensGauge      *prometheus.GaugeVec
        rateGauge        *prometheus.GaugeVec
}

// NewRateLimiter creates a new rate limiter with the given configuration
func NewRateLimiter(config RateLimiterConfig, logger *zap.Logger) RateLimiter <span class="cov1" title="1">{
        return NewRateLimiterWithRegistry(config, logger, prometheus.DefaultRegisterer)
}</span>

// NewRateLimiterWithRegistry creates a new rate limiter with a custom metrics registry
func NewRateLimiterWithRegistry(config RateLimiterConfig, logger *zap.Logger, registerer prometheus.Registerer) RateLimiter <span class="cov4" title="21">{
        // Set default values
        if config.RequestsPerSecond &lt;= 0 </span><span class="cov2" title="6">{
                config.RequestsPerSecond = 10.0
        }</span>
        <span class="cov4" title="21">if config.BurstSize &lt;= 0 </span><span class="cov3" title="7">{
                config.BurstSize = int(config.RequestsPerSecond)
        }</span>
        <span class="cov4" title="21">if config.WindowSize == 0 </span><span class="cov4" title="21">{
                config.WindowSize = 1 * time.Second
        }</span>
        <span class="cov4" title="21">if config.BackoffStrategy == "" </span><span class="cov3" title="14">{
                config.BackoffStrategy = Block
        }</span>
        <span class="cov4" title="21">if config.Type == "" </span><span class="cov2" title="4">{
                config.Type = TokenBucket
        }</span>

        <span class="cov4" title="21">switch config.Type </span>{
        case TokenBucket:<span class="cov3" title="18">
                return newTokenBucketLimiter(config, logger, registerer)</span>
        case SlidingWindow:<span class="cov1" title="1">
                return newSlidingWindowLimiter(config, logger, registerer)</span>
        case FixedWindow:<span class="cov1" title="1">
                return newFixedWindowLimiter(config, logger, registerer)</span>
        default:<span class="cov1" title="1">
                logger.Warn("Unknown rate limiter type, using token bucket",
                        zap.String("type", string(config.Type)))
                config.Type = TokenBucket
                return newTokenBucketLimiter(config, logger, registerer)</span>
        }
}

// newTokenBucketLimiter creates a new token bucket rate limiter
func newTokenBucketLimiter(config RateLimiterConfig, logger *zap.Logger, registerer prometheus.Registerer) *TokenBucketLimiter <span class="cov4" title="21">{
        limiter := &amp;TokenBucketLimiter{
                config:     config,
                logger:     logger,
                tokens:     float64(config.BurstSize),
                lastRefill: time.Now(),
                maxTokens:  float64(config.BurstSize),
                refillRate: config.RequestsPerSecond,

                requestsTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "rate_limiter_requests_total",
                                Help: "Total number of requests processed by rate limiter",
                        },
                        []string{"name", "result"},
                ),

                waitingDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "rate_limiter_waiting_duration_seconds",
                                Help:    "Time spent waiting for rate limiter",
                                Buckets: prometheus.ExponentialBuckets(0.001, 2, 15),
                        },
                        []string{"name"},
                ),

                tokensGauge: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "rate_limiter_tokens_available",
                                Help: "Current number of available tokens",
                        },
                        []string{"name"},
                ),

                rateGauge: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "rate_limiter_rate_per_second",
                                Help: "Current rate limit in requests per second",
                        },
                        []string{"name"},
                ),
        }

        // Register metrics
        if registerer != nil </span><span class="cov4" title="21">{
                registerer.MustRegister(
                        limiter.requestsTotal,
                        limiter.waitingDuration,
                        limiter.tokensGauge,
                        limiter.rateGauge,
                )
        }</span>

        // Set initial metric values
        <span class="cov4" title="21">limiter.tokensGauge.WithLabelValues(config.Name).Set(limiter.tokens)
        limiter.rateGauge.WithLabelValues(config.Name).Set(config.RequestsPerSecond)

        return limiter</span>
}

// Allow checks if a request is allowed and returns immediately
func (tb *TokenBucketLimiter) Allow() bool <span class="cov9" title="3245">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        tb.refillTokens()

        if tb.tokens &gt;= 1.0 </span><span class="cov7" title="352">{
                tb.tokens--
                tb.allowed++
                tb.requestsTotal.WithLabelValues(tb.config.Name, "allowed").Inc()
                tb.tokensGauge.WithLabelValues(tb.config.Name).Set(tb.tokens)
                return true
        }</span>

        <span class="cov9" title="2893">tb.rejected++
        tb.requestsTotal.WithLabelValues(tb.config.Name, "rejected").Inc()
        return false</span>
}

// Wait blocks until the request can be processed
func (tb *TokenBucketLimiter) Wait(ctx context.Context) error <span class="cov6" title="209">{
        startTime := time.Now()
        defer func() </span><span class="cov6" title="209">{
                duration := time.Since(startTime)
                tb.waitingDuration.WithLabelValues(tb.config.Name).Observe(duration.Seconds())
        }</span>()

        <span class="cov6" title="209">for </span><span class="cov9" title="2922">{
                // Check if we can proceed
                if tb.Allow() </span><span class="cov6" title="207">{
                        return nil
                }</span>

                // Calculate delay needed
                <span class="cov9" title="2715">delay := tb.Reserve()
                if delay == 0 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Handle different backoff strategies
                <span class="cov9" title="2715">switch tb.config.BackoffStrategy </span>{
                case Reject:<span class="cov1" title="1">
                        return ErrRateLimited</span>
                case Block:<span class="cov9" title="2713">
                        // Wait for the calculated delay
                        timer := time.NewTimer(delay)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov1" title="1">
                                timer.Stop()
                                return ctx.Err()</span>
                        case &lt;-timer.C:<span class="cov9" title="2712"></span>
                                // Continue the loop to try again
                        }
                case Adaptive:<span class="cov1" title="1">
                        // Adaptive strategy - reduce delay based on system load
                        adaptiveDelay := tb.calculateAdaptiveDelay(delay)
                        timer := time.NewTimer(adaptiveDelay)
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                timer.Stop()
                                return ctx.Err()</span>
                        case &lt;-timer.C:<span class="cov1" title="1"></span>
                                // Continue the loop to try again
                        }
                }

                // Call rate limited callback if configured
                <span class="cov9" title="2713">if tb.config.OnRateLimited != nil </span><span class="cov1" title="1">{
                        tb.config.OnRateLimited(tb.config.Name, delay)
                }</span>
        }
}

// Reserve reserves a slot and returns the delay needed
func (tb *TokenBucketLimiter) Reserve() time.Duration <span class="cov9" title="2717">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        tb.refillTokens()

        if tb.tokens &gt;= 1.0 </span><span class="cov1" title="1">{
                return 0 // No delay needed
        }</span>

        // Calculate delay needed to get one token
        <span class="cov9" title="2716">tokensNeeded := 1.0 - tb.tokens
        delay := time.Duration(tokensNeeded/tb.refillRate*float64(time.Second))

        return delay</span>
}

// SetRate updates the rate limit dynamically
func (tb *TokenBucketLimiter) SetRate(requestsPerSecond float64, burstSize int) <span class="cov1" title="1">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        tb.refillRate = requestsPerSecond
        tb.maxTokens = float64(burstSize)

        // Adjust current tokens if needed
        if tb.tokens &gt; tb.maxTokens </span><span class="cov1" title="1">{
                tb.tokens = tb.maxTokens
        }</span>

        <span class="cov1" title="1">tb.config.RequestsPerSecond = requestsPerSecond
        tb.config.BurstSize = burstSize

        // Update metrics
        tb.tokensGauge.WithLabelValues(tb.config.Name).Set(tb.tokens)
        tb.rateGauge.WithLabelValues(tb.config.Name).Set(requestsPerSecond)

        tb.logger.Info("Rate limit updated",
                zap.String("name", tb.config.Name),
                zap.Float64("requests_per_second", requestsPerSecond),
                zap.Int("burst_size", burstSize),
        )</span>
}

// Stats returns current rate limiter statistics
func (tb *TokenBucketLimiter) Stats() RateLimiterStats <span class="cov2" title="4">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        tb.refillTokens()

        return RateLimiterStats{
                RequestsAllowed:   tb.allowed,
                RequestsRejected:  tb.rejected,
                RequestsWaiting:   tb.waiting,
                CurrentTokens:     tb.tokens,
                RequestsPerSecond: tb.refillRate,
                BurstSize:         int(tb.maxTokens),
                LastRefill:        tb.lastRefill,
        }
}</span>

// Reset resets the rate limiter state
func (tb *TokenBucketLimiter) Reset() <span class="cov1" title="1">{
        tb.mu.Lock()
        defer tb.mu.Unlock()

        tb.tokens = tb.maxTokens
        tb.lastRefill = time.Now()
        tb.allowed = 0
        tb.rejected = 0
        tb.waiting = 0

        tb.tokensGauge.WithLabelValues(tb.config.Name).Set(tb.tokens)
}</span>

// refillTokens refills the token bucket based on elapsed time
func (tb *TokenBucketLimiter) refillTokens() <span class="cov9" title="5966">{
        now := time.Now()
        elapsed := now.Sub(tb.lastRefill)
        tb.lastRefill = now

        // Calculate tokens to add
        tokensToAdd := tb.refillRate * elapsed.Seconds()
        tb.tokens = min(tb.tokens+tokensToAdd, tb.maxTokens)
}</span>

// calculateAdaptiveDelay calculates adaptive delay based on current system state
func (tb *TokenBucketLimiter) calculateAdaptiveDelay(baseDelay time.Duration) time.Duration <span class="cov1" title="1">{
        // Simple adaptive strategy: reduce delay if we have been waiting
        waitingRatio := float64(tb.waiting) / (float64(tb.allowed + tb.rejected) + 1)

        // Reduce delay if too many requests are waiting
        if waitingRatio &gt; 0.5 </span><span class="cov0" title="0">{
                return time.Duration(float64(baseDelay) * 0.5)
        }</span>

        <span class="cov1" title="1">return baseDelay</span>
}

// Errors
var (
        ErrRateLimited = fmt.Errorf("rate limit exceeded")
)

// Convenience functions for common rate limiting patterns

// CloudflareRateLimiterConfig returns a configuration optimized for Cloudflare API
func CloudflareRateLimiterConfig() RateLimiterConfig <span class="cov1" title="1">{
        return RateLimiterConfig{
                Name:              "cloudflare-api",
                Type:              TokenBucket,
                RequestsPerSecond: 1200.0 / 300.0, // 1200 requests per 5 minutes = 4 RPS
                BurstSize:         10,
                BackoffStrategy:   Block,
        }
}</span>

// DefaultRateLimiterConfig returns a default rate limiter configuration
func DefaultRateLimiterConfig() RateLimiterConfig <span class="cov1" title="2">{
        return RateLimiterConfig{
                Name:              "default",
                Type:              TokenBucket,
                RequestsPerSecond: 10.0,
                BurstSize:         10,
                BackoffStrategy:   Block,
        }
}</span>

// AggressiveRateLimiterConfig returns a configuration for high-throughput scenarios
func AggressiveRateLimiterConfig() RateLimiterConfig <span class="cov1" title="1">{
        return RateLimiterConfig{
                Name:              "aggressive",
                Type:              TokenBucket,
                RequestsPerSecond: 100.0,
                BurstSize:         50,
                BackoffStrategy:   Reject,
        }
}</span>

// ConservativeRateLimiterConfig returns a conservative rate limiter configuration
func ConservativeRateLimiterConfig() RateLimiterConfig <span class="cov1" title="1">{
        return RateLimiterConfig{
                Name:              "conservative",
                Type:              TokenBucket,
                RequestsPerSecond: 1.0,
                BurstSize:         5,
                BackoffStrategy:   Block,
        }
}</span>

// Helper function
func min(a, b float64) float64 <span class="cov10" title="5970">{
        if a &lt; b </span><span class="cov9" title="5948">{
                return a
        }</span>
        <span class="cov4" title="22">return b</span>
}

// Placeholder implementations for other rate limiter types
// These would be implemented similarly to TokenBucketLimiter

type SlidingWindowLimiter struct {
        config RateLimiterConfig
        logger *zap.Logger
        // Implementation would go here
}

func newSlidingWindowLimiter(config RateLimiterConfig, logger *zap.Logger, registerer prometheus.Registerer) RateLimiter <span class="cov1" title="1">{
        // For now, fall back to token bucket
        logger.Warn("Sliding window limiter not yet implemented, using token bucket")
        config.Type = TokenBucket
        return newTokenBucketLimiter(config, logger, registerer)
}</span>

type FixedWindowLimiter struct {
        config RateLimiterConfig
        logger *zap.Logger
        // Implementation would go here
}

func newFixedWindowLimiter(config RateLimiterConfig, logger *zap.Logger, registerer prometheus.Registerer) RateLimiter <span class="cov1" title="1">{
        // For now, fall back to token bucket
        logger.Warn("Fixed window limiter not yet implemented, using token bucket")
        config.Type = TokenBucket
        return newTokenBucketLimiter(config, logger, registerer)
}</pre>

		<pre class="file" id="file17" style="display: none">package reliability

import (
        "context"
        "time"

        "go.uber.org/zap"
)

// ReliabilityComponents demonstrates how to use all reliability patterns together
type ReliabilityComponents struct {
        CircuitBreaker CircuitBreaker
        Retryer       *Retryer
        RateLimiter   RateLimiter
        logger        *zap.Logger
}

// NewReliabilityComponents creates a complete reliability setup for Cloudflare API
func NewReliabilityComponents(logger *zap.Logger) *ReliabilityComponents <span class="cov0" title="0">{
        // Circuit breaker for API protection
        circuitBreaker := NewCircuitBreaker(CircuitBreakerConfig{
                Name:        "cloudflare-api",
                MaxRequests: 3,
                Interval:    60 * time.Second,
                Timeout:     30 * time.Second,
                ReadyToTrip: func(counts Counts) bool </span><span class="cov0" title="0">{
                        return counts.Requests &gt;= 5 &amp;&amp; counts.FailureRate() &gt;= 0.6
                }</span>,
        }, logger)

        // Retry logic with exponential backoff
        <span class="cov0" title="0">retryer := NewRetryer(CloudflareRetryConfig(), logger)

        // Rate limiter for Cloudflare API limits
        rateLimiter := NewRateLimiter(CloudflareRateLimiterConfig(), logger)

        return &amp;ReliabilityComponents{
                CircuitBreaker: *circuitBreaker,
                Retryer:       retryer,
                RateLimiter:   rateLimiter,
                logger:        logger,
        }</span>
}

// ExecuteWithReliability executes a function with all reliability patterns applied
func (rc *ReliabilityComponents) ExecuteWithReliability(ctx context.Context, operation string, fn func(context.Context) error) error <span class="cov0" title="0">{
        return rc.Retryer.Retry(ctx, operation, func(ctx context.Context) error </span><span class="cov0" title="0">{
                // First check rate limit
                if err := rc.RateLimiter.Wait(ctx); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Then execute through circuit breaker
                <span class="cov0" title="0">return (&amp;rc.CircuitBreaker).Execute(ctx, fn)</span>
        })
}

// Example usage:
//
// func main() {
//     logger := zap.NewProduction()
//     components := NewReliabilityComponents(logger)
//
//     err := components.ExecuteWithReliability(context.Background(), "cloudflare_dns_update", func(ctx context.Context) error {
//         // Your Cloudflare API call here
//         return cloudflareClient.UpdateDNSRecord(ctx, record)
//     })
//
//     if err != nil {
//         logger.Error("Failed to update DNS record", zap.Error(err))
//     }
// }</pre>

		<pre class="file" id="file18" style="display: none">package reliability

import (
        "context"
        "errors"
        "fmt"
        "math"
        "math/rand"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// RetryConfig holds configuration for the retry mechanism
type RetryConfig struct {
        // MaxRetries is the maximum number of retry attempts (0 means no retries)
        MaxRetries int

        // InitialDelay is the initial delay before the first retry
        InitialDelay time.Duration

        // MaxDelay is the maximum delay between retries
        MaxDelay time.Duration

        // Multiplier is the exponential backoff multiplier
        Multiplier float64

        // Jitter adds randomness to delays to avoid thundering herd
        Jitter bool

        // RetryableChecker determines if an error is retryable
        RetryableChecker func(error) bool

        // OnRetry is called before each retry attempt
        OnRetry func(attempt int, delay time.Duration, err error)
}

// RetryableFunc is the function type that can be retried
type RetryableFunc func(context.Context) error

// Retryer implements exponential backoff retry logic
type Retryer struct {
        config  RetryConfig
        logger  *zap.Logger

        // Prometheus metrics
        attemptsTotal    *prometheus.CounterVec
        successesTotal   *prometheus.CounterVec
        failuresTotal    *prometheus.CounterVec
        delayHistogram   *prometheus.HistogramVec
        retryDuration    *prometheus.HistogramVec
}

// NewRetryer creates a new retryer with the given configuration
func NewRetryer(config RetryConfig, logger *zap.Logger) *Retryer <span class="cov1" title="1">{
        return NewRetryerWithRegistry(config, logger, prometheus.DefaultRegisterer)
}</span>

// NewRetryerWithRegistry creates a new retryer with a custom metrics registry
func NewRetryerWithRegistry(config RetryConfig, logger *zap.Logger, registerer prometheus.Registerer) *Retryer <span class="cov4" title="22">{
        // Set default configuration values
        if config.MaxRetries &lt; 0 </span><span class="cov1" title="1">{
                config.MaxRetries = 0
        }</span>
        <span class="cov4" title="22">if config.InitialDelay == 0 </span><span class="cov1" title="1">{
                config.InitialDelay = 100 * time.Millisecond
        }</span>
        <span class="cov4" title="22">if config.MaxDelay == 0 </span><span class="cov3" title="6">{
                config.MaxDelay = 30 * time.Second
        }</span>
        <span class="cov4" title="22">if config.Multiplier == 0 </span><span class="cov3" title="6">{
                config.Multiplier = 2.0
        }</span>
        <span class="cov4" title="22">if config.RetryableChecker == nil </span><span class="cov4" title="20">{
                config.RetryableChecker = defaultRetryableChecker
        }</span>

        <span class="cov4" title="22">r := &amp;Retryer{
                config: config,
                logger: logger,

                attemptsTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "retry_attempts_total",
                                Help: "Total number of retry attempts",
                        },
                        []string{"operation", "attempt"},
                ),

                successesTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "retry_successes_total",
                                Help: "Total number of successful operations after retries",
                        },
                        []string{"operation", "final_attempt"},
                ),

                failuresTotal: prometheus.NewCounterVec(
                        prometheus.CounterOpts{
                                Name: "retry_failures_total",
                                Help: "Total number of failed operations after all retries",
                        },
                        []string{"operation"},
                ),

                delayHistogram: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "retry_delay_seconds",
                                Help:    "Histogram of retry delays in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.001, 2, 15), // 1ms to ~32s
                        },
                        []string{"operation", "attempt"},
                ),

                retryDuration: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "retry_duration_seconds",
                                Help:    "Total duration of retry operations including all attempts",
                                Buckets: prometheus.ExponentialBuckets(0.01, 2, 15), // 10ms to ~5min
                        },
                        []string{"operation", "result"},
                ),
        }

        // Register metrics if registerer provided
        if registerer != nil </span><span class="cov4" title="17">{
                registerer.MustRegister(
                        r.attemptsTotal,
                        r.successesTotal,
                        r.failuresTotal,
                        r.delayHistogram,
                        r.retryDuration,
                )
        }</span>

        <span class="cov4" title="22">return r</span>
}

// Retry executes the given function with exponential backoff retry logic
func (r *Retryer) Retry(ctx context.Context, operation string, fn RetryableFunc) error <span class="cov6" title="65">{
        startTime := time.Now()

        var lastErr error
        for attempt := 0; attempt &lt;= r.config.MaxRetries; attempt++ </span><span class="cov6" title="132">{
                // Record attempt
                r.attemptsTotal.WithLabelValues(operation, fmt.Sprintf("%d", attempt)).Inc()

                // Execute the function
                err := fn(ctx)
                if err == nil </span><span class="cov5" title="57">{
                        // Success
                        r.successesTotal.WithLabelValues(operation, fmt.Sprintf("%d", attempt)).Inc()
                        r.retryDuration.WithLabelValues(operation, "success").Observe(time.Since(startTime).Seconds())

                        if attempt &gt; 0 </span><span class="cov5" title="56">{
                                r.logger.Info("Operation succeeded after retries",
                                        zap.String("operation", operation),
                                        zap.Int("attempts", attempt+1),
                                        zap.Duration("total_duration", time.Since(startTime)),
                                )
                        }</span>

                        <span class="cov5" title="57">return nil</span>
                }

                <span class="cov6" title="75">lastErr = err

                // Check if error is retryable
                if !r.config.RetryableChecker(err) </span><span class="cov1" title="2">{
                        r.logger.Info("Error is not retryable, giving up",
                                zap.String("operation", operation),
                                zap.Error(err),
                                zap.Int("attempt", attempt),
                        )
                        break</span>
                }

                // Check if we have more retries left
                <span class="cov6" title="73">if attempt &gt;= r.config.MaxRetries </span><span class="cov2" title="4">{
                        break</span>
                }

                // Check context cancellation
                <span class="cov6" title="69">if ctx.Err() != nil </span><span class="cov1" title="1">{
                        r.logger.Info("Context cancelled, giving up retries",
                                zap.String("operation", operation),
                                zap.Error(ctx.Err()),
                                zap.Int("attempt", attempt),
                        )
                        return ctx.Err()
                }</span>

                // Calculate delay for next attempt
                <span class="cov6" title="68">delay := r.calculateDelay(attempt + 1)
                r.delayHistogram.WithLabelValues(operation, fmt.Sprintf("%d", attempt+1)).Observe(delay.Seconds())

                // Call retry callback if configured
                if r.config.OnRetry != nil </span><span class="cov2" title="5">{
                        r.config.OnRetry(attempt+1, delay, err)
                }</span>

                <span class="cov6" title="68">r.logger.Debug("Retrying operation after delay",
                        zap.String("operation", operation),
                        zap.Int("attempt", attempt+1),
                        zap.Duration("delay", delay),
                        zap.Error(err),
                )

                // Wait before retry
                select </span>{
                case &lt;-ctx.Done():<span class="cov1" title="1">
                        return ctx.Err()</span>
                case &lt;-time.After(delay):<span class="cov6" title="67"></span>
                        // Continue to next attempt
                }
        }

        // All retries exhausted
        <span class="cov3" title="6">r.failuresTotal.WithLabelValues(operation).Inc()
        r.retryDuration.WithLabelValues(operation, "failure").Observe(time.Since(startTime).Seconds())

        r.logger.Error("All retry attempts exhausted",
                zap.String("operation", operation),
                zap.Int("attempts", r.config.MaxRetries+1),
                zap.Duration("total_duration", time.Since(startTime)),
                zap.Error(lastErr),
        )

        return fmt.Errorf("operation failed after %d attempts: %w", r.config.MaxRetries+1, lastErr)</span>
}

// RetryWithBackoff is a convenience method for simple retry with exponential backoff
func (r *Retryer) RetryWithBackoff(ctx context.Context, fn RetryableFunc) error <span class="cov1" title="2">{
        return r.Retry(ctx, "operation", fn)
}</span>

// calculateDelay calculates the delay for the given attempt using exponential backoff
func (r *Retryer) calculateDelay(attempt int) time.Duration <span class="cov7" title="184">{
        // Calculate exponential delay
        delay := float64(r.config.InitialDelay) * math.Pow(r.config.Multiplier, float64(attempt-1))

        // Apply maximum delay limit
        if delay &gt; float64(r.config.MaxDelay) </span><span class="cov1" title="2">{
                delay = float64(r.config.MaxDelay)
        }</span>

        // Add jitter if enabled
        <span class="cov7" title="184">if r.config.Jitter </span><span class="cov6" title="116">{
                // Add 25% jitter
                jitterRange := delay * 0.25
                jitter := (rand.Float64() * 2 - 1) * jitterRange
                delay += jitter

                // Ensure delay doesn't go negative or exceed max
                if delay &lt; 0 </span><span class="cov0" title="0">{
                        delay = float64(r.config.InitialDelay)
                }</span>
                <span class="cov6" title="116">if delay &gt; float64(r.config.MaxDelay) </span><span class="cov0" title="0">{
                        delay = float64(r.config.MaxDelay)
                }</span>
        }

        <span class="cov7" title="184">return time.Duration(delay)</span>
}

// Config returns a copy of the current configuration
func (r *Retryer) Config() RetryConfig <span class="cov1" title="1">{
        return r.config
}</span>

// SetRetryableChecker sets a custom retryable error checker
func (r *Retryer) SetRetryableChecker(checker func(error) bool) <span class="cov1" title="1">{
        r.config.RetryableChecker = checker
}</span>

// SetOnRetry sets a callback to be called before each retry
func (r *Retryer) SetOnRetry(callback func(attempt int, delay time.Duration, err error)) <span class="cov1" title="1">{
        r.config.OnRetry = callback
}</span>

// Predefined retry configurations for common use cases

// DefaultRetryConfig returns a default retry configuration
func DefaultRetryConfig() RetryConfig <span class="cov3" title="6">{
        return RetryConfig{
                MaxRetries:   3,
                InitialDelay: 100 * time.Millisecond,
                MaxDelay:     30 * time.Second,
                Multiplier:   2.0,
                Jitter:       true,
        }
}</span>

// AggressiveRetryConfig returns a configuration for aggressive retrying
func AggressiveRetryConfig() RetryConfig <span class="cov1" title="1">{
        return RetryConfig{
                MaxRetries:   5,
                InitialDelay: 50 * time.Millisecond,
                MaxDelay:     10 * time.Second,
                Multiplier:   1.5,
                Jitter:       true,
        }
}</span>

// ConservativeRetryConfig returns a configuration for conservative retrying
func ConservativeRetryConfig() RetryConfig <span class="cov1" title="1">{
        return RetryConfig{
                MaxRetries:   2,
                InitialDelay: 500 * time.Millisecond,
                MaxDelay:     60 * time.Second,
                Multiplier:   3.0,
                Jitter:       true,
        }
}</span>

// CloudflareRetryConfig returns a configuration optimized for Cloudflare API
func CloudflareRetryConfig() RetryConfig <span class="cov1" title="2">{
        return RetryConfig{
                MaxRetries:       3,
                InitialDelay:     200 * time.Millisecond,
                MaxDelay:         30 * time.Second,
                Multiplier:       2.0,
                Jitter:           true,
                RetryableChecker: cloudflareRetryable,
        }
}</span>

// Default retryable error checker
func defaultRetryableChecker(err error) bool <span class="cov6" title="77">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Context errors are not retryable
        <span class="cov6" title="76">if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov1" title="2">{
                return false
        }</span>

        // By default, all other errors are considered retryable
        <span class="cov6" title="74">return true</span>
}

// Cloudflare-specific retryable error checker
func cloudflareRetryable(err error) bool <span class="cov4" title="18">{
        if err == nil </span><span class="cov1" title="1">{
                return false
        }</span>

        // Context errors are not retryable
        <span class="cov4" title="17">if errors.Is(err, context.Canceled) || errors.Is(err, context.DeadlineExceeded) </span><span class="cov1" title="2">{
                return false
        }</span>

        <span class="cov4" title="15">errStr := err.Error()

        // Network errors are usually retryable
        if contains(errStr, "connection refused") ||
                contains(errStr, "timeout") ||
                contains(errStr, "temporary failure") ||
                contains(errStr, "network is unreachable") </span><span class="cov2" title="3">{
                return true
        }</span>

        // HTTP 5xx errors are retryable
        <span class="cov3" title="12">if contains(errStr, "500") || contains(errStr, "502") ||
                contains(errStr, "503") || contains(errStr, "504") </span><span class="cov2" title="4">{
                return true
        }</span>

        // Cloudflare rate limiting (429) is retryable
        <span class="cov3" title="8">if contains(errStr, "429") || contains(errStr, "rate limit") </span><span class="cov1" title="2">{
                return true
        }</span>

        // Authentication errors (401, 403) are not retryable
        <span class="cov3" title="6">if contains(errStr, "401") || contains(errStr, "403") ||
                contains(errStr, "unauthorized") || contains(errStr, "forbidden") </span><span class="cov1" title="2">{
                return false
        }</span>

        // Client errors (4xx except 429) are generally not retryable
        <span class="cov2" title="4">if contains(errStr, "400") || contains(errStr, "404") || contains(errStr, "422") </span><span class="cov2" title="3">{
                return false
        }</span>

        // Default to retryable for unknown errors
        <span class="cov1" title="1">return true</span>
}

// Helper function to check if a string contains a substring (case-insensitive)
func contains(s, substr string) bool <span class="cov6" title="143">{
        return len(s) &gt;= len(substr) &amp;&amp;
                (s == substr || len(s) &gt; len(substr) &amp;&amp;
                (s[:len(substr)] == substr || s[len(s)-len(substr):] == substr ||
                indexInString(s, substr) != -1))
}</span>

// Simple string search
func indexInString(s, substr string) int <span class="cov6" title="130">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov10" title="1799">{
                if s[i:i+len(substr)] == substr </span><span class="cov4" title="15">{
                        return i
                }</span>
        }
        <span class="cov6" title="115">return -1</span>
}

// Convenience functions for common retry patterns

// RetryOnError retries a function with default configuration
func RetryOnError(ctx context.Context, fn RetryableFunc) error <span class="cov1" title="1">{
        retryer := NewRetryerWithRegistry(DefaultRetryConfig(), zap.NewNop(), nil)
        return retryer.RetryWithBackoff(ctx, fn)
}</span>

// RetryCloudflareOperation retries a Cloudflare API operation
func RetryCloudflareOperation(ctx context.Context, logger *zap.Logger, operation string, fn RetryableFunc) error <span class="cov1" title="1">{
        retryer := NewRetryerWithRegistry(CloudflareRetryConfig(), logger, nil)
        return retryer.Retry(ctx, operation, fn)
}</span>

// RetryWithConfig retries a function with custom configuration
func RetryWithConfig(ctx context.Context, config RetryConfig, logger *zap.Logger, operation string, fn RetryableFunc) error <span class="cov1" title="1">{
        retryer := NewRetryerWithRegistry(config, logger, nil)
        return retryer.Retry(ctx, operation, fn)
}</pre>

		<pre class="file" id="file19" style="display: none">package slo

import (
        "context"
        "fmt"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        dto "github.com/prometheus/client_model/go"
)

// Calculator calculates SLI values from metrics
type Calculator struct {
        config *Config

        // Metrics for SLI calculation
        availabilityRatio   *prometheus.GaugeVec
        successRateRatio    *prometheus.GaugeVec
        latencyHistogram    *prometheus.HistogramVec
        throughputGauge     *prometheus.GaugeVec
        errorBudgetGauge    *prometheus.GaugeVec
}

// NewCalculator creates a new SLI calculator
func NewCalculator(config *Config) *Calculator <span class="cov0" title="0">{
        return NewCalculatorWithRegistry(config, prometheus.DefaultRegisterer)
}</span>

// NewCalculatorWithRegistry creates a new SLI calculator with a custom registry
func NewCalculatorWithRegistry(config *Config, registerer prometheus.Registerer) *Calculator <span class="cov4" title="27">{
        calc := &amp;Calculator{
                config: config,

                availabilityRatio: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "sli_availability_ratio",
                                Help: "Availability SLI as a ratio (0.0-1.0)",
                        },
                        []string{"window"},
                ),

                successRateRatio: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "sli_success_rate_ratio",
                                Help: "Success rate SLI as a ratio (0.0-1.0)",
                        },
                        []string{"window", "controller", "namespace"},
                ),

                latencyHistogram: prometheus.NewHistogramVec(
                        prometheus.HistogramOpts{
                                Name:    "sli_latency_seconds",
                                Help:    "Latency SLI in seconds",
                                Buckets: prometheus.ExponentialBuckets(0.001, 2, 20), // 1ms to ~17min
                        },
                        []string{"window", "controller", "namespace", "operation"},
                ),

                throughputGauge: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "sli_throughput_operations_per_minute",
                                Help: "Throughput SLI in operations per minute",
                        },
                        []string{"window", "controller", "namespace"},
                ),

                errorBudgetGauge: prometheus.NewGaugeVec(
                        prometheus.GaugeOpts{
                                Name: "sli_error_budget_remaining_ratio",
                                Help: "Remaining error budget as a ratio (0.0-1.0)",
                        },
                        []string{"slo_name", "window"},
                ),
        }

        // Register metrics if registerer is provided
        if registerer != nil </span><span class="cov4" title="26">{
                registerer.MustRegister(
                        calc.availabilityRatio,
                        calc.successRateRatio,
                        calc.latencyHistogram,
                        calc.throughputGauge,
                        calc.errorBudgetGauge,
                )
        }</span>

        <span class="cov4" title="27">return calc</span>
}

// SLIValues holds calculated SLI values
type SLIValues struct {
        Availability   float64
        SuccessRate    float64
        LatencyP95     time.Duration
        LatencyP99     time.Duration
        Throughput     float64
        Timestamp      time.Time
        Window         string
}

// Calculate calculates all SLI values for a given time window
func (c *Calculator) Calculate(ctx context.Context, window TimeWindow) (*SLIValues, error) <span class="cov8" title="641">{
        values := &amp;SLIValues{
                Window:    window.Name,
                Timestamp: time.Now(),
        }

        // Calculate availability from up metric
        availability, err := c.calculateAvailability(ctx, window)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calculating availability: %w", err)
        }</span>
        <span class="cov8" title="641">values.Availability = availability
        c.availabilityRatio.WithLabelValues(window.Name).Set(availability)

        // Calculate success rate from reconcile metrics
        successRate, err := c.calculateSuccessRate(ctx, window)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calculating success rate: %w", err)
        }</span>
        <span class="cov8" title="641">values.SuccessRate = successRate
        c.successRateRatio.WithLabelValues(window.Name, "cloudflarerecord", "all").Set(successRate)

        // Calculate latency percentiles
        p95, p99, err := c.calculateLatencyPercentiles(ctx, window)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calculating latency percentiles: %w", err)
        }</span>
        <span class="cov8" title="641">values.LatencyP95 = p95
        values.LatencyP99 = p99

        // Record latency observations
        c.latencyHistogram.WithLabelValues(window.Name, "cloudflarerecord", "all", "reconcile").Observe(p95.Seconds())

        // Calculate throughput
        throughput, err := c.calculateThroughput(ctx, window)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("calculating throughput: %w", err)
        }</span>
        <span class="cov8" title="641">values.Throughput = throughput
        c.throughputGauge.WithLabelValues(window.Name, "cloudflarerecord", "all").Set(throughput)

        // Calculate error budgets for each SLO
        c.calculateErrorBudgets(values)

        return values, nil</span>
}

// calculateAvailability calculates the availability SLI
func (c *Calculator) calculateAvailability(ctx context.Context, window TimeWindow) (float64, error) <span class="cov8" title="642">{
        // This would typically query Prometheus or use the up metric
        // For now, return a placeholder calculation
        // In real implementation, this would use prometheus.Query API
        return 0.999, nil
}</span>

// calculateSuccessRate calculates the success rate SLI
func (c *Calculator) calculateSuccessRate(ctx context.Context, window TimeWindow) (float64, error) <span class="cov8" title="642">{
        // This would query controller_runtime_reconcile_total metrics
        // For now, return a placeholder calculation
        return 0.995, nil
}</span>

// calculateLatencyPercentiles calculates P95 and P99 latency
func (c *Calculator) calculateLatencyPercentiles(ctx context.Context, window TimeWindow) (time.Duration, time.Duration, error) <span class="cov8" title="642">{
        // This would query controller_runtime_reconcile_time_seconds histogram
        // For now, return placeholder values
        return 25 * time.Second, 45 * time.Second, nil
}</span>

// calculateThroughput calculates operations per minute
func (c *Calculator) calculateThroughput(ctx context.Context, window TimeWindow) (float64, error) <span class="cov8" title="642">{
        // This would query the rate of reconcile operations
        // For now, return a placeholder calculation
        return 15.0, nil
}</span>

// calculateErrorBudgets updates error budget gauges based on SLI values
func (c *Calculator) calculateErrorBudgets(values *SLIValues) <span class="cov8" title="642">{
        // Calculate error budget for availability
        availabilityBudget := c.calculateSingleErrorBudget(
                values.Availability,
                c.config.Targets.Availability/100,
                "availability",
                values.Window,
        )

        // Calculate error budget for success rate
        successRateBudget := c.calculateSingleErrorBudget(
                values.SuccessRate,
                c.config.Targets.SuccessRate/100,
                "success_rate",
                values.Window,
        )

        // Calculate error budget for latency (using P95)
        latencyConformance := 1.0
        if values.LatencyP95 &gt; c.config.Targets.LatencyP95 </span><span class="cov0" title="0">{
                // Simple binary conformance for latency
                latencyConformance = 0.95 // Assume 95% of requests meet latency target
        }</span>
        <span class="cov8" title="642">latencyBudget := c.calculateSingleErrorBudget(
                latencyConformance,
                0.95, // 95% of requests should meet latency target
                "latency_p95",
                values.Window,
        )

        // Update error budget gauges
        c.errorBudgetGauge.WithLabelValues("availability", values.Window).Set(availabilityBudget)
        c.errorBudgetGauge.WithLabelValues("success_rate", values.Window).Set(successRateBudget)
        c.errorBudgetGauge.WithLabelValues("latency_p95", values.Window).Set(latencyBudget)</span>
}

// calculateSingleErrorBudget calculates remaining error budget for a single SLO
func (c *Calculator) calculateSingleErrorBudget(actual, target float64, sloName, window string) float64 <span class="cov10" title="1932">{
        if target &gt;= 1.0 </span><span class="cov1" title="1">{
                return 1.0 // No error budget if target is 100%
        }</span>

        // If actual &gt;= target, budget is 100% remaining
        <span class="cov9" title="1931">if actual &gt;= target </span><span class="cov9" title="1287">{
                return 1.0
        }</span>

        // Error budget calculation:
        // Total error budget = 1 - target
        // Error budget consumed = target - actual
        // Error budget remaining = (total - consumed) / total
        <span class="cov8" title="644">errorBudgetTotal := 1.0 - target
        errorBudgetConsumed := target - actual

        if errorBudgetTotal &lt;= 0 </span><span class="cov0" title="0">{
                return 1.0 // Edge case: no error budget exists
        }</span>

        <span class="cov8" title="644">errorBudgetRemaining := (errorBudgetTotal - errorBudgetConsumed) / errorBudgetTotal

        // Clamp between 0 and 1
        if errorBudgetRemaining &lt; 0 </span><span class="cov1" title="1">{
                return 0.0
        }</span>
        <span class="cov8" title="643">if errorBudgetRemaining &gt; 1 </span><span class="cov0" title="0">{
                return 1.0
        }</span>

        <span class="cov8" title="643">return errorBudgetRemaining</span>
}

// GetMetricValue is a helper to get current metric value
func (c *Calculator) GetMetricValue(vec *prometheus.GaugeVec, labels ...string) (float64, error) <span class="cov1" title="2">{
        metric, err := vec.GetMetricWithLabelValues(labels...)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("getting metric with labels: %w", err)
        }</span>

        <span class="cov1" title="2">pb := &amp;dto.Metric{}
        if err := metric.Write(pb); err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("writing metric: %w", err)
        }</span>

        <span class="cov1" title="2">if pb.Gauge == nil || pb.Gauge.Value == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("metric has no gauge value")
        }</span>

        <span class="cov1" title="2">return *pb.Gauge.Value, nil</span>
}

// CalculateMultiWindowBurnRate calculates burn rate across multiple windows
func (c *Calculator) CalculateMultiWindowBurnRate(ctx context.Context, shortWindow, longWindow TimeWindow) (float64, error) <span class="cov3" title="7">{
        // Calculate error budget consumption rate
        // This is simplified - real implementation would query Prometheus
        shortValues, err := c.Calculate(ctx, shortWindow)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("calculating short window SLI: %w", err)
        }</span>

        <span class="cov3" title="7">longValues, err := c.Calculate(ctx, longWindow)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("calculating long window SLI: %w", err)
        }</span>

        // Calculate burn rate based on error budget consumption
        // This is a simplified calculation
        <span class="cov3" title="7">shortBurnRate := (1.0 - shortValues.SuccessRate) / (1.0 - c.config.Targets.SuccessRate/100)
        longBurnRate := (1.0 - longValues.SuccessRate) / (1.0 - c.config.Targets.SuccessRate/100)

        // Return the average burn rate
        return (shortBurnRate + longBurnRate) / 2, nil</span>
}</pre>

		<pre class="file" id="file20" style="display: none">package slo

import (
        "time"
)

// Config defines the SLO configuration
type Config struct {
        // Enabled indicates if SLO monitoring is enabled
        Enabled bool `json:"enabled" yaml:"enabled"`

        // Targets defines the SLO targets
        Targets SLOTargets `json:"targets" yaml:"targets"`

        // ErrorBudget defines error budget configuration
        ErrorBudget ErrorBudgetConfig `json:"errorBudget" yaml:"errorBudget"`

        // Windows defines the time windows for SLI calculation
        Windows []TimeWindow `json:"windows" yaml:"windows"`

        // AlertingRules defines the alerting configuration
        AlertingRules AlertingConfig `json:"alertingRules" yaml:"alertingRules"`
}

// SLOTargets defines the target objectives for each SLI
type SLOTargets struct {
        // Availability target percentage (e.g., 99.9)
        Availability float64 `json:"availability" yaml:"availability"`

        // SuccessRate target percentage (e.g., 99.5)
        SuccessRate float64 `json:"successRate" yaml:"successRate"`

        // LatencyP95 target duration for 95th percentile
        LatencyP95 time.Duration `json:"latencyP95" yaml:"latencyP95"`

        // LatencyP99 target duration for 99th percentile
        LatencyP99 time.Duration `json:"latencyP99" yaml:"latencyP99"`

        // ThroughputMin minimum operations per minute
        ThroughputMin float64 `json:"throughputMin" yaml:"throughputMin"`
}

// ErrorBudgetConfig defines error budget configuration
type ErrorBudgetConfig struct {
        // WindowDays defines the rolling window for error budget calculation
        WindowDays int `json:"windowDays" yaml:"windowDays"`

        // AlertThresholds defines when to alert on error budget consumption
        AlertThresholds ErrorBudgetThresholds `json:"alertThresholds" yaml:"alertThresholds"`

        // Policies defines what actions to take at different consumption levels
        Policies []ErrorBudgetPolicy `json:"policies" yaml:"policies"`
}

// ErrorBudgetThresholds defines alert thresholds for error budget
type ErrorBudgetThresholds struct {
        // Warning threshold as a fraction of error budget consumed (0.0-1.0)
        Warning float64 `json:"warning" yaml:"warning"`

        // Critical threshold as a fraction of error budget consumed (0.0-1.0)
        Critical float64 `json:"critical" yaml:"critical"`
}

// ErrorBudgetPolicy defines actions based on error budget consumption
type ErrorBudgetPolicy struct {
        // Threshold is the consumption threshold that triggers this policy
        Threshold float64 `json:"threshold" yaml:"threshold"`

        // Action to take when threshold is exceeded
        Action string `json:"action" yaml:"action"`

        // Description of the policy
        Description string `json:"description" yaml:"description"`
}

// TimeWindow defines a time window for SLI calculation
type TimeWindow struct {
        // Name of the window (e.g., "5m", "30m", "1h")
        Name string `json:"name" yaml:"name"`

        // Duration of the window
        Duration time.Duration `json:"duration" yaml:"duration"`

        // IsShortTerm indicates if this is a short-term window for fast burn alerts
        IsShortTerm bool `json:"isShortTerm" yaml:"isShortTerm"`
}

// AlertingConfig defines multi-window multi-burn-rate alerting
type AlertingConfig struct {
        // PageAlerts for immediate attention (fast burn)
        PageAlerts BurnRateAlert `json:"pageAlerts" yaml:"pageAlerts"`

        // TicketAlerts for slower burns
        TicketAlerts BurnRateAlert `json:"ticketAlerts" yaml:"ticketAlerts"`
}

// BurnRateAlert defines a burn rate alert configuration
type BurnRateAlert struct {
        // Enabled indicates if this alert type is enabled
        Enabled bool `json:"enabled" yaml:"enabled"`

        // ShortWindow for recent burn rate
        ShortWindow time.Duration `json:"shortWindow" yaml:"shortWindow"`

        // LongWindow for sustained burn rate
        LongWindow time.Duration `json:"longWindow" yaml:"longWindow"`

        // BurnRateThreshold multiplier for error budget burn rate
        BurnRateThreshold float64 `json:"burnRateThreshold" yaml:"burnRateThreshold"`

        // Severity of the alert
        Severity string `json:"severity" yaml:"severity"`
}

// DefaultConfig returns a default SLO configuration
func DefaultConfig() *Config <span class="cov6" title="51">{
        return &amp;Config{
                Enabled: true,
                Targets: SLOTargets{
                        Availability: 99.9,
                        SuccessRate:  99.5,
                        LatencyP95:   30 * time.Second,
                        LatencyP99:   60 * time.Second,
                        ThroughputMin: 10.0,
                },
                ErrorBudget: ErrorBudgetConfig{
                        WindowDays: 30,
                        AlertThresholds: ErrorBudgetThresholds{
                                Warning:  0.5,
                                Critical: 0.9,
                        },
                        Policies: []ErrorBudgetPolicy{
                                {
                                        Threshold:   0.5,
                                        Action:      "notify",
                                        Description: "Notify team when 50% of error budget is consumed",
                                },
                                {
                                        Threshold:   0.9,
                                        Action:      "freeze_deployments",
                                        Description: "Freeze non-critical deployments when 90% of error budget is consumed",
                                },
                        },
                },
                Windows: []TimeWindow{
                        {Name: "5m", Duration: 5 * time.Minute, IsShortTerm: true},
                        {Name: "30m", Duration: 30 * time.Minute, IsShortTerm: true},
                        {Name: "1h", Duration: 1 * time.Hour, IsShortTerm: false},
                        {Name: "6h", Duration: 6 * time.Hour, IsShortTerm: false},
                        {Name: "1d", Duration: 24 * time.Hour, IsShortTerm: false},
                        {Name: "30d", Duration: 30 * 24 * time.Hour, IsShortTerm: false},
                },
                AlertingRules: AlertingConfig{
                        PageAlerts: BurnRateAlert{
                                Enabled:           true,
                                ShortWindow:       5 * time.Minute,
                                LongWindow:        1 * time.Hour,
                                BurnRateThreshold: 14.4, // Consumes monthly budget in ~6 hours
                                Severity:          "critical",
                        },
                        TicketAlerts: BurnRateAlert{
                                Enabled:           true,
                                ShortWindow:       30 * time.Minute,
                                LongWindow:        6 * time.Hour,
                                BurnRateThreshold: 6.0, // Consumes monthly budget in ~3 days
                                Severity:          "warning",
                        },
                },
        }
}</span>

// Validate validates the SLO configuration
func (c *Config) Validate() error <span class="cov10" title="1024">{
        // TODO: Implement validation
        return nil
}</pre>

		<pre class="file" id="file21" style="display: none">package slo

import (
        "fmt"
        "sync"
        "time"
)

// ErrorBudgetManager manages error budget calculations and policies
type ErrorBudgetManager struct {
        config *ErrorBudgetConfig

        // Historical data for trend analysis
        history map[string][]ErrorBudgetSnapshot

        // Mutex to protect concurrent access
        mu sync.RWMutex
}

// ErrorBudgetSnapshot represents a point-in-time error budget state
type ErrorBudgetSnapshot struct {
        Timestamp        time.Time
        Remaining        float64
        ConsumedPercent  float64
        BurnRate         float64
        SLOName          string
        Window           string
}

// NewErrorBudgetManager creates a new error budget manager
func NewErrorBudgetManager(config *ErrorBudgetConfig) *ErrorBudgetManager <span class="cov3" title="12">{
        return &amp;ErrorBudgetManager{
                config:  config,
                history: make(map[string][]ErrorBudgetSnapshot),
        }
}</span>

// CalculateErrorBudget calculates the error budget for an SLO
func (ebm *ErrorBudgetManager) CalculateErrorBudget(sloName string, actual, target float64) *ErrorBudgetCalculation <span class="cov8" title="509">{
        calc := &amp;ErrorBudgetCalculation{
                SLOName:   sloName,
                Actual:    actual,
                Target:    target,
                Timestamp: time.Now(),
        }

        // Calculate total error budget (1 - target)
        calc.TotalBudget = 1.0 - target

        // Calculate consumed budget
        if actual &gt;= target </span><span class="cov8" title="504">{
                calc.ConsumedBudget = 0.0
        }</span> else<span class="cov2" title="5"> {
                calc.ConsumedBudget = target - actual
        }</span>

        // Calculate remaining budget
        <span class="cov8" title="509">calc.RemainingBudget = calc.TotalBudget - calc.ConsumedBudget

        // Calculate percentages
        if calc.TotalBudget &gt; 0 </span><span class="cov8" title="508">{
                calc.RemainingPercent = calc.RemainingBudget / calc.TotalBudget
                calc.ConsumedPercent = calc.ConsumedBudget / calc.TotalBudget
        }</span> else<span class="cov1" title="1"> {
                calc.RemainingPercent = 1.0
                calc.ConsumedPercent = 0.0
        }</span>

        // Ensure percentages are within bounds
        <span class="cov8" title="509">calc.RemainingPercent = clamp(calc.RemainingPercent, 0.0, 1.0)
        calc.ConsumedPercent = clamp(calc.ConsumedPercent, 0.0, 1.0)

        return calc</span>
}

// ErrorBudgetCalculation holds the results of an error budget calculation
type ErrorBudgetCalculation struct {
        SLOName          string
        Actual           float64
        Target           float64
        TotalBudget      float64
        ConsumedBudget   float64
        RemainingBudget  float64
        RemainingPercent float64
        ConsumedPercent  float64
        Timestamp        time.Time
}

// RecordSnapshot records an error budget snapshot for historical tracking
func (ebm *ErrorBudgetManager) RecordSnapshot(snapshot ErrorBudgetSnapshot) <span class="cov10" title="2511">{
        ebm.mu.Lock()
        defer ebm.mu.Unlock()

        key := fmt.Sprintf("%s_%s", snapshot.SLOName, snapshot.Window)

        // Initialize slice if needed
        if _, exists := ebm.history[key]; !exists </span><span class="cov3" title="6">{
                ebm.history[key] = make([]ErrorBudgetSnapshot, 0, 1000)
        }</span>

        // Add snapshot
        <span class="cov10" title="2511">ebm.history[key] = append(ebm.history[key], snapshot)

        // Trim old snapshots (keep last 1000)
        if len(ebm.history[key]) &gt; 1000 </span><span class="cov8" title="500">{
                ebm.history[key] = ebm.history[key][len(ebm.history[key])-1000:]
        }</span>
}

// CalculateBurnRate calculates the error budget burn rate over a time period
func (ebm *ErrorBudgetManager) CalculateBurnRate(sloName, window string, period time.Duration) (float64, error) <span class="cov3" title="6">{
        ebm.mu.RLock()
        defer ebm.mu.RUnlock()

        key := fmt.Sprintf("%s_%s", sloName, window)
        snapshots, exists := ebm.history[key]
        if !exists || len(snapshots) &lt; 2 </span><span class="cov1" title="2">{
                return 0, fmt.Errorf("insufficient historical data for burn rate calculation")
        }</span>

        // Find snapshots at the start and end of the period
        <span class="cov2" title="4">now := time.Now()
        periodStart := now.Add(-period)

        var startSnapshot, endSnapshot *ErrorBudgetSnapshot

        // Find the closest snapshots to our period boundaries
        for i := range snapshots </span><span class="cov4" title="14">{
                if snapshots[i].Timestamp.After(periodStart) &amp;&amp; startSnapshot == nil </span><span class="cov2" title="4">{
                        if i &gt; 0 </span><span class="cov2" title="3">{
                                startSnapshot = &amp;snapshots[i-1]
                        }</span> else<span class="cov1" title="1"> {
                                startSnapshot = &amp;snapshots[i]
                        }</span>
                }
                <span class="cov4" title="14">endSnapshot = &amp;snapshots[i]</span>
        }

        <span class="cov2" title="4">if startSnapshot == nil || endSnapshot == nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("could not find snapshots for period")
        }</span>

        // Calculate burn rate
        <span class="cov2" title="4">timeDiff := endSnapshot.Timestamp.Sub(startSnapshot.Timestamp)
        if timeDiff &lt;= 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid time difference for burn rate calculation")
        }</span>

        <span class="cov2" title="4">budgetConsumed := startSnapshot.ConsumedPercent - endSnapshot.ConsumedPercent
        if budgetConsumed &lt; 0 </span><span class="cov2" title="4">{
                budgetConsumed = -budgetConsumed // Absolute value
        }</span>

        // Burn rate = budget consumed per hour
        <span class="cov2" title="4">hoursElapsed := timeDiff.Hours()
        if hoursElapsed &gt; 0 </span><span class="cov2" title="4">{
                return budgetConsumed / hoursElapsed, nil
        }</span>

        <span class="cov0" title="0">return 0, nil</span>
}

// PredictExhaustion predicts when the error budget will be exhausted
func (ebm *ErrorBudgetManager) PredictExhaustion(sloName, window string) (time.Time, error) <span class="cov2" title="3">{
        // Get current burn rate
        burnRate, err := ebm.CalculateBurnRate(sloName, window, 1*time.Hour)
        if err != nil </span><span class="cov1" title="1">{
                return time.Time{}, fmt.Errorf("calculating burn rate: %w", err)
        }</span>

        <span class="cov1" title="2">if burnRate &lt;= 0 </span><span class="cov0" title="0">{
                return time.Time{}, fmt.Errorf("burn rate is zero or negative")
        }</span>

        // Get latest snapshot
        <span class="cov1" title="2">ebm.mu.RLock()
        key := fmt.Sprintf("%s_%s", sloName, window)
        snapshots, exists := ebm.history[key]
        if !exists || len(snapshots) == 0 </span><span class="cov0" title="0">{
                ebm.mu.RUnlock()
                return time.Time{}, fmt.Errorf("no historical data available")
        }</span>
        <span class="cov1" title="2">latestSnapshot := snapshots[len(snapshots)-1]
        ebm.mu.RUnlock()

        remainingBudget := 1.0 - latestSnapshot.ConsumedPercent

        if remainingBudget &lt;= 0 </span><span class="cov0" title="0">{
                return latestSnapshot.Timestamp, nil // Already exhausted
        }</span>

        // Calculate hours until exhaustion
        <span class="cov1" title="2">hoursUntilExhaustion := remainingBudget / burnRate

        return time.Now().Add(time.Duration(hoursUntilExhaustion) * time.Hour), nil</span>
}

// CheckAlertThresholds checks if any alert thresholds have been exceeded
func (ebm *ErrorBudgetManager) CheckAlertThresholds(calc *ErrorBudgetCalculation) []AlertThreshold <span class="cov2" title="5">{
        var triggered []AlertThreshold

        // Check warning threshold
        if calc.ConsumedPercent &gt;= ebm.config.AlertThresholds.Warning </span><span class="cov2" title="4">{
                triggered = append(triggered, AlertThreshold{
                        Name:      "warning",
                        Threshold: ebm.config.AlertThresholds.Warning,
                        Severity:  "warning",
                        Message:   fmt.Sprintf("Error budget warning: %.1f%% consumed", calc.ConsumedPercent*100),
                })
        }</span>

        // Check critical threshold
        <span class="cov2" title="5">if calc.ConsumedPercent &gt;= ebm.config.AlertThresholds.Critical </span><span class="cov1" title="2">{
                triggered = append(triggered, AlertThreshold{
                        Name:      "critical",
                        Threshold: ebm.config.AlertThresholds.Critical,
                        Severity:  "critical",
                        Message:   fmt.Sprintf("Error budget critical: %.1f%% consumed", calc.ConsumedPercent*100),
                })
        }</span>

        <span class="cov2" title="5">return triggered</span>
}

// AlertThreshold represents a triggered alert threshold
type AlertThreshold struct {
        Name      string
        Threshold float64
        Severity  string
        Message   string
}

// GetRecommendedAction returns the recommended action based on error budget consumption
func (ebm *ErrorBudgetManager) GetRecommendedAction(consumedPercent float64) string <span class="cov8" title="506">{
        // Sort policies by threshold in descending order to find the highest applicable threshold
        var applicableAction string
        var highestThreshold float64 = -1

        for _, policy := range ebm.config.Policies </span><span class="cov4" title="16">{
                if consumedPercent &gt;= policy.Threshold &amp;&amp; policy.Threshold &gt; highestThreshold </span><span class="cov3" title="8">{
                        applicableAction = policy.Action
                        highestThreshold = policy.Threshold
                }</span>
        }

        <span class="cov8" title="506">if applicableAction != "" </span><span class="cov2" title="5">{
                return applicableAction
        }</span>
        <span class="cov8" title="501">return "continue_normal_operations"</span>
}

// GenerateReport generates an error budget report
func (ebm *ErrorBudgetManager) GenerateReport(sloName, window string) (*ErrorBudgetReport, error) <span class="cov1" title="2">{
        ebm.mu.RLock()
        key := fmt.Sprintf("%s_%s", sloName, window)
        snapshots, exists := ebm.history[key]
        if !exists || len(snapshots) == 0 </span><span class="cov1" title="1">{
                ebm.mu.RUnlock()
                return nil, fmt.Errorf("no data available for report")
        }</span>

        // Create a copy of snapshots to avoid holding the lock too long
        <span class="cov1" title="1">snapshotsCopy := make([]ErrorBudgetSnapshot, len(snapshots))
        copy(snapshotsCopy, snapshots)
        ebm.mu.RUnlock()

        report := &amp;ErrorBudgetReport{
                SLOName:   sloName,
                Window:    window,
                Generated: time.Now(),
        }

        // Get latest state
        latest := snapshotsCopy[len(snapshotsCopy)-1]
        report.CurrentRemaining = latest.Remaining
        report.CurrentConsumed = latest.ConsumedPercent

        // Calculate burn rate
        windowDuration := time.Duration(ebm.config.WindowDays) * 24 * time.Hour
        burnRate, err := ebm.CalculateBurnRate(sloName, window, windowDuration)
        if err == nil </span><span class="cov1" title="1">{
                report.BurnRate = burnRate
        }</span>

        // Predict exhaustion
        <span class="cov1" title="1">exhaustionTime, err := ebm.PredictExhaustion(sloName, window)
        if err == nil </span><span class="cov1" title="1">{
                report.PredictedExhaustion = &amp;exhaustionTime
        }</span>

        // Get recommended action
        <span class="cov1" title="1">report.RecommendedAction = ebm.GetRecommendedAction(latest.ConsumedPercent)

        // Calculate statistics over the window
        report.Statistics = ebm.calculateStatistics(snapshotsCopy)

        return report, nil</span>
}

// ErrorBudgetReport contains a comprehensive error budget report
type ErrorBudgetReport struct {
        SLOName             string
        Window              string
        Generated           time.Time
        CurrentRemaining    float64
        CurrentConsumed     float64
        BurnRate            float64
        PredictedExhaustion *time.Time
        RecommendedAction   string
        Statistics          ErrorBudgetStatistics
}

// ErrorBudgetStatistics contains statistical data about error budget
type ErrorBudgetStatistics struct {
        MinRemaining     float64
        MaxRemaining     float64
        AvgRemaining     float64
        MinBurnRate      float64
        MaxBurnRate      float64
        AvgBurnRate      float64
        TotalViolations  int
        LongestViolation time.Duration
}

// calculateStatistics calculates statistics from snapshots
func (ebm *ErrorBudgetManager) calculateStatistics(snapshots []ErrorBudgetSnapshot) ErrorBudgetStatistics <span class="cov2" title="3">{
        if len(snapshots) == 0 </span><span class="cov1" title="1">{
                return ErrorBudgetStatistics{}
        }</span>

        <span class="cov1" title="2">stats := ErrorBudgetStatistics{
                MinRemaining: 1.0,
                MaxRemaining: 0.0,
                MinBurnRate:  1e9,
                MaxBurnRate:  0.0,
        }

        var (
                totalRemaining float64
                totalBurnRate  float64
                burnRateCount  int
                inViolation    bool
                violationStart time.Time
        )

        for _, snapshot := range snapshots </span><span class="cov3" title="9">{
                // Update remaining stats
                if snapshot.Remaining &lt; stats.MinRemaining </span><span class="cov3" title="8">{
                        stats.MinRemaining = snapshot.Remaining
                }</span>
                <span class="cov3" title="9">if snapshot.Remaining &gt; stats.MaxRemaining </span><span class="cov1" title="2">{
                        stats.MaxRemaining = snapshot.Remaining
                }</span>
                <span class="cov3" title="9">totalRemaining += snapshot.Remaining

                // Update burn rate stats
                if snapshot.BurnRate &gt; 0 </span><span class="cov3" title="9">{
                        if snapshot.BurnRate &lt; stats.MinBurnRate </span><span class="cov1" title="2">{
                                stats.MinBurnRate = snapshot.BurnRate
                        }</span>
                        <span class="cov3" title="9">if snapshot.BurnRate &gt; stats.MaxBurnRate </span><span class="cov3" title="6">{
                                stats.MaxBurnRate = snapshot.BurnRate
                        }</span>
                        <span class="cov3" title="9">totalBurnRate += snapshot.BurnRate
                        burnRateCount++</span>
                }

                // Track violations (when consumed &gt; warning threshold)
                <span class="cov3" title="9">if snapshot.ConsumedPercent &gt;= ebm.config.AlertThresholds.Warning </span><span class="cov2" title="3">{
                        if !inViolation </span><span class="cov1" title="2">{
                                inViolation = true
                                violationStart = snapshot.Timestamp
                                stats.TotalViolations++
                        }</span>
                } else<span class="cov3" title="6"> {
                        if inViolation </span><span class="cov1" title="1">{
                                violationDuration := snapshot.Timestamp.Sub(violationStart)
                                if violationDuration &gt; stats.LongestViolation </span><span class="cov1" title="1">{
                                        stats.LongestViolation = violationDuration
                                }</span>
                                <span class="cov1" title="1">inViolation = false</span>
                        }
                }
        }

        // Calculate averages
        <span class="cov1" title="2">if len(snapshots) &gt; 0 </span><span class="cov1" title="2">{
                stats.AvgRemaining = totalRemaining / float64(len(snapshots))
        }</span>
        <span class="cov1" title="2">if burnRateCount &gt; 0 </span><span class="cov1" title="2">{
                stats.AvgBurnRate = totalBurnRate / float64(burnRateCount)
        }</span>

        // If still in violation, calculate duration to now
        <span class="cov1" title="2">if inViolation </span><span class="cov1" title="1">{
                violationDuration := time.Now().Sub(violationStart)
                if violationDuration &gt; stats.LongestViolation </span><span class="cov1" title="1">{
                        stats.LongestViolation = violationDuration
                }</span>
        }

        <span class="cov1" title="2">return stats</span>
}

// clamp ensures a value is within min and max bounds
func clamp(value, min, max float64) float64 <span class="cov8" title="1023">{
        if value &lt; min </span><span class="cov2" title="3">{
                return min
        }</span>
        <span class="cov8" title="1020">if value &gt; max </span><span class="cov2" title="3">{
                return max
        }</span>
        <span class="cov8" title="1017">return value</span>
}</pre>

		<pre class="file" id="file22" style="display: none">package slo

import (
        "fmt"
        "strings"
        "time"

        "gopkg.in/yaml.v3"
)

// RecordingRuleGroup represents a Prometheus recording rule group
type RecordingRuleGroup struct {
        Name     string          `yaml:"name"`
        Interval string          `yaml:"interval,omitempty"`
        Rules    []RecordingRule `yaml:"rules"`
}

// RecordingRule represents a single Prometheus recording rule
type RecordingRule struct {
        Record string            `yaml:"record"`
        Expr   string            `yaml:"expr"`
        Labels map[string]string `yaml:"labels,omitempty"`
}

// PrometheusRulesSpec represents the structure expected by PrometheusRule CRD
type PrometheusRulesSpec struct {
        Groups []RecordingRuleGroup `yaml:"groups"`
}

// RecordingRulesGenerator generates Prometheus recording rules for SLO monitoring
type RecordingRulesGenerator struct {
        config *Config
}

// NewRecordingRulesGenerator creates a new recording rules generator
func NewRecordingRulesGenerator(config *Config) *RecordingRulesGenerator <span class="cov5" title="13">{
        return &amp;RecordingRulesGenerator{
                config: config,
        }
}</span>

// GenerateRecordingRules generates all recording rules for SLO monitoring
func (g *RecordingRulesGenerator) GenerateRecordingRules() *PrometheusRulesSpec <span class="cov4" title="11">{
        return &amp;PrometheusRulesSpec{
                Groups: []RecordingRuleGroup{
                        g.generateSLIRules(),
                        g.generateSLOBurnRateRules(),
                        g.generateErrorBudgetRules(),
                        g.generateMultiWindowRules(),
                },
        }
}</span>

// generateSLIRules generates SLI recording rules
func (g *RecordingRulesGenerator) generateSLIRules() RecordingRuleGroup <span class="cov5" title="12">{
        rules := []RecordingRule{
                // Availability SLI
                {
                        Record: "sli:availability:rate5m",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code!~"5.."}[5m])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[5m]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "availability",
                                "window":   "5m",
                        },
                },
                {
                        Record: "sli:availability:rate30m",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code!~"5.."}[30m])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[30m]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "availability",
                                "window":   "30m",
                        },
                },
                {
                        Record: "sli:availability:rate1h",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code!~"5.."}[1h])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[1h]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "availability",
                                "window":   "1h",
                        },
                },
                // Success Rate SLI (includes client errors as failures)
                {
                        Record: "sli:success_rate:rate5m",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code=~"2.."}[5m])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[5m]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "success_rate",
                                "window":   "5m",
                        },
                },
                {
                        Record: "sli:success_rate:rate30m",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code=~"2.."}[30m])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[30m]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "success_rate",
                                "window":   "30m",
                        },
                },
                {
                        Record: "sli:success_rate:rate1h",
                        Expr: `(
                                sum(rate(http_requests_total{job="cloudflare-dns-operator",code=~"2.."}[1h])) /
                                sum(rate(http_requests_total{job="cloudflare-dns-operator"}[1h]))
                        )`,
                        Labels: map[string]string{
                                "sli_type": "success_rate",
                                "window":   "1h",
                        },
                },
                // Latency SLI (P95)
                {
                        Record: "sli:latency_p95:5m",
                        Expr: `histogram_quantile(0.95,
                                sum(rate(http_request_duration_seconds_bucket{job="cloudflare-dns-operator"}[5m])) by (le)
                        )`,
                        Labels: map[string]string{
                                "sli_type": "latency_p95",
                                "window":   "5m",
                        },
                },
                {
                        Record: "sli:latency_p95:30m",
                        Expr: `histogram_quantile(0.95,
                                sum(rate(http_request_duration_seconds_bucket{job="cloudflare-dns-operator"}[30m])) by (le)
                        )`,
                        Labels: map[string]string{
                                "sli_type": "latency_p95",
                                "window":   "30m",
                        },
                },
                {
                        Record: "sli:latency_p95:1h",
                        Expr: `histogram_quantile(0.95,
                                sum(rate(http_request_duration_seconds_bucket{job="cloudflare-dns-operator"}[1h])) by (le)
                        )`,
                        Labels: map[string]string{
                                "sli_type": "latency_p95",
                                "window":   "1h",
                        },
                },
                // Throughput SLI
                {
                        Record: "sli:throughput:rate5m",
                        Expr:   `sum(rate(http_requests_total{job="cloudflare-dns-operator"}[5m]))`,
                        Labels: map[string]string{
                                "sli_type": "throughput",
                                "window":   "5m",
                        },
                },
                {
                        Record: "sli:throughput:rate30m",
                        Expr:   `sum(rate(http_requests_total{job="cloudflare-dns-operator"}[30m]))`,
                        Labels: map[string]string{
                                "sli_type": "throughput",
                                "window":   "30m",
                        },
                },
                {
                        Record: "sli:throughput:rate1h",
                        Expr:   `sum(rate(http_requests_total{job="cloudflare-dns-operator"}[1h]))`,
                        Labels: map[string]string{
                                "sli_type": "throughput",
                                "window":   "1h",
                        },
                },
        }

        return RecordingRuleGroup{
                Name:     "cloudflare-dns-operator.sli",
                Interval: "30s",
                Rules:    rules,
        }
}</span>

// generateSLOBurnRateRules generates SLO burn rate recording rules
func (g *RecordingRulesGenerator) generateSLOBurnRateRules() RecordingRuleGroup <span class="cov5" title="12">{
        rules := []RecordingRule{}

        // Generate burn rate rules for each SLO target
        sloTargets := map[string]float64{
                "availability":  g.config.Targets.Availability / 100.0,
                "success_rate":  g.config.Targets.SuccessRate / 100.0,
                "latency_p95":   g.config.Targets.LatencyP95.Seconds(),
                "throughput":    g.config.Targets.ThroughputMin,
        }

        windows := []string{"5m", "30m", "1h", "6h", "24h"}

        for sloName, target := range sloTargets </span><span class="cov7" title="48">{
                for _, window := range windows </span><span class="cov10" title="240">{
                        if sloName == "latency_p95" </span><span class="cov7" title="60">{
                                // For latency, we calculate the percentage of requests that meet the SLO
                                rule := RecordingRule{
                                        Record: fmt.Sprintf("slo:burn_rate:%s:%s", sloName, window),
                                        Expr: fmt.Sprintf(`(
                                                1 - (
                                                        sum(rate(http_request_duration_seconds_bucket{job="cloudflare-dns-operator",le="%.3f"}[%s])) /
                                                        sum(rate(http_request_duration_seconds_bucket{job="cloudflare-dns-operator",le="+Inf"}[%s]))
                                                )
                                        ) / (1 - 0.95)`, target, window, window),
                                        Labels: map[string]string{
                                                "slo_type": sloName,
                                                "window":   window,
                                                "target":   fmt.Sprintf("%.3f", target),
                                        },
                                }
                                rules = append(rules, rule)
                        }</span> else<span class="cov9" title="180"> if sloName == "throughput" </span><span class="cov7" title="60">{
                                // For throughput, we check if we're meeting the minimum requirement
                                rule := RecordingRule{
                                        Record: fmt.Sprintf("slo:burn_rate:%s:%s", sloName, window),
                                        Expr: fmt.Sprintf(`(
                                                clamp_max(1 - (sli:throughput:rate%s / %.2f), 1)
                                        )`, window, target),
                                        Labels: map[string]string{
                                                "slo_type": sloName,
                                                "window":   window,
                                                "target":   fmt.Sprintf("%.2f", target),
                                        },
                                }
                                rules = append(rules, rule)
                        }</span> else<span class="cov8" title="120"> {
                                // For availability and success rate
                                rule := RecordingRule{
                                        Record: fmt.Sprintf("slo:burn_rate:%s:%s", sloName, window),
                                        Expr: fmt.Sprintf(`(
                                                1 - (sli:%s:rate%s / %.4f)
                                        ) / (1 - %.4f)`, sloName, window, target, target),
                                        Labels: map[string]string{
                                                "slo_type": sloName,
                                                "window":   window,
                                                "target":   fmt.Sprintf("%.4f", target),
                                        },
                                }
                                rules = append(rules, rule)
                        }</span>
                }
        }

        <span class="cov5" title="12">return RecordingRuleGroup{
                Name:     "cloudflare-dns-operator.slo.burn_rate",
                Interval: "30s",
                Rules:    rules,
        }</span>
}

// generateErrorBudgetRules generates error budget recording rules
func (g *RecordingRulesGenerator) generateErrorBudgetRules() RecordingRuleGroup <span class="cov5" title="12">{
        rules := []RecordingRule{
                // Error budget remaining (30 days)
                {
                        Record: "slo:error_budget_remaining:availability:30d",
                        Expr: fmt.Sprintf(`(
                                1 - (
                                        (1 - avg_over_time(sli:availability:rate1h[30d])) / (1 - %.4f)
                                )
                        )`, g.config.Targets.Availability/100.0),
                        Labels: map[string]string{
                                "slo_type":     "availability",
                                "window":       "30d",
                                "target":       fmt.Sprintf("%.4f", g.config.Targets.Availability/100.0),
                                "budget_type":  "remaining",
                        },
                },
                {
                        Record: "slo:error_budget_remaining:success_rate:30d",
                        Expr: fmt.Sprintf(`(
                                1 - (
                                        (1 - avg_over_time(sli:success_rate:rate1h[30d])) / (1 - %.4f)
                                )
                        )`, g.config.Targets.SuccessRate/100.0),
                        Labels: map[string]string{
                                "slo_type":     "success_rate",
                                "window":       "30d",
                                "target":       fmt.Sprintf("%.4f", g.config.Targets.SuccessRate/100.0),
                                "budget_type":  "remaining",
                        },
                },
                // Error budget burn rate over different periods
                {
                        Record: "slo:error_budget_burn_rate:availability:1h",
                        Expr: `(
                                slo:burn_rate:availability:1h * 24 * 30
                        )`,
                        Labels: map[string]string{
                                "slo_type":     "availability",
                                "window":       "1h",
                                "budget_type":  "burn_rate",
                        },
                },
                {
                        Record: "slo:error_budget_burn_rate:availability:6h",
                        Expr: `(
                                slo:burn_rate:availability:6h * 4 * 30
                        )`,
                        Labels: map[string]string{
                                "slo_type":     "availability",
                                "window":       "6h",
                                "budget_type":  "burn_rate",
                        },
                },
                {
                        Record: "slo:error_budget_burn_rate:success_rate:1h",
                        Expr: `(
                                slo:burn_rate:success_rate:1h * 24 * 30
                        )`,
                        Labels: map[string]string{
                                "slo_type":     "success_rate",
                                "window":       "1h",
                                "budget_type":  "burn_rate",
                        },
                },
                {
                        Record: "slo:error_budget_burn_rate:success_rate:6h",
                        Expr: `(
                                slo:burn_rate:success_rate:6h * 4 * 30
                        )`,
                        Labels: map[string]string{
                                "slo_type":     "success_rate",
                                "window":       "6h",
                                "budget_type":  "burn_rate",
                        },
                },
        }

        return RecordingRuleGroup{
                Name:     "cloudflare-dns-operator.slo.error_budget",
                Interval: "1m",
                Rules:    rules,
        }
}</span>

// generateMultiWindowRules generates multi-window burn rate rules for alerting
func (g *RecordingRulesGenerator) generateMultiWindowRules() RecordingRuleGroup <span class="cov5" title="12">{
        rules := []RecordingRule{}

        // Multi-window burn rate rules for page alerts (fast burn)
        pageAlerts := []struct {
                shortWindow string
                longWindow  string
                threshold   float64
        }{
                {"5m", "1h", 14.4},   // 2% budget in 1 hour
                {"30m", "6h", 6.0},   // 5% budget in 6 hours
        }

        // Multi-window burn rate rules for ticket alerts (slow burn)
        ticketAlerts := []struct {
                shortWindow string
                longWindow  string
                threshold   float64
        }{
                {"2h", "1d", 3.0},   // 10% budget in 1 day
                {"6h", "3d", 1.0},   // 25% budget in 3 days
        }

        sloTypes := []string{"availability", "success_rate"}

        // Generate page alert rules
        for _, alert := range pageAlerts </span><span class="cov6" title="24">{
                for _, sloType := range sloTypes </span><span class="cov7" title="48">{
                        rule := RecordingRule{
                                Record: fmt.Sprintf("slo:multi_window_burn_rate:%s:%s_%s", sloType, alert.shortWindow, alert.longWindow),
                                Expr: fmt.Sprintf(`(
                                        slo:burn_rate:%s:%s &gt; (%.1f * 0.25)
                                        and
                                        slo:burn_rate:%s:%s &gt; (%.1f * 0.25)
                                )`, sloType, alert.shortWindow, alert.threshold, sloType, alert.longWindow, alert.threshold),
                                Labels: map[string]string{
                                        "slo_type":     sloType,
                                        "short_window": alert.shortWindow,
                                        "long_window":  alert.longWindow,
                                        "severity":     "page",
                                        "threshold":    fmt.Sprintf("%.1f", alert.threshold),
                                },
                        }
                        rules = append(rules, rule)
                }</span>
        }

        // Generate ticket alert rules
        <span class="cov5" title="12">for _, alert := range ticketAlerts </span><span class="cov6" title="24">{
                for _, sloType := range sloTypes </span><span class="cov7" title="48">{
                        rule := RecordingRule{
                                Record: fmt.Sprintf("slo:multi_window_burn_rate:%s:%s_%s", sloType, alert.shortWindow, alert.longWindow),
                                Expr: fmt.Sprintf(`(
                                        slo:burn_rate:%s:%s &gt; (%.1f * 0.1)
                                        and
                                        slo:burn_rate:%s:%s &gt; (%.1f * 0.1)
                                )`, sloType, alert.shortWindow, alert.threshold, sloType, alert.longWindow, alert.threshold),
                                Labels: map[string]string{
                                        "slo_type":     sloType,
                                        "short_window": alert.shortWindow,
                                        "long_window":  alert.longWindow,
                                        "severity":     "ticket",
                                        "threshold":    fmt.Sprintf("%.1f", alert.threshold),
                                },
                        }
                        rules = append(rules, rule)
                }</span>
        }

        <span class="cov5" title="12">return RecordingRuleGroup{
                Name:     "cloudflare-dns-operator.slo.multi_window",
                Interval: "30s",
                Rules:    rules,
        }</span>
}

// GenerateYAML generates YAML output for the recording rules
func (g *RecordingRulesGenerator) GenerateYAML() (string, error) <span class="cov2" title="2">{
        rules := g.GenerateRecordingRules()

        yamlData, err := yaml.Marshal(rules)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal recording rules to YAML: %w", err)
        }</span>

        <span class="cov2" title="2">return string(yamlData), nil</span>
}

// GeneratePrometheusRuleCRD generates a PrometheusRule CRD YAML
func (g *RecordingRulesGenerator) GeneratePrometheusRuleCRD(name, namespace string) (string, error) <span class="cov2" title="2">{
        rules := g.GenerateRecordingRules()

        crd := map[string]interface{}{
                "apiVersion": "monitoring.coreos.com/v1",
                "kind":       "PrometheusRule",
                "metadata": map[string]interface{}{
                        "name":      name,
                        "namespace": namespace,
                        "labels": map[string]string{
                                "app.kubernetes.io/name":      "cloudflare-dns-operator",
                                "app.kubernetes.io/component": "slo-monitoring",
                                "prometheus":                  "kube-prometheus",
                                "role":                        "alert-rules",
                        },
                },
                "spec": rules,
        }

        yamlData, err := yaml.Marshal(crd)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to marshal PrometheusRule CRD to YAML: %w", err)
        }</span>

        <span class="cov2" title="2">return string(yamlData), nil</span>
}

// ValidateRecordingRules validates the generated recording rules
func (g *RecordingRulesGenerator) ValidateRecordingRules() []string <span class="cov2" title="2">{
        var issues []string
        rules := g.GenerateRecordingRules()

        for _, group := range rules.Groups </span><span class="cov4" title="8">{
                // Validate group name
                if group.Name == "" </span><span class="cov0" title="0">{
                        issues = append(issues, "empty group name found")
                }</span>

                // Validate rules
                <span class="cov4" title="8">for _, rule := range group.Rules </span><span class="cov8" title="92">{
                        // Check for empty record name
                        if rule.Record == "" </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("empty record name in group %s", group.Name))
                        }</span>

                        // Check for empty expression
                        <span class="cov8" title="92">if rule.Expr == "" </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("empty expression for rule %s", rule.Record))
                        }</span>

                        // Check for valid metric naming
                        <span class="cov8" title="92">if !strings.Contains(rule.Record, ":") </span><span class="cov0" title="0">{
                                issues = append(issues, fmt.Sprintf("rule %s doesn't follow naming convention (missing colon)", rule.Record))
                        }</span>

                        // Check for reasonable interval
                        <span class="cov8" title="92">if group.Interval != "" </span><span class="cov8" title="92">{
                                if interval, err := time.ParseDuration(group.Interval); err != nil </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("invalid interval %s in group %s", group.Interval, group.Name))
                                }</span> else<span class="cov8" title="92"> if interval &lt; 10*time.Second </span><span class="cov0" title="0">{
                                        issues = append(issues, fmt.Sprintf("interval %s in group %s is too short", group.Interval, group.Name))
                                }</span>
                        }
                }
        }

        <span class="cov2" title="2">return issues</span>
}

// GetRecordingRuleNames returns all recording rule names for testing
func (g *RecordingRulesGenerator) GetRecordingRuleNames() []string <span class="cov2" title="2">{
        var names []string
        rules := g.GenerateRecordingRules()

        for _, group := range rules.Groups </span><span class="cov4" title="8">{
                for _, rule := range group.Rules </span><span class="cov8" title="92">{
                        names = append(names, rule.Record)
                }</span>
        }

        <span class="cov2" title="2">return names</span>
}</pre>

		<pre class="file" id="file23" style="display: none">package slo

import (
        "context"
        "fmt"
        "sync"
        "time"

        "github.com/prometheus/client_golang/prometheus"
        "go.uber.org/zap"
)

// Manager manages SLO monitoring and alerting
type Manager struct {
        config     *Config
        calculator *Calculator
        logger     *zap.Logger

        // State management
        mu              sync.RWMutex
        lastCalculation map[string]*SLIValues
        errorBudgets    map[string]*ErrorBudgetState

        // Control channels
        stopCh chan struct{}
        doneCh chan struct{}
}

// ErrorBudgetState tracks the state of an error budget
type ErrorBudgetState struct {
        SLOName           string
        CurrentRemaining  float64
        ConsumedPercent   float64
        LastUpdated       time.Time
        PolicyTriggered   []string
        BurnRate          float64
        TimeToExhaustion  time.Duration
}

// NewManager creates a new SLO manager
func NewManager(config *Config, logger *zap.Logger) (*Manager, error) <span class="cov1" title="2">{
        if config == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>
        <span class="cov1" title="1">if logger == nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid SLO config: %w", err)
        }</span>

        <span class="cov0" title="0">return NewManagerWithRegistry(config, logger, prometheus.DefaultRegisterer)</span>
}

// NewManagerWithRegistry creates a new SLO manager with a custom metrics registry
func NewManagerWithRegistry(config *Config, logger *zap.Logger, registerer prometheus.Registerer) (*Manager, error) <span class="cov4" title="16">{
        if config == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config cannot be nil")
        }</span>
        <span class="cov4" title="16">if logger == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("logger cannot be nil")
        }</span>
        <span class="cov4" title="16">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid SLO config: %w", err)
        }</span>

        <span class="cov4" title="16">return &amp;Manager{
                config:          config,
                calculator:      NewCalculatorWithRegistry(config, registerer),
                logger:          logger,
                lastCalculation: make(map[string]*SLIValues),
                errorBudgets:    make(map[string]*ErrorBudgetState),
                stopCh:          make(chan struct{}),
                doneCh:          make(chan struct{}),
        }, nil</span>
}

// Start begins SLO monitoring
func (m *Manager) Start(ctx context.Context) error <span class="cov3" title="7">{
        if !m.config.Enabled </span><span class="cov1" title="1">{
                m.logger.Info("SLO monitoring is disabled")
                return nil
        }</span>

        <span class="cov3" title="6">m.logger.Info("Starting SLO monitoring")

        // Start monitoring goroutine
        go m.run(ctx)

        return nil</span>
}

// Stop stops SLO monitoring
func (m *Manager) Stop() <span class="cov3" title="7">{
        m.logger.Info("Stopping SLO monitoring")
        close(m.stopCh)

        // Only wait for doneCh if SLO monitoring was actually started
        if m.config.Enabled </span><span class="cov3" title="6">{
                &lt;-m.doneCh
        }</span>
}

// run is the main monitoring loop
func (m *Manager) run(ctx context.Context) <span class="cov3" title="6">{
        defer close(m.doneCh)

        // Create tickers for each window
        tickers := make(map[string]*time.Ticker)
        for _, window := range m.config.Windows </span><span class="cov3" title="10">{
                // Calculate SLIs more frequently than the window duration
                // Short-term windows: every 30 seconds
                // Long-term windows: every 5 minutes
                interval := window.Duration / 10
                if window.IsShortTerm </span><span class="cov3" title="6">{
                        interval = 30 * time.Second
                }</span> else<span class="cov2" title="4"> if interval &lt; 5*time.Minute </span><span class="cov0" title="0">{
                        interval = 5 * time.Minute
                }</span>

                <span class="cov3" title="10">ticker := time.NewTicker(interval)
                tickers[window.Name] = ticker

                // Initial calculation
                go m.calculateForWindow(ctx, window)</span>
        }

        // Clean up tickers on exit
        <span class="cov3" title="6">defer func() </span><span class="cov3" title="6">{
                for _, ticker := range tickers </span><span class="cov3" title="10">{
                        ticker.Stop()
                }</span>
        }()

        // Main monitoring loop
        <span class="cov3" title="6">for </span><span class="cov5" title="37">{
                select </span>{
                case &lt;-m.stopCh:<span class="cov3" title="6">
                        return</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return</span>
                default:<span class="cov4" title="31">
                        // Check each ticker
                        for _, window := range m.config.Windows </span><span class="cov5" title="40">{
                                select </span>{
                                case &lt;-tickers[window.Name].C:<span class="cov0" title="0">
                                        go m.calculateForWindow(ctx, window)</span>
                                default:<span class="cov5" title="40"></span>
                                        // Non-blocking
                                }
                        }

                        // Small sleep to prevent busy loop
                        <span class="cov4" title="31">time.Sleep(100 * time.Millisecond)</span>
                }
        }
}

// calculateForWindow calculates SLIs for a specific time window
func (m *Manager) calculateForWindow(ctx context.Context, window TimeWindow) <span class="cov6" title="111">{
        logger := m.logger.With(
                zap.String("window", window.Name),
                zap.Duration("duration", window.Duration),
        )

        logger.Debug("Calculating SLIs for window")

        // Calculate SLI values
        values, err := m.calculator.Calculate(ctx, window)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to calculate SLIs", zap.Error(err))
                return
        }</span>

        // Store calculation
        <span class="cov6" title="111">m.mu.Lock()
        m.lastCalculation[window.Name] = values
        m.mu.Unlock()

        // Update error budgets
        m.updateErrorBudgets(values)

        // Check multi-window burn rates for alerting
        if window.IsShortTerm </span><span class="cov3" title="7">{
                m.checkBurnRates(ctx)
        }</span>

        <span class="cov6" title="111">logger.Debug("SLI calculation completed",
                zap.Float64("availability", values.Availability),
                zap.Float64("success_rate", values.SuccessRate),
                zap.Duration("latency_p95", values.LatencyP95),
                zap.Float64("throughput", values.Throughput),
        )</span>
}

// updateErrorBudgets updates error budget states based on SLI values
func (m *Manager) updateErrorBudgets(values *SLIValues) <span class="cov7" title="362">{
        m.mu.Lock()
        defer m.mu.Unlock()

        // Update availability error budget
        m.updateSingleErrorBudget("availability", values.Availability, m.config.Targets.Availability/100, values.Window)

        // Update success rate error budget
        m.updateSingleErrorBudget("success_rate", values.SuccessRate, m.config.Targets.SuccessRate/100, values.Window)

        // Update latency error budget (simplified)
        latencyConformance := 1.0
        if values.LatencyP95 &gt; m.config.Targets.LatencyP95 </span><span class="cov1" title="1">{
                latencyConformance = 0.95
        }</span>
        <span class="cov7" title="362">m.updateSingleErrorBudget("latency_p95", latencyConformance, 0.95, values.Window)</span>
}

// updateSingleErrorBudget updates a single error budget state
func (m *Manager) updateSingleErrorBudget(sloName string, actual, target float64, window string) <span class="cov8" title="1087">{
        key := fmt.Sprintf("%s_%s", sloName, window)

        state, exists := m.errorBudgets[key]
        if !exists </span><span class="cov5" title="40">{
                state = &amp;ErrorBudgetState{
                        SLOName: sloName,
                }
                m.errorBudgets[key] = state
        }</span>

        // Calculate remaining budget
        <span class="cov8" title="1087">errorBudgetTotal := 1.0 - target
        errorBudgetConsumed := 0.0
        if actual &lt; target </span><span class="cov8" title="614">{
                errorBudgetConsumed = target - actual
        }</span>

        <span class="cov8" title="1087">state.CurrentRemaining = 1.0
        if errorBudgetTotal &gt; 0 </span><span class="cov8" title="1087">{
                state.CurrentRemaining = (errorBudgetTotal - errorBudgetConsumed) / errorBudgetTotal
        }</span>
        <span class="cov8" title="1087">state.ConsumedPercent = 1.0 - state.CurrentRemaining
        state.LastUpdated = time.Now()

        // Calculate burn rate (simplified - would use historical data in production)
        if state.BurnRate == 0 </span><span class="cov7" title="389">{
                state.BurnRate = state.ConsumedPercent // Initial estimate
        }</span> else<span class="cov8" title="698"> {
                // Exponential moving average
                state.BurnRate = 0.9*state.BurnRate + 0.1*state.ConsumedPercent
        }</span>

        // Estimate time to exhaustion
        <span class="cov8" title="1087">if state.BurnRate &gt; 0 &amp;&amp; state.CurrentRemaining &gt; 0 </span><span class="cov7" title="462">{
                hoursRemaining := state.CurrentRemaining / (state.BurnRate / 24) // Assuming daily burn rate
                state.TimeToExhaustion = time.Duration(hoursRemaining) * time.Hour
        }</span>

        // Check policies
        <span class="cov8" title="1087">m.checkErrorBudgetPolicies(state)</span>
}

// checkErrorBudgetPolicies checks if any policies should be triggered
func (m *Manager) checkErrorBudgetPolicies(state *ErrorBudgetState) <span class="cov8" title="1089">{
        state.PolicyTriggered = []string{}

        for _, policy := range m.config.ErrorBudget.Policies </span><span class="cov9" title="2178">{
                if state.ConsumedPercent &gt;= policy.Threshold </span><span class="cov8" title="508">{
                        state.PolicyTriggered = append(state.PolicyTriggered, policy.Action)

                        m.logger.Warn("Error budget policy triggered",
                                zap.String("slo", state.SLOName),
                                zap.Float64("consumed", state.ConsumedPercent),
                                zap.Float64("threshold", policy.Threshold),
                                zap.String("action", policy.Action),
                                zap.String("description", policy.Description),
                        )
                }</span>
        }
}

// checkBurnRates checks multi-window burn rates for alerting
func (m *Manager) checkBurnRates(ctx context.Context) <span class="cov3" title="7">{
        // Check page alerts (fast burn)
        if m.config.AlertingRules.PageAlerts.Enabled </span><span class="cov3" title="7">{
                m.checkBurnRateAlert(ctx, m.config.AlertingRules.PageAlerts, "page")
        }</span>

        // Check ticket alerts (slow burn)
        <span class="cov3" title="7">if m.config.AlertingRules.TicketAlerts.Enabled </span><span class="cov3" title="7">{
                m.checkBurnRateAlert(ctx, m.config.AlertingRules.TicketAlerts, "ticket")
        }</span>
}

// checkBurnRateAlert checks a specific burn rate alert
func (m *Manager) checkBurnRateAlert(ctx context.Context, alert BurnRateAlert, alertType string) <span class="cov3" title="14">{
        // Find the windows
        var shortWindow, longWindow *TimeWindow
        for i := range m.config.Windows </span><span class="cov5" title="44">{
                if m.config.Windows[i].Duration == alert.ShortWindow </span><span class="cov3" title="7">{
                        shortWindow = &amp;m.config.Windows[i]
                }</span>
                <span class="cov5" title="44">if m.config.Windows[i].Duration == alert.LongWindow </span><span class="cov3" title="6">{
                        longWindow = &amp;m.config.Windows[i]
                }</span>
        }

        <span class="cov3" title="14">if shortWindow == nil || longWindow == nil </span><span class="cov3" title="8">{
                m.logger.Error("Burn rate windows not found",
                        zap.String("alert_type", alertType),
                        zap.Duration("short_window", alert.ShortWindow),
                        zap.Duration("long_window", alert.LongWindow),
                )
                return
        }</span>

        // Calculate burn rate
        <span class="cov3" title="6">burnRate, err := m.calculator.CalculateMultiWindowBurnRate(ctx, *shortWindow, *longWindow)
        if err != nil </span><span class="cov0" title="0">{
                m.logger.Error("Failed to calculate burn rate",
                        zap.String("alert_type", alertType),
                        zap.Error(err),
                )
                return
        }</span>

        // Check threshold
        <span class="cov3" title="6">if burnRate &gt;= alert.BurnRateThreshold </span><span class="cov0" title="0">{
                m.logger.Error("Burn rate threshold exceeded",
                        zap.String("alert_type", alertType),
                        zap.Float64("burn_rate", burnRate),
                        zap.Float64("threshold", alert.BurnRateThreshold),
                        zap.String("severity", alert.Severity),
                )

                // In a real implementation, this would trigger alerts via AlertManager
        }</span>
}

// GetSLIValues returns the last calculated SLI values for a window
func (m *Manager) GetSLIValues(window string) (*SLIValues, bool) <span class="cov8" title="1004">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        values, exists := m.lastCalculation[window]
        return values, exists
}</span>

// GetErrorBudgetState returns the error budget state for an SLO
func (m *Manager) GetErrorBudgetState(sloName, window string) (*ErrorBudgetState, bool) <span class="cov8" title="1002">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        key := fmt.Sprintf("%s_%s", sloName, window)
        state, exists := m.errorBudgets[key]
        return state, exists
}</span>

// GetAllErrorBudgets returns all error budget states
func (m *Manager) GetAllErrorBudgets() map[string]*ErrorBudgetState <span class="cov8" title="1005">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Create a copy to avoid race conditions
        result := make(map[string]*ErrorBudgetState)
        for k, v := range m.errorBudgets </span><span class="cov10" title="2926">{
                result[k] = v
        }</span>
        <span class="cov8" title="1005">return result</span>
}</pre>

		<pre class="file" id="file24" style="display: none">// Package tracing provides distributed tracing functionality for the Cloudflare DNS Operator.
// It implements OpenTelemetry-based tracing with configurable exporters and sampling strategies.
package tracing

import (
        "fmt"
        "strings"
        "time"
)

// Config represents the tracing configuration
type Config struct {
        // Enabled controls whether tracing is enabled
        Enabled bool `yaml:"enabled" json:"enabled"`

        // ServiceName is the name of the service for tracing
        ServiceName string `yaml:"service_name" json:"service_name"`

        // ServiceVersion is the version of the service
        ServiceVersion string `yaml:"service_version" json:"service_version"`

        // Environment is the deployment environment (dev, staging, prod)
        Environment string `yaml:"environment" json:"environment"`

        // Exporter configuration
        Exporter ExporterConfig `yaml:"exporter" json:"exporter"`

        // Sampling configuration
        Sampling SamplingConfig `yaml:"sampling" json:"sampling"`

        // Resource attributes
        ResourceAttributes map[string]string `yaml:"resource_attributes" json:"resource_attributes"`
}

// ExporterConfig represents exporter configuration
type ExporterConfig struct {
        // Type of exporter (otlp, jaeger, console, none)
        Type string `yaml:"type" json:"type"`

        // Endpoint for OTLP/Jaeger exporter
        Endpoint string `yaml:"endpoint" json:"endpoint"`

        // Insecure connection (for development)
        Insecure bool `yaml:"insecure" json:"insecure"`

        // Headers for OTLP exporter
        Headers map[string]string `yaml:"headers" json:"headers"`

        // Timeout for export operations
        Timeout time.Duration `yaml:"timeout" json:"timeout"`

        // Compression type (gzip, none)
        Compression string `yaml:"compression" json:"compression"`
}

// SamplingConfig represents sampling configuration
type SamplingConfig struct {
        // Type of sampling (always, never, trace_id_ratio, parent_based)
        Type string `yaml:"type" json:"type"`

        // Ratio for trace_id_ratio sampling (0.0 to 1.0)
        Ratio float64 `yaml:"ratio" json:"ratio"`
}

// NewDefaultConfig returns a default tracing configuration
func NewDefaultConfig() Config <span class="cov6" title="11">{
        return Config{
                Enabled:        false,
                ServiceName:    "k8s-operator-cloudflare",
                ServiceVersion: "0.1.0",
                Environment:    "development",
                Exporter: ExporterConfig{
                        Type:        "console",
                        Endpoint:    "",
                        Insecure:    true,
                        Headers:     make(map[string]string),
                        Timeout:     10 * time.Second,
                        Compression: "none",
                },
                Sampling: SamplingConfig{
                        Type:  "parent_based",
                        Ratio: 1.0,
                },
                ResourceAttributes: make(map[string]string),
        }
}</span>

// NewEnvironmentConfig returns a tracing configuration for the given environment
func NewEnvironmentConfig(environment string) Config <span class="cov5" title="9">{
        config := NewDefaultConfig()
        config.Environment = environment

        switch strings.ToLower(environment) </span>{
        case "development", "dev":<span class="cov3" title="3">
                config.Enabled = true
                config.Exporter.Type = "console"
                config.Sampling.Type = "always"
                config.Sampling.Ratio = 1.0</span>
        case "staging":<span class="cov2" title="2">
                config.Enabled = true
                config.Exporter.Type = "otlp"
                config.Exporter.Endpoint = "http://localhost:4318/v1/traces"
                config.Sampling.Type = "trace_id_ratio"
                config.Sampling.Ratio = 0.5</span>
        case "production", "prod":<span class="cov3" title="3">
                config.Enabled = true
                config.Exporter.Type = "otlp"
                config.Exporter.Endpoint = "http://localhost:4318/v1/traces"
                config.Exporter.Insecure = false
                config.Sampling.Type = "trace_id_ratio"
                config.Sampling.Ratio = 0.1</span>
        default:<span class="cov1" title="1">
                // Default to development settings for unknown environments
                config.Enabled = false</span>
        }

        <span class="cov5" title="9">return config</span>
}

// Validate validates the tracing configuration
func (c *Config) Validate() error <span class="cov7" title="18">{
        if !c.Enabled </span><span class="cov3" title="3">{
                return nil // No validation needed if tracing is disabled
        }</span>

        // Validate service name
        <span class="cov6" title="15">if c.ServiceName == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("service_name is required when tracing is enabled")
        }</span>

        // Validate exporter
        <span class="cov6" title="13">if err := c.Exporter.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid exporter config: %w", err)
        }</span>

        // Validate sampling
        <span class="cov6" title="12">if err := c.Sampling.Validate(); err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid sampling config: %w", err)
        }</span>

        <span class="cov6" title="11">return nil</span>
}

// IsEnabled returns true if tracing is enabled
func (c *Config) IsEnabled() bool <span class="cov7" title="18">{
        return c.Enabled
}</span>

// GetServiceName returns the service name, with fallback
func (c *Config) GetServiceName() string <span class="cov6" title="15">{
        if c.ServiceName != "" </span><span class="cov6" title="14">{
                return c.ServiceName
        }</span>
        <span class="cov1" title="1">return "k8s-operator-cloudflare"</span>
}

// GetServiceVersion returns the service version, with fallback
func (c *Config) GetServiceVersion() string <span class="cov6" title="15">{
        if c.ServiceVersion != "" </span><span class="cov4" title="6">{
                return c.ServiceVersion
        }</span>
        <span class="cov5" title="9">return "unknown"</span>
}

// String returns a string representation of the config
func (c *Config) String() string <span class="cov1" title="1">{
        return fmt.Sprintf("enabled=%t, service=%s, version=%s, environment=%s, exporter=%s",
                c.Enabled, c.GetServiceName(), c.GetServiceVersion(), c.Environment, c.Exporter.Type)
}</span>

// Validate validates the exporter configuration
func (e *ExporterConfig) Validate() error <span class="cov7" title="24">{
        // Validate exporter type
        validTypes := []string{"otlp", "jaeger", "console", "none"}
        valid := false
        for _, t := range validTypes </span><span class="cov10" title="73">{
                if e.Type == t </span><span class="cov7" title="22">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov7" title="24">if !valid </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid exporter type: %s, must be one of %v", e.Type, validTypes)
        }</span>

        // Validate endpoint for OTLP and Jaeger
        <span class="cov7" title="22">if (e.Type == "otlp" || e.Type == "jaeger") &amp;&amp; e.Endpoint == "" </span><span class="cov2" title="2">{
                return fmt.Errorf("endpoint is required for %s exporter", e.Type)
        }</span>

        // Validate timeout
        <span class="cov7" title="20">if e.Timeout &lt;= 0 </span><span class="cov1" title="1">{
                e.Timeout = 10 * time.Second // Set default
        }</span>

        // Validate compression
        <span class="cov7" title="20">if e.Compression != "" &amp;&amp; e.Compression != "gzip" &amp;&amp; e.Compression != "none" </span><span class="cov1" title="1">{
                return fmt.Errorf("invalid compression: %s, must be 'gzip' or 'none'", e.Compression)
        }</span>

        <span class="cov7" title="19">return nil</span>
}

// Validate validates the sampling configuration
func (s *SamplingConfig) Validate() error <span class="cov7" title="21">{
        // Validate sampling type
        validTypes := []string{"always", "never", "trace_id_ratio", "parent_based"}
        valid := false
        for _, t := range validTypes </span><span class="cov8" title="45">{
                if s.Type == t </span><span class="cov7" title="19">{
                        valid = true
                        break</span>
                }
        }
        <span class="cov7" title="21">if !valid </span><span class="cov2" title="2">{
                return fmt.Errorf("invalid sampling type: %s, must be one of %v", s.Type, validTypes)
        }</span>

        // Validate ratio for trace_id_ratio sampling
        <span class="cov7" title="19">if s.Type == "trace_id_ratio" </span><span class="cov4" title="6">{
                if s.Ratio &lt; 0.0 || s.Ratio &gt; 1.0 </span><span class="cov2" title="2">{
                        return fmt.Errorf("sampling ratio must be between 0.0 and 1.0, got %f", s.Ratio)
                }</span>
        }

        <span class="cov6" title="17">return nil</span>
}
</pre>

		<pre class="file" id="file25" style="display: none">package tracing

import (
        "context"
        "fmt"
        "os"

        "go.opentelemetry.io/otel"
        "go.opentelemetry.io/otel/attribute"
        "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp"
        "go.opentelemetry.io/otel/exporters/stdout/stdouttrace"
        "go.opentelemetry.io/otel/propagation"
        "go.opentelemetry.io/otel/sdk/resource"
        "go.opentelemetry.io/otel/sdk/trace"
        semconv "go.opentelemetry.io/otel/semconv/v1.20.0"
        oteltrace "go.opentelemetry.io/otel/trace"
)

// Provider wraps the OpenTelemetry TracerProvider
type Provider struct {
        provider *trace.TracerProvider
        config   Config
}

// NewProvider creates a new tracing provider with the given configuration
func NewProvider(config Config) (*Provider, error) <span class="cov9" title="13">{
        if err := config.Validate(); err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("invalid tracing config: %w", err)
        }</span>

        <span class="cov9" title="12">if !config.IsEnabled() </span><span class="cov3" title="2">{
                // Return a no-op provider
                return &amp;Provider{
                        provider: trace.NewTracerProvider(),
                        config:   config,
                }, nil
        }</span>

        // Create resource with service information
        <span class="cov8" title="10">res, err := createResource(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create resource: %w", err)
        }</span>

        // Create exporter
        <span class="cov8" title="10">exporter, err := createExporter(config.Exporter)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create exporter: %w", err)
        }</span>

        // Create sampler
        <span class="cov8" title="10">sampler, err := createSampler(config.Sampling)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create sampler: %w", err)
        }</span>

        // Create tracer provider
        <span class="cov8" title="10">tracerProvider := trace.NewTracerProvider(
                trace.WithBatcher(exporter),
                trace.WithResource(res),
                trace.WithSampler(sampler),
        )

        return &amp;Provider{
                provider: tracerProvider,
                config:   config,
        }, nil</span>
}

// Tracer returns a tracer for the given name
func (p *Provider) Tracer(name string, opts ...oteltrace.TracerOption) oteltrace.Tracer <span class="cov1" title="1">{
        return p.provider.Tracer(name, opts...)
}</span>

// Shutdown shuts down the tracer provider
func (p *Provider) Shutdown(ctx context.Context) error <span class="cov9" title="13">{
        if p.provider == nil </span><span class="cov1" title="1">{
                return nil
        }</span>
        <span class="cov9" title="12">return p.provider.Shutdown(ctx)</span>
}

// IsEnabled returns true if tracing is enabled
func (p *Provider) IsEnabled() bool <span class="cov5" title="4">{
        return p.config.IsEnabled()
}</span>

// Config returns the tracing configuration
func (p *Provider) Config() Config <span class="cov4" title="3">{
        return p.config
}</span>

// SetupGlobalTracer sets up the global tracer provider
func SetupGlobalTracer(config Config) (*Provider, error) <span class="cov5" title="4">{
        provider, err := NewProvider(config)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Set global tracer provider
        <span class="cov5" title="4">otel.SetTracerProvider(provider.provider)

        // Set global propagator
        otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
                propagation.TraceContext{},
                propagation.Baggage{},
        ))

        return provider, nil</span>
}

// TracerFromConfig creates a tracer from environment variables and config
func TracerFromConfig(environment string) (*Provider, error) <span class="cov4" title="3">{
        config := NewEnvironmentConfig(environment)

        // Override with environment variables if present
        if enabled := os.Getenv("TRACING_ENABLED"); enabled != "" </span><span class="cov4" title="3">{
                config.Enabled = enabled == "true"
        }</span>
        <span class="cov4" title="3">if serviceName := os.Getenv("TRACING_SERVICE_NAME"); serviceName != "" </span><span class="cov1" title="1">{
                config.ServiceName = serviceName
        }</span>
        <span class="cov4" title="3">if serviceVersion := os.Getenv("TRACING_SERVICE_VERSION"); serviceVersion != "" </span><span class="cov1" title="1">{
                config.ServiceVersion = serviceVersion
        }</span>
        <span class="cov4" title="3">if exporterType := os.Getenv("TRACING_EXPORTER_TYPE"); exporterType != "" </span><span class="cov1" title="1">{
                config.Exporter.Type = exporterType
        }</span>
        <span class="cov4" title="3">if endpoint := os.Getenv("TRACING_EXPORTER_ENDPOINT"); endpoint != "" </span><span class="cov1" title="1">{
                config.Exporter.Endpoint = endpoint
        }</span>
        <span class="cov4" title="3">if samplingType := os.Getenv("TRACING_SAMPLING_TYPE"); samplingType != "" </span><span class="cov1" title="1">{
                config.Sampling.Type = samplingType
        }</span>

        <span class="cov4" title="3">return NewProvider(config)</span>
}

// createResource creates OpenTelemetry resource with service information
func createResource(config Config) (*resource.Resource, error) <span class="cov9" title="12">{
        attrs := []resource.Option{
                resource.WithAttributes(
                        semconv.ServiceName(config.GetServiceName()),
                        semconv.ServiceVersion(config.GetServiceVersion()),
                        semconv.DeploymentEnvironment(config.Environment),
                ),
        }

        // Add custom resource attributes
        if len(config.ResourceAttributes) &gt; 0 </span><span class="cov1" title="1">{
                customAttrs := make([]attribute.KeyValue, 0, len(config.ResourceAttributes))
                for key, value := range config.ResourceAttributes </span><span class="cov1" title="1">{
                        customAttrs = append(customAttrs, attribute.String(key, value))
                }</span>
                <span class="cov1" title="1">attrs = append(attrs, resource.WithAttributes(customAttrs...))</span>
        }

        <span class="cov9" title="12">return resource.New(context.Background(), attrs...)</span>
}

// createExporter creates the appropriate trace exporter
func createExporter(config ExporterConfig) (trace.SpanExporter, error) <span class="cov10" title="15">{
        switch config.Type </span>{
        case "otlp":<span class="cov4" title="3">
                opts := []otlptracehttp.Option{
                        otlptracehttp.WithEndpoint(config.Endpoint),
                        otlptracehttp.WithTimeout(config.Timeout),
                }

                if config.Insecure </span><span class="cov1" title="1">{
                        opts = append(opts, otlptracehttp.WithInsecure())
                }</span>

                <span class="cov4" title="3">if len(config.Headers) &gt; 0 </span><span class="cov1" title="1">{
                        opts = append(opts, otlptracehttp.WithHeaders(config.Headers))
                }</span>

                <span class="cov4" title="3">if config.Compression == "gzip" </span><span class="cov1" title="1">{
                        opts = append(opts, otlptracehttp.WithCompression(otlptracehttp.GzipCompression))
                }</span>

                <span class="cov4" title="3">return otlptracehttp.New(context.Background(), opts...)</span>

        case "console":<span class="cov3" title="2">
                return stdouttrace.New(
                        stdouttrace.WithPrettyPrint(),
                )</span>

        case "none":<span class="cov8" title="9">
                // Return a no-op exporter
                return &amp;noopExporter{}, nil</span>

        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported exporter type: %s", config.Type)</span>
        }
}

// createSampler creates the appropriate trace sampler
func createSampler(config SamplingConfig) (trace.Sampler, error) <span class="cov10" title="15">{
        switch config.Type </span>{
        case "always":<span class="cov7" title="8">
                return trace.AlwaysSample(), nil</span>
        case "never":<span class="cov4" title="3">
                return trace.NeverSample(), nil</span>
        case "trace_id_ratio":<span class="cov3" title="2">
                return trace.TraceIDRatioBased(config.Ratio), nil</span>
        case "parent_based":<span class="cov1" title="1">
                return trace.ParentBased(trace.TraceIDRatioBased(config.Ratio)), nil</span>
        default:<span class="cov1" title="1">
                return nil, fmt.Errorf("unsupported sampling type: %s", config.Type)</span>
        }
}

// noopExporter is a no-op span exporter
type noopExporter struct{}

func (e *noopExporter) ExportSpans(ctx context.Context, spans []trace.ReadOnlySpan) error <span class="cov6" title="6">{
        return nil
}</span>

func (e *noopExporter) Shutdown(ctx context.Context) error <span class="cov8" title="10">{
        return nil
}</span>

// StartSpan starts a new span with the given name and options
func StartSpan(ctx context.Context, name string, opts ...oteltrace.SpanStartOption) (context.Context, oteltrace.Span) <span class="cov4" title="3">{
        tracer := otel.Tracer("k8s-operator-cloudflare")
        return tracer.Start(ctx, name, opts...)
}</span>

// SpanFromContext returns the current span from the context
func SpanFromContext(ctx context.Context) oteltrace.Span <span class="cov7" title="7">{
        return oteltrace.SpanFromContext(ctx)
}</span>

// ContextWithSpan returns a new context with the given span
func ContextWithSpan(ctx context.Context, span oteltrace.Span) context.Context <span class="cov1" title="1">{
        return oteltrace.ContextWithSpan(ctx, span)
}</span>

// GetTraceID returns the trace ID from the current span in context
func GetTraceID(ctx context.Context) string <span class="cov3" title="2">{
        span := SpanFromContext(ctx)
        if !span.SpanContext().IsValid() </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">return span.SpanContext().TraceID().String()</span>
}

// GetSpanID returns the span ID from the current span in context
func GetSpanID(ctx context.Context) string <span class="cov3" title="2">{
        span := SpanFromContext(ctx)
        if !span.SpanContext().IsValid() </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">return span.SpanContext().SpanID().String()</span>
}

// StringAttribute creates a string attribute for tracing
func StringAttribute(key, value string) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.String(key, value)
}</span>

// IntAttribute creates an int attribute for tracing
func IntAttribute(key string, value int) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Int(key, value)
}</span>

// BoolAttribute creates a bool attribute for tracing
func BoolAttribute(key string, value bool) attribute.KeyValue <span class="cov0" title="0">{
        return attribute.Bool(key, value)
}</span>
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
