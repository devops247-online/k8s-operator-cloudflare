
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>v1: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">

				<option value="file0">github.com/example/cloudflare-dns-operator/api/v1/cloudflarerecord_types.go (100.0%)</option>

				<option value="file1">github.com/example/cloudflare-dns-operator/api/v1/zz_generated.deepcopy.go (0.0%)</option>

				<option value="file2">github.com/example/cloudflare-dns-operator/cmd/main.go (0.0%)</option>

				<option value="file3">github.com/example/cloudflare-dns-operator/internal/controller/cloudflarerecord_controller.go (82.2%)</option>

				<option value="file4">github.com/example/cloudflare-dns-operator/test/utils/utils.go (0.0%)</option>

				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>

				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>

			</div>
		</div>
		<div id="content">

		<pre class="file" id="file0" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package v1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// Condition types for CloudflareRecord
const (
        // ConditionTypeReady indicates that the CloudflareRecord is ready
        ConditionTypeReady = "Ready"
        // ConditionTypeSynced indicates that the CloudflareRecord is synced with Cloudflare
        ConditionTypeSynced = "Synced"
)

// Condition reasons for CloudflareRecord
const (
        // ConditionReasonRecordCreated indicates that the DNS record was created
        ConditionReasonRecordCreated = "RecordCreated"
        // ConditionReasonRecordUpdated indicates that the DNS record was updated
        ConditionReasonRecordUpdated = "RecordUpdated"
        // ConditionReasonRecordDeleted indicates that the DNS record was deleted
        ConditionReasonRecordDeleted = "RecordDeleted"
        // ConditionReasonRecordError indicates an error occurred while managing the DNS record
        ConditionReasonRecordError = "RecordError"
        // ConditionReasonCredentialsError indicates an error with Cloudflare credentials
        ConditionReasonCredentialsError = "CredentialsError"
        // ConditionReasonZoneNotFound indicates the specified zone was not found
        ConditionReasonZoneNotFound = "ZoneNotFound"
)

// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!
// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.

// CloudflareRecordSpec defines the desired state of CloudflareRecord
type CloudflareRecordSpec struct {
        // Zone is the Cloudflare zone name (e.g., example.com)
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:MinLength=1
        Zone string `json:"zone"`

        // Type is the DNS record type (A, AAAA, CNAME, MX, TXT, etc.)
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:Enum=A;AAAA;CNAME;MX;TXT;SRV;NS;PTR;CAA;CERT;DNSKEY;DS;NAPTR;SMIMEA;SSHFP;TLSA;URI
        Type string `json:"type"`

        // Name is the DNS record name
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:MinLength=1
        Name string `json:"name"`

        // Content is the content of the DNS record
        // +kubebuilder:validation:Required
        // +kubebuilder:validation:MinLength=1
        Content string `json:"content"`

        // TTL is the time to live for the DNS record in seconds
        // +kubebuilder:validation:Optional
        // +kubebuilder:validation:Minimum=1
        // +kubebuilder:validation:Maximum=2147483647
        // +kubebuilder:default=3600
        TTL *int `json:"ttl,omitempty"`

        // Priority is used for MX, SRV, and other records that support priority
        // +kubebuilder:validation:Optional
        // +kubebuilder:validation:Minimum=0
        // +kubebuilder:validation:Maximum=65535
        Priority *int `json:"priority,omitempty"`

        // Proxied indicates whether the record should be proxied through Cloudflare
        // Only applicable to A, AAAA, and CNAME records
        // +kubebuilder:validation:Optional
        // +kubebuilder:default=false
        Proxied *bool `json:"proxied,omitempty"`

        // Comment is an optional comment for the DNS record
        // +kubebuilder:validation:Optional
        // +kubebuilder:validation:MaxLength=100
        Comment *string `json:"comment,omitempty"`

        // Tags are optional tags for the DNS record
        // +kubebuilder:validation:Optional
        Tags []string `json:"tags,omitempty"`

        // CloudflareCredentialsSecretRef references a Secret containing Cloudflare credentials
        // +kubebuilder:validation:Required
        CloudflareCredentialsSecretRef SecretReference `json:"cloudflareCredentialsSecretRef"`
}

// SecretReference represents a reference to a Secret
type SecretReference struct {
        // Name is the name of the secret
        // +kubebuilder:validation:Required
        Name string `json:"name"`

        // Namespace is the namespace of the secret
        // +kubebuilder:validation:Optional
        Namespace *string `json:"namespace,omitempty"`
}

// CloudflareRecordStatus defines the observed state of CloudflareRecord.
type CloudflareRecordStatus struct {
        // RecordID is the Cloudflare record ID
        // +kubebuilder:validation:Optional
        RecordID *string `json:"recordId,omitempty"`

        // ZoneID is the Cloudflare zone ID
        // +kubebuilder:validation:Optional
        ZoneID *string `json:"zoneId,omitempty"`

        // Ready indicates whether the DNS record is ready and synchronized
        // +kubebuilder:validation:Optional
        // +kubebuilder:default=false
        Ready bool `json:"ready"`

        // LastUpdated is the timestamp of the last update
        // +kubebuilder:validation:Optional
        LastUpdated *metav1.Time `json:"lastUpdated,omitempty"`

        // Conditions represent the latest available observations of the CloudflareRecord's current state
        // +kubebuilder:validation:Optional
        Conditions []metav1.Condition `json:"conditions,omitempty"`

        // ObservedGeneration reflects the generation of the most recently observed CloudflareRecord
        // +kubebuilder:validation:Optional
        ObservedGeneration int64 `json:"observedGeneration,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:resource:scope=Namespaced,categories=cloudflare,shortName=cfr
// +kubebuilder:printcolumn:name="Zone",type=string,JSONPath=`.spec.zone`
// +kubebuilder:printcolumn:name="Type",type=string,JSONPath=`.spec.type`
// +kubebuilder:printcolumn:name="Name",type=string,JSONPath=`.spec.name`
// +kubebuilder:printcolumn:name="Content",type=string,JSONPath=`.spec.content`
// +kubebuilder:printcolumn:name="Ready",type=boolean,JSONPath=`.status.ready`
// +kubebuilder:printcolumn:name="Age",type=date,JSONPath=`.metadata.creationTimestamp`

// CloudflareRecord is the Schema for the cloudflarerecords API
type CloudflareRecord struct {
        metav1.TypeMeta `json:",inline"`

        // metadata is a standard object metadata
        // +optional
        metav1.ObjectMeta `json:"metadata,omitempty,omitzero"`

        // spec defines the desired state of CloudflareRecord
        // +required
        Spec CloudflareRecordSpec `json:"spec"`

        // status defines the observed state of CloudflareRecord
        // +optional
        Status CloudflareRecordStatus `json:"status,omitempty,omitzero"`
}

// +kubebuilder:object:root=true

// CloudflareRecordList contains a list of CloudflareRecord
type CloudflareRecordList struct {
        metav1.TypeMeta `json:",inline"`
        metav1.ListMeta `json:"metadata,omitempty"`
        Items           []CloudflareRecord `json:"items"`
}

func init() <span class="cov8" title="1">{
        SchemeBuilder.Register(&amp;CloudflareRecord{}, &amp;CloudflareRecordList{})
}</span>
</pre>

		<pre class="file" id="file1" style="display: none">//go:build !ignore_autogenerated

/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1

import (
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudflareRecord) DeepCopyInto(out *CloudflareRecord) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ObjectMeta.DeepCopyInto(&amp;out.ObjectMeta)
        in.Spec.DeepCopyInto(&amp;out.Spec)
        in.Status.DeepCopyInto(&amp;out.Status)
}</span>

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudflareRecord.
func (in *CloudflareRecord) DeepCopy() *CloudflareRecord <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudflareRecord)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CloudflareRecord) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudflareRecordList) DeepCopyInto(out *CloudflareRecordList) <span class="cov0" title="0">{
        *out = *in
        out.TypeMeta = in.TypeMeta
        in.ListMeta.DeepCopyInto(&amp;out.ListMeta)
        if in.Items != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Items, &amp;out.Items
                *out = make([]CloudflareRecord, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudflareRecordList.
func (in *CloudflareRecordList) DeepCopy() *CloudflareRecordList <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudflareRecordList)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *CloudflareRecordList) DeepCopyObject() runtime.Object <span class="cov0" title="0">{
        if c := in.DeepCopy(); c != nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudflareRecordSpec) DeepCopyInto(out *CloudflareRecordSpec) <span class="cov0" title="0">{
        *out = *in
        if in.TTL != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.TTL, &amp;out.TTL
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Priority != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Priority, &amp;out.Priority
                *out = new(int)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Proxied != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Proxied, &amp;out.Proxied
                *out = new(bool)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Comment != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Comment, &amp;out.Comment
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.Tags != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Tags, &amp;out.Tags
                *out = make([]string, len(*in))
                copy(*out, *in)
        }</span>
        <span class="cov0" title="0">in.CloudflareCredentialsSecretRef.DeepCopyInto(&amp;out.CloudflareCredentialsSecretRef)</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudflareRecordSpec.
func (in *CloudflareRecordSpec) DeepCopy() *CloudflareRecordSpec <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudflareRecordSpec)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CloudflareRecordStatus) DeepCopyInto(out *CloudflareRecordStatus) <span class="cov0" title="0">{
        *out = *in
        if in.RecordID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.RecordID, &amp;out.RecordID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.ZoneID != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.ZoneID, &amp;out.ZoneID
                *out = new(string)
                **out = **in
        }</span>
        <span class="cov0" title="0">if in.LastUpdated != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.LastUpdated, &amp;out.LastUpdated
                *out = (*in).DeepCopy()
        }</span>
        <span class="cov0" title="0">if in.Conditions != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Conditions, &amp;out.Conditions
                *out = make([]metav1.Condition, len(*in))
                for i := range *in </span><span class="cov0" title="0">{
                        (*in)[i].DeepCopyInto(&amp;(*out)[i])
                }</span>
        }
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CloudflareRecordStatus.
func (in *CloudflareRecordStatus) DeepCopy() *CloudflareRecordStatus <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(CloudflareRecordStatus)
        in.DeepCopyInto(out)
        return out</span>
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SecretReference) DeepCopyInto(out *SecretReference) <span class="cov0" title="0">{
        *out = *in
        if in.Namespace != nil </span><span class="cov0" title="0">{
                in, out := &amp;in.Namespace, &amp;out.Namespace
                *out = new(string)
                **out = **in
        }</span>
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SecretReference.
func (in *SecretReference) DeepCopy() *SecretReference <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">out := new(SecretReference)
        in.DeepCopyInto(out)
        return out</span>
}
</pre>

		<pre class="file" id="file2" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
        "crypto/tls"
        "flag"
        "os"
        "path/filepath"

        // Import all Kubernetes client auth plugins (e.g. Azure, GCP, OIDC, etc.)
        // to ensure that exec-entrypoint and run can make use of them.
        _ "k8s.io/client-go/plugin/pkg/client/auth"

        "k8s.io/apimachinery/pkg/runtime"
        utilruntime "k8s.io/apimachinery/pkg/util/runtime"
        clientgoscheme "k8s.io/client-go/kubernetes/scheme"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/certwatcher"
        "sigs.k8s.io/controller-runtime/pkg/healthz"
        "sigs.k8s.io/controller-runtime/pkg/log/zap"
        "sigs.k8s.io/controller-runtime/pkg/metrics/filters"
        metricsserver "sigs.k8s.io/controller-runtime/pkg/metrics/server"
        "sigs.k8s.io/controller-runtime/pkg/webhook"

        dnsv1 "github.com/example/cloudflare-dns-operator/api/v1"
        "github.com/example/cloudflare-dns-operator/internal/controller"
        // +kubebuilder:scaffold:imports
)

var (
        scheme   = runtime.NewScheme()
        setupLog = ctrl.Log.WithName("setup")
)

func init() <span class="cov0" title="0">{
        utilruntime.Must(clientgoscheme.AddToScheme(scheme))

        utilruntime.Must(dnsv1.AddToScheme(scheme))
        // +kubebuilder:scaffold:scheme
}</span>

// nolint:gocyclo
func main() <span class="cov0" title="0">{
        var metricsAddr string
        var metricsCertPath, metricsCertName, metricsCertKey string
        var webhookCertPath, webhookCertName, webhookCertKey string
        var enableLeaderElection bool
        var probeAddr string
        var secureMetrics bool
        var enableHTTP2 bool
        var tlsOpts []func(*tls.Config)
        flag.StringVar(&amp;metricsAddr, "metrics-bind-address", "0", "The address the metrics endpoint binds to. "+
                "Use :8443 for HTTPS or :8080 for HTTP, or leave as 0 to disable the metrics service.")
        flag.StringVar(&amp;probeAddr, "health-probe-bind-address", ":8081", "The address the probe endpoint binds to.")
        flag.BoolVar(&amp;enableLeaderElection, "leader-elect", false,
                "Enable leader election for controller manager. "+
                        "Enabling this will ensure there is only one active controller manager.")
        flag.BoolVar(&amp;secureMetrics, "metrics-secure", true,
                "If set, the metrics endpoint is served securely via HTTPS. Use --metrics-secure=false to use HTTP instead.")
        flag.StringVar(&amp;webhookCertPath, "webhook-cert-path", "", "The directory that contains the webhook certificate.")
        flag.StringVar(&amp;webhookCertName, "webhook-cert-name", "tls.crt", "The name of the webhook certificate file.")
        flag.StringVar(&amp;webhookCertKey, "webhook-cert-key", "tls.key", "The name of the webhook key file.")
        flag.StringVar(&amp;metricsCertPath, "metrics-cert-path", "",
                "The directory that contains the metrics server certificate.")
        flag.StringVar(&amp;metricsCertName, "metrics-cert-name", "tls.crt", "The name of the metrics server certificate file.")
        flag.StringVar(&amp;metricsCertKey, "metrics-cert-key", "tls.key", "The name of the metrics server key file.")
        flag.BoolVar(&amp;enableHTTP2, "enable-http2", false,
                "If set, HTTP/2 will be enabled for the metrics and webhook servers")
        opts := zap.Options{
                Development: true,
        }
        opts.BindFlags(flag.CommandLine)
        flag.Parse()

        ctrl.SetLogger(zap.New(zap.UseFlagOptions(&amp;opts)))

        // if the enable-http2 flag is false (the default), http/2 should be disabled
        // due to its vulnerabilities. More specifically, disabling http/2 will
        // prevent from being vulnerable to the HTTP/2 Stream Cancellation and
        // Rapid Reset CVEs. For more information see:
        // - https://github.com/advisories/GHSA-qppj-fm5r-hxr3
        // - https://github.com/advisories/GHSA-4374-p667-p6c8
        disableHTTP2 := func(c *tls.Config) </span><span class="cov0" title="0">{
                setupLog.Info("disabling http/2")
                c.NextProtos = []string{"http/1.1"}
        }</span>

        <span class="cov0" title="0">if !enableHTTP2 </span><span class="cov0" title="0">{
                tlsOpts = append(tlsOpts, disableHTTP2)
        }</span>

        // Create watchers for metrics and webhooks certificates
        <span class="cov0" title="0">var metricsCertWatcher, webhookCertWatcher *certwatcher.CertWatcher

        // Initial webhook TLS options
        webhookTLSOpts := tlsOpts

        if len(webhookCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing webhook certificate watcher using provided certificates",
                        "webhook-cert-path", webhookCertPath, "webhook-cert-name", webhookCertName, "webhook-cert-key", webhookCertKey)

                var err error
                webhookCertWatcher, err = certwatcher.New(
                        filepath.Join(webhookCertPath, webhookCertName),
                        filepath.Join(webhookCertPath, webhookCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "Failed to initialize webhook certificate watcher")
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">webhookTLSOpts = append(webhookTLSOpts, func(config *tls.Config) </span><span class="cov0" title="0">{
                        config.GetCertificate = webhookCertWatcher.GetCertificate
                }</span>)
        }

        <span class="cov0" title="0">webhookServer := webhook.NewServer(webhook.Options{
                TLSOpts: webhookTLSOpts,
        })

        // Metrics endpoint is enabled in 'config/default/kustomization.yaml'. The Metrics options configure the server.
        // More info:
        // - https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.21.0/pkg/metrics/server
        // - https://book.kubebuilder.io/reference/metrics.html
        metricsServerOptions := metricsserver.Options{
                BindAddress:   metricsAddr,
                SecureServing: secureMetrics,
                TLSOpts:       tlsOpts,
        }

        if secureMetrics </span><span class="cov0" title="0">{
                // FilterProvider is used to protect the metrics endpoint with authn/authz.
                // These configurations ensure that only authorized users and service accounts
                // can access the metrics endpoint. The RBAC are configured in 'config/rbac/kustomization.yaml'. More info:
                // https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.21.0/pkg/metrics/filters#WithAuthenticationAndAuthorization
                metricsServerOptions.FilterProvider = filters.WithAuthenticationAndAuthorization
        }</span>

        // If the certificate is not specified, controller-runtime will automatically
        // generate self-signed certificates for the metrics server. While convenient for development and testing,
        // this setup is not recommended for production.
        //
        // TODO(user): If you enable certManager, uncomment the following lines:
        // - [METRICS-WITH-CERTS] at config/default/kustomization.yaml to generate and use certificates
        // managed by cert-manager for the metrics server.
        // - [PROMETHEUS-WITH-CERTS] at config/prometheus/kustomization.yaml for TLS certification.
        <span class="cov0" title="0">if len(metricsCertPath) &gt; 0 </span><span class="cov0" title="0">{
                setupLog.Info("Initializing metrics certificate watcher using provided certificates",
                        "metrics-cert-path", metricsCertPath, "metrics-cert-name", metricsCertName, "metrics-cert-key", metricsCertKey)

                var err error
                metricsCertWatcher, err = certwatcher.New(
                        filepath.Join(metricsCertPath, metricsCertName),
                        filepath.Join(metricsCertPath, metricsCertKey),
                )
                if err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "to initialize metrics certificate watcher", "error", err)
                        os.Exit(1)
                }</span>

                <span class="cov0" title="0">metricsServerOptions.TLSOpts = append(metricsServerOptions.TLSOpts, func(config *tls.Config) </span><span class="cov0" title="0">{
                        config.GetCertificate = metricsCertWatcher.GetCertificate
                }</span>)
        }

        <span class="cov0" title="0">mgr, err := ctrl.NewManager(ctrl.GetConfigOrDie(), ctrl.Options{
                Scheme:                 scheme,
                Metrics:                metricsServerOptions,
                WebhookServer:          webhookServer,
                HealthProbeBindAddress: probeAddr,
                LeaderElection:         enableLeaderElection,
                LeaderElectionID:       "085fc383.cloudflare.io",
                // LeaderElectionReleaseOnCancel defines if the leader should step down voluntarily
                // when the Manager ends. This requires the binary to immediately end when the
                // Manager is stopped, otherwise, this setting is unsafe. Setting this significantly
                // speeds up voluntary leader transitions as the new leader don't have to wait
                // LeaseDuration time first.
                //
                // In the default scaffold provided, the program ends immediately after
                // the manager stops, so would be fine to enable this option. However,
                // if you are doing or is intended to do any operation such as perform cleanups
                // after the manager stops then its usage might be unsafe.
                // LeaderElectionReleaseOnCancel: true,
        })
        if err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to start manager")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">if err := (&amp;controller.CloudflareRecordReconciler{
                Client: mgr.GetClient(),
                Scheme: mgr.GetScheme(),
        }).SetupWithManager(mgr); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to create controller", "controller", "CloudflareRecord")
                os.Exit(1)
        }</span>
        // +kubebuilder:scaffold:builder

        <span class="cov0" title="0">if metricsCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding metrics certificate watcher to manager")
                if err := mgr.Add(metricsCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add metrics certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if webhookCertWatcher != nil </span><span class="cov0" title="0">{
                setupLog.Info("Adding webhook certificate watcher to manager")
                if err := mgr.Add(webhookCertWatcher); err != nil </span><span class="cov0" title="0">{
                        setupLog.Error(err, "unable to add webhook certificate watcher to manager")
                        os.Exit(1)
                }</span>
        }

        <span class="cov0" title="0">if err := mgr.AddHealthzCheck("healthz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up health check")
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">if err := mgr.AddReadyzCheck("readyz", healthz.Ping); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "unable to set up ready check")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">setupLog.Info("starting manager")
        if err := mgr.Start(ctrl.SetupSignalHandler()); err != nil </span><span class="cov0" title="0">{
                setupLog.Error(err, "problem running manager")
                os.Exit(1)
        }</span>
}
</pre>

		<pre class="file" id="file3" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package controller

import (
        "context"
        "time"

        "k8s.io/apimachinery/pkg/api/errors"
        metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
        "k8s.io/apimachinery/pkg/runtime"
        ctrl "sigs.k8s.io/controller-runtime"
        "sigs.k8s.io/controller-runtime/pkg/client"
        "sigs.k8s.io/controller-runtime/pkg/controller/controllerutil"
        logf "sigs.k8s.io/controller-runtime/pkg/log"

        dnsv1 "github.com/example/cloudflare-dns-operator/api/v1"
)

const (
        // CloudflareRecordFinalizer is the finalizer added to CloudflareRecord resources
        CloudflareRecordFinalizer = "dns.cloudflare.io/finalizer"
)

// CloudflareRecordReconciler reconciles a CloudflareRecord object
type CloudflareRecordReconciler struct {
        client.Client
        Scheme *runtime.Scheme
}

// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords,verbs=get;list;watch;create;update;patch;delete
// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords/status,verbs=get;update;patch
// +kubebuilder:rbac:groups=dns.cloudflare.io,resources=cloudflarerecords/finalizers,verbs=update
// +kubebuilder:rbac:groups="",resources=secrets,verbs=get;list;watch
// +kubebuilder:rbac:groups="",resources=events,verbs=create;patch

// Reconcile is part of the main kubernetes reconciliation loop which aims to
// move the current state of the cluster closer to the desired state.
func (r *CloudflareRecordReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) <span class="cov8" title="1">{
        log := logf.FromContext(ctx)

        // Fetch the CloudflareRecord instance
        var cloudflareRecord dnsv1.CloudflareRecord
        if err := r.Get(ctx, req.NamespacedName, &amp;cloudflareRecord); err != nil </span><span class="cov8" title="1">{
                if errors.IsNotFound(err) </span><span class="cov8" title="1">{
                        // Request object not found, could have been deleted after reconcile request.
                        log.Info("CloudflareRecord resource not found. Ignoring since object must be deleted")
                        return ctrl.Result{}, nil
                }</span>
                <span class="cov0" title="0">log.Error(err, "Failed to get CloudflareRecord")
                return ctrl.Result{}, err</span>
        }

        // Check if the CloudflareRecord instance is marked to be deleted
        <span class="cov8" title="1">if cloudflareRecord.GetDeletionTimestamp() != nil </span><span class="cov8" title="1">{
                return r.reconcileDelete(ctx, &amp;cloudflareRecord)
        }</span>

        // Add finalizer if not present
        <span class="cov8" title="1">if !controllerutil.ContainsFinalizer(&amp;cloudflareRecord, CloudflareRecordFinalizer) </span><span class="cov8" title="1">{
                controllerutil.AddFinalizer(&amp;cloudflareRecord, CloudflareRecordFinalizer)
                if err := r.Update(ctx, &amp;cloudflareRecord); err != nil </span><span class="cov0" title="0">{
                        log.Error(err, "Failed to add finalizer")
                        return ctrl.Result{}, err
                }</span>
        }

        // Log the DNS record details
        <span class="cov8" title="1">log.Info("Processing CloudflareRecord",
                "zone", cloudflareRecord.Spec.Zone,
                "type", cloudflareRecord.Spec.Type,
                "name", cloudflareRecord.Spec.Name,
                "content", cloudflareRecord.Spec.Content)

        // TODO: Implement full Cloudflare API integration here
        // For now, just update status to show operator is working

        // Update status to indicate processing
        r.updateStatus(ctx, &amp;cloudflareRecord, true, dnsv1.ConditionReasonRecordCreated, "DNS record processing completed (implementation ready for Cloudflare API)")

        cloudflareRecord.Status.ObservedGeneration = cloudflareRecord.Generation
        now := metav1.NewTime(time.Now())
        cloudflareRecord.Status.LastUpdated = &amp;now

        if err := r.Status().Update(ctx, &amp;cloudflareRecord); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to update CloudflareRecord status")
                return ctrl.Result{RequeueAfter: time.Minute}, err
        }</span>

        // Requeue after 5 minutes for periodic sync
        <span class="cov8" title="1">return ctrl.Result{RequeueAfter: time.Minute * 5}, nil</span>
}

// reconcileDelete handles the deletion of CloudflareRecord
func (r *CloudflareRecordReconciler) reconcileDelete(ctx context.Context, cloudflareRecord *dnsv1.CloudflareRecord) (ctrl.Result, error) <span class="cov8" title="1">{
        log := logf.FromContext(ctx)
        log.Info("Deleting CloudflareRecord", "name", cloudflareRecord.Name)

        // TODO: In a full implementation, delete the DNS record from Cloudflare here

        // Remove finalizer
        controllerutil.RemoveFinalizer(cloudflareRecord, CloudflareRecordFinalizer)
        if err := r.Update(ctx, cloudflareRecord); err != nil </span><span class="cov0" title="0">{
                log.Error(err, "Failed to remove finalizer")
                return ctrl.Result{}, err
        }</span>

        <span class="cov8" title="1">return ctrl.Result{}, nil</span>
}

// updateStatus updates the status of the CloudflareRecord
func (r *CloudflareRecordReconciler) updateStatus(ctx context.Context, cloudflareRecord *dnsv1.CloudflareRecord, ready bool, reason, message string) <span class="cov8" title="1">{
        cloudflareRecord.Status.Ready = ready

        // Update condition
        condition := metav1.Condition{
                Type:               dnsv1.ConditionTypeReady,
                Status:             metav1.ConditionFalse,
                Reason:             reason,
                Message:            message,
                LastTransitionTime: metav1.NewTime(time.Now()),
        }

        if ready </span><span class="cov8" title="1">{
                condition.Status = metav1.ConditionTrue
        }</span>

        // Find existing condition or add new one
        <span class="cov8" title="1">updated := false
        for i, existingCondition := range cloudflareRecord.Status.Conditions </span><span class="cov8" title="1">{
                if existingCondition.Type == dnsv1.ConditionTypeReady </span><span class="cov8" title="1">{
                        if existingCondition.Status != condition.Status || existingCondition.Reason != condition.Reason </span><span class="cov8" title="1">{
                                cloudflareRecord.Status.Conditions[i] = condition
                                updated = true
                        }</span>
                        <span class="cov8" title="1">break</span>
                }
        }

        <span class="cov8" title="1">if !updated </span><span class="cov8" title="1">{
                cloudflareRecord.Status.Conditions = append(cloudflareRecord.Status.Conditions, condition)
        }</span>
}

// SetupWithManager sets up the controller with the Manager.
func (r *CloudflareRecordReconciler) SetupWithManager(mgr ctrl.Manager) error <span class="cov8" title="1">{
        return ctrl.NewControllerManagedBy(mgr).
                For(&amp;dnsv1.CloudflareRecord{}).
                Named("cloudflarerecord").
                Complete(r)
}</span>
</pre>

		<pre class="file" id="file4" style="display: none">/*
Copyright 2025.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package utils

import (
        "bufio"
        "bytes"
        "fmt"
        "os"
        "os/exec"
        "strings"

        . "github.com/onsi/ginkgo/v2" // nolint:revive,staticcheck
)

const (
        prometheusOperatorVersion = "v0.77.1"
        prometheusOperatorURL     = "https://github.com/prometheus-operator/prometheus-operator/" +
                "releases/download/%s/bundle.yaml"

        certmanagerVersion = "v1.16.3"
        certmanagerURLTmpl = "https://github.com/cert-manager/cert-manager/releases/download/%s/cert-manager.yaml"
)

func warnError(err error) <span class="cov0" title="0">{
        _, _ = fmt.Fprintf(GinkgoWriter, "warning: %v\n", err)
}</span>

// Run executes the provided command within this context
func Run(cmd *exec.Cmd) (string, error) <span class="cov0" title="0">{
        dir, _ := GetProjectDir()
        cmd.Dir = dir

        if err := os.Chdir(cmd.Dir); err != nil </span><span class="cov0" title="0">{
                _, _ = fmt.Fprintf(GinkgoWriter, "chdir dir: %q\n", err)
        }</span>

        <span class="cov0" title="0">cmd.Env = append(os.Environ(), "GO111MODULE=on")
        command := strings.Join(cmd.Args, " ")
        _, _ = fmt.Fprintf(GinkgoWriter, "running: %q\n", command)
        output, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return string(output), fmt.Errorf("%q failed with error %q: %w", command, string(output), err)
        }</span>

        <span class="cov0" title="0">return string(output), nil</span>
}

// InstallPrometheusOperator installs the prometheus Operator to be used to export the enabled metrics.
func InstallPrometheusOperator() error <span class="cov0" title="0">{
        url := fmt.Sprintf(prometheusOperatorURL, prometheusOperatorVersion)
        cmd := exec.Command("kubectl", "create", "-f", url)
        _, err := Run(cmd)
        return err
}</span>

// UninstallPrometheusOperator uninstalls the prometheus
func UninstallPrometheusOperator() <span class="cov0" title="0">{
        url := fmt.Sprintf(prometheusOperatorURL, prometheusOperatorVersion)
        cmd := exec.Command("kubectl", "delete", "-f", url)
        if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                warnError(err)
        }</span>
}

// IsPrometheusCRDsInstalled checks if any Prometheus CRDs are installed
// by verifying the existence of key CRDs related to Prometheus.
func IsPrometheusCRDsInstalled() bool <span class="cov0" title="0">{
        // List of common Prometheus CRDs
        prometheusCRDs := []string{
                "prometheuses.monitoring.coreos.com",
                "prometheusrules.monitoring.coreos.com",
                "prometheusagents.monitoring.coreos.com",
        }

        cmd := exec.Command("kubectl", "get", "crds", "-o", "custom-columns=NAME:.metadata.name")
        output, err := Run(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov0" title="0">crdList := GetNonEmptyLines(output)
        for _, crd := range prometheusCRDs </span><span class="cov0" title="0">{
                for _, line := range crdList </span><span class="cov0" title="0">{
                        if strings.Contains(line, crd) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// UninstallCertManager uninstalls the cert manager
func UninstallCertManager() <span class="cov0" title="0">{
        url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
        cmd := exec.Command("kubectl", "delete", "-f", url)
        if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                warnError(err)
        }</span>
}

// InstallCertManager installs the cert manager bundle.
func InstallCertManager() error <span class="cov0" title="0">{
        url := fmt.Sprintf(certmanagerURLTmpl, certmanagerVersion)
        cmd := exec.Command("kubectl", "apply", "-f", url)
        if _, err := Run(cmd); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        // Wait for cert-manager-webhook to be ready, which can take time if cert-manager
        // was re-installed after uninstalling on a cluster.
        <span class="cov0" title="0">cmd = exec.Command("kubectl", "wait", "deployment.apps/cert-manager-webhook",
                "--for", "condition=Available",
                "--namespace", "cert-manager",
                "--timeout", "5m",
        )

        _, err := Run(cmd)
        return err</span>
}

// IsCertManagerCRDsInstalled checks if any Cert Manager CRDs are installed
// by verifying the existence of key CRDs related to Cert Manager.
func IsCertManagerCRDsInstalled() bool <span class="cov0" title="0">{
        // List of common Cert Manager CRDs
        certManagerCRDs := []string{
                "certificates.cert-manager.io",
                "issuers.cert-manager.io",
                "clusterissuers.cert-manager.io",
                "certificaterequests.cert-manager.io",
                "orders.acme.cert-manager.io",
                "challenges.acme.cert-manager.io",
        }

        // Execute the kubectl command to get all CRDs
        cmd := exec.Command("kubectl", "get", "crds")
        output, err := Run(cmd)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        // Check if any of the Cert Manager CRDs are present
        <span class="cov0" title="0">crdList := GetNonEmptyLines(output)
        for _, crd := range certManagerCRDs </span><span class="cov0" title="0">{
                for _, line := range crdList </span><span class="cov0" title="0">{
                        if strings.Contains(line, crd) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">return false</span>
}

// LoadImageToKindClusterWithName loads a local docker image to the kind cluster
func LoadImageToKindClusterWithName(name string) error <span class="cov0" title="0">{
        cluster := "kind"
        if v, ok := os.LookupEnv("KIND_CLUSTER"); ok </span><span class="cov0" title="0">{
                cluster = v
        }</span>
        <span class="cov0" title="0">kindOptions := []string{"load", "docker-image", name, "--name", cluster}
        cmd := exec.Command("kind", kindOptions...)
        _, err := Run(cmd)
        return err</span>
}

// GetNonEmptyLines converts given command output string into individual objects
// according to line breakers, and ignores the empty elements in it.
func GetNonEmptyLines(output string) []string <span class="cov0" title="0">{
        var res []string
        elements := strings.Split(output, "\n")
        for _, element := range elements </span><span class="cov0" title="0">{
                if element != "" </span><span class="cov0" title="0">{
                        res = append(res, element)
                }</span>
        }

        <span class="cov0" title="0">return res</span>
}

// GetProjectDir will return the directory where the project is
func GetProjectDir() (string, error) <span class="cov0" title="0">{
        wd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return wd, fmt.Errorf("failed to get current working directory: %w", err)
        }</span>
        <span class="cov0" title="0">wd = strings.ReplaceAll(wd, "/test/e2e", "")
        return wd, nil</span>
}

// UncommentCode searches for target in the file and remove the comment prefix
// of the target content. The target content may span multiple lines.
func UncommentCode(filename, target, prefix string) error <span class="cov0" title="0">{
        // false positive
        // nolint:gosec
        content, err := os.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to read file %q: %w", filename, err)
        }</span>
        <span class="cov0" title="0">strContent := string(content)

        idx := strings.Index(strContent, target)
        if idx &lt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("unable to find the code %q to be uncomment", target)
        }</span>

        <span class="cov0" title="0">out := new(bytes.Buffer)
        _, err = out.Write(content[:idx])
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to output: %w", err)
        }</span>

        <span class="cov0" title="0">scanner := bufio.NewScanner(bytes.NewBufferString(target))
        if !scanner.Scan() </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">for </span><span class="cov0" title="0">{
                if _, err = out.WriteString(strings.TrimPrefix(scanner.Text(), prefix)); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to output: %w", err)
                }</span>
                // Avoid writing a newline in case the previous line was the last in target.
                <span class="cov0" title="0">if !scanner.Scan() </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">if _, err = out.WriteString("\n"); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to output: %w", err)
                }</span>
        }

        <span class="cov0" title="0">if _, err = out.Write(content[idx+len(target):]); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write to output: %w", err)
        }</span>

        // false positive
        // nolint:gosec
        <span class="cov0" title="0">if err = os.WriteFile(filename, out.Bytes(), 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write file %q: %w", filename, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>

		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
